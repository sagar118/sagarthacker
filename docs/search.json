[
  {
    "objectID": "kaggle.html",
    "href": "kaggle.html",
    "title": "Kaggle Competitions",
    "section": "",
    "text": "Playground Series Season 3, Episode 4\n\nExploratory Data Analysis\nEnsemble Model"
  },
  {
    "objectID": "posts/kaggle/pss3e3-eda.html",
    "href": "posts/kaggle/pss3e3-eda.html",
    "title": "EDA - Playground Series Season 3, Episode 4",
    "section": "",
    "text": "Code\n# Import libraries\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\npd.options.display.max_columns = None\n%matplotlib inline"
  },
  {
    "objectID": "posts/kaggle/pss3e3-eda.html#data-description",
    "href": "posts/kaggle/pss3e3-eda.html#data-description",
    "title": "EDA - Playground Series Season 3, Episode 4",
    "section": "1. Data Description",
    "text": "1. Data Description\nThe dataset for this competition (both train and test) was generated from a deep learning model trained on the Credit Card Fraud Detection. Feature distributions are close to, but not exactly the same, as the original.\nWe are given three files:\n\ntrain.csv - the training dataset; Class is the target\ntest.csv - the test dataset; our objective is to predict Class\nsample_submission.csv - a sample submission file in the correct format\n\nDescription of each column:\n\nFeature Description\n\n\n\n\n\n\nFeature\nDescription\n\n\n\n\nid\nIndentifier for unique rows\n\n\nTime\nNumber of seconds elapsed between this transaction and the first transaction in the dataset\n\n\nV1-V28\nFeatures generated from the original dataset\n\n\nAmount\nTransaction amount\n\n\nClass\nTarget Feature: 1 for fraudulent transactions, 0 otherwise"
  },
  {
    "objectID": "posts/kaggle/pss3e3-eda.html#overview-and-structure",
    "href": "posts/kaggle/pss3e3-eda.html#overview-and-structure",
    "title": "EDA - Playground Series Season 3, Episode 4",
    "section": "2. Overview and Structure",
    "text": "2. Overview and Structure\n\n__dirname = '../input/playground-series-s3e4/'\n\ntrain = pd.read_csv(__dirname + 'train.csv')\ntest = pd.read_csv(__dirname + 'test.csv')\n\n\n# Display top 5 rows of train set\ntrain.head()\n\n\n\n\n\n  \n    \n      \n      id\n      Time\n      V1\n      V2\n      V3\n      V4\n      V5\n      V6\n      V7\n      V8\n      V9\n      V10\n      V11\n      V12\n      V13\n      V14\n      V15\n      V16\n      V17\n      V18\n      V19\n      V20\n      V21\n      V22\n      V23\n      V24\n      V25\n      V26\n      V27\n      V28\n      Amount\n      Class\n    \n  \n  \n    \n      0\n      0\n      0.0\n      2.074329\n      -0.129425\n      -1.137418\n      0.412846\n      -0.192638\n      -1.210144\n      0.110697\n      -0.263477\n      0.742144\n      0.108782\n      -1.070243\n      -0.234910\n      -1.099360\n      0.502467\n      0.169318\n      0.065688\n      -0.306957\n      -0.323800\n      0.103348\n      -0.292969\n      -0.334701\n      -0.887840\n      0.336701\n      -0.110835\n      -0.291459\n      0.207733\n      -0.076576\n      -0.059577\n      1.98\n      0\n    \n    \n      1\n      1\n      0.0\n      1.998827\n      -1.250891\n      -0.520969\n      -0.894539\n      -1.122528\n      -0.270866\n      -1.029289\n      0.050198\n      -0.109948\n      0.908773\n      0.836798\n      -0.056580\n      -0.120990\n      -0.144028\n      -0.039582\n      1.653057\n      -0.253599\n      -0.814354\n      0.716784\n      0.065717\n      0.054848\n      -0.038367\n      0.133518\n      -0.461928\n      -0.465491\n      -0.464655\n      -0.009413\n      -0.038238\n      84.00\n      0\n    \n    \n      2\n      2\n      0.0\n      0.091535\n      1.004517\n      -0.223445\n      -0.435249\n      0.667548\n      -0.988351\n      0.948146\n      -0.084789\n      -0.042027\n      -0.818383\n      -0.376512\n      -0.226546\n      -0.552869\n      -0.886466\n      -0.180890\n      0.230286\n      0.590579\n      -0.321590\n      -0.433959\n      -0.021375\n      -0.326725\n      -0.803736\n      0.154495\n      0.951233\n      -0.506919\n      0.085046\n      0.224458\n      0.087356\n      2.69\n      0\n    \n    \n      3\n      3\n      0.0\n      1.979649\n      -0.184949\n      -1.064206\n      0.120125\n      -0.215238\n      -0.648829\n      -0.087826\n      -0.035367\n      0.885838\n      -0.007527\n      0.637441\n      0.676960\n      -1.504823\n      0.554039\n      -0.824356\n      -0.527267\n      -0.095838\n      -0.312519\n      0.642659\n      -0.340089\n      -0.095514\n      -0.079792\n      0.167701\n      -0.042939\n      0.000799\n      -0.096148\n      -0.057780\n      -0.073839\n      1.00\n      0\n    \n    \n      4\n      4\n      0.0\n      1.025898\n      -0.171827\n      1.203717\n      1.243900\n      -0.636572\n      1.099074\n      -0.938651\n      0.569239\n      0.692665\n      -0.097495\n      1.338869\n      1.391399\n      -0.128167\n      -0.081836\n      0.100548\n      -0.338937\n      0.090864\n      -0.423645\n      -0.731939\n      -0.203628\n      0.099157\n      0.608908\n      0.027901\n      -0.262813\n      0.257834\n      -0.252829\n      0.108338\n      0.021051\n      1.00\n      0\n    \n  \n\n\n\n\n\n2.1. Data Structure and Statistics\n\nprint(f\"Training set has {train.shape[0]} rows and {train.shape[1]} columns\")\nprint(f\"Testing set has {test.shape[0]} rows and {test.shape[1]} columns\")\n\nTraining set has 219129 rows and 32 columns\nTesting set has 146087 rows and 31 columns\n\n\n\ntrain.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 219129 entries, 0 to 219128\nData columns (total 32 columns):\n #   Column  Non-Null Count   Dtype  \n---  ------  --------------   -----  \n 0   id      219129 non-null  int64  \n 1   Time    219129 non-null  float64\n 2   V1      219129 non-null  float64\n 3   V2      219129 non-null  float64\n 4   V3      219129 non-null  float64\n 5   V4      219129 non-null  float64\n 6   V5      219129 non-null  float64\n 7   V6      219129 non-null  float64\n 8   V7      219129 non-null  float64\n 9   V8      219129 non-null  float64\n 10  V9      219129 non-null  float64\n 11  V10     219129 non-null  float64\n 12  V11     219129 non-null  float64\n 13  V12     219129 non-null  float64\n 14  V13     219129 non-null  float64\n 15  V14     219129 non-null  float64\n 16  V15     219129 non-null  float64\n 17  V16     219129 non-null  float64\n 18  V17     219129 non-null  float64\n 19  V18     219129 non-null  float64\n 20  V19     219129 non-null  float64\n 21  V20     219129 non-null  float64\n 22  V21     219129 non-null  float64\n 23  V22     219129 non-null  float64\n 24  V23     219129 non-null  float64\n 25  V24     219129 non-null  float64\n 26  V25     219129 non-null  float64\n 27  V26     219129 non-null  float64\n 28  V27     219129 non-null  float64\n 29  V28     219129 non-null  float64\n 30  Amount  219129 non-null  float64\n 31  Class   219129 non-null  int64  \ndtypes: float64(30), int64(2)\nmemory usage: 53.5 MB\n\n\n\ntest.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 146087 entries, 0 to 146086\nData columns (total 31 columns):\n #   Column  Non-Null Count   Dtype  \n---  ------  --------------   -----  \n 0   id      146087 non-null  int64  \n 1   Time    146087 non-null  float64\n 2   V1      146087 non-null  float64\n 3   V2      146087 non-null  float64\n 4   V3      146087 non-null  float64\n 5   V4      146087 non-null  float64\n 6   V5      146087 non-null  float64\n 7   V6      146087 non-null  float64\n 8   V7      146087 non-null  float64\n 9   V8      146087 non-null  float64\n 10  V9      146087 non-null  float64\n 11  V10     146087 non-null  float64\n 12  V11     146087 non-null  float64\n 13  V12     146087 non-null  float64\n 14  V13     146087 non-null  float64\n 15  V14     146087 non-null  float64\n 16  V15     146087 non-null  float64\n 17  V16     146087 non-null  float64\n 18  V17     146087 non-null  float64\n 19  V18     146087 non-null  float64\n 20  V19     146087 non-null  float64\n 21  V20     146087 non-null  float64\n 22  V21     146087 non-null  float64\n 23  V22     146087 non-null  float64\n 24  V23     146087 non-null  float64\n 25  V24     146087 non-null  float64\n 26  V25     146087 non-null  float64\n 27  V26     146087 non-null  float64\n 28  V27     146087 non-null  float64\n 29  V28     146087 non-null  float64\n 30  Amount  146087 non-null  float64\ndtypes: float64(30), int64(1)\nmemory usage: 34.6 MB\n\n\nWe find:\n\nAll the columns in the both train and test set are either int64 or float64.\nBased on the value for Non-Null we can observe we don’t have any missing values in our datasets.\nAs categorical type features are not present, it reduces some pain points while data preprocessing.\n\n\ntrain.describe()\n\n\n\n\n\n  \n    \n      \n      id\n      Time\n      V1\n      V2\n      V3\n      V4\n      V5\n      V6\n      V7\n      V8\n      V9\n      V10\n      V11\n      V12\n      V13\n      V14\n      V15\n      V16\n      V17\n      V18\n      V19\n      V20\n      V21\n      V22\n      V23\n      V24\n      V25\n      V26\n      V27\n      V28\n      Amount\n      Class\n    \n  \n  \n    \n      count\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n      219129.000000\n    \n    \n      mean\n      109564.000000\n      62377.415376\n      0.096008\n      0.048345\n      0.592102\n      0.069273\n      -0.161555\n      0.133688\n      -0.128224\n      0.149534\n      -0.048337\n      -0.039758\n      0.153632\n      -0.061038\n      0.014330\n      0.067649\n      0.108643\n      0.013650\n      0.036815\n      -0.033927\n      -0.008302\n      0.009708\n      -0.031064\n      -0.050852\n      -0.050531\n      -0.002992\n      0.124005\n      0.009881\n      0.014034\n      0.017313\n      66.359803\n      0.002140\n    \n    \n      std\n      63257.237906\n      25620.348569\n      1.395425\n      1.159805\n      1.132884\n      1.253125\n      1.069530\n      1.202411\n      0.817207\n      0.716212\n      1.054143\n      0.821889\n      0.976946\n      0.998470\n      1.039145\n      0.801335\n      0.891613\n      0.786654\n      0.691709\n      0.784454\n      0.739928\n      0.439521\n      0.422777\n      0.597812\n      0.318175\n      0.593100\n      0.406741\n      0.473867\n      0.233355\n      0.164859\n      150.795017\n      0.046214\n    \n    \n      min\n      0.000000\n      0.000000\n      -29.807725\n      -44.247914\n      -19.722872\n      -5.263650\n      -37.591259\n      -25.659750\n      -31.179799\n      -28.903442\n      -8.756951\n      -22.092656\n      -4.190145\n      -16.180165\n      -4.373778\n      -15.585021\n      -4.155728\n      -11.778839\n      -20.756768\n      -7.456060\n      -4.281628\n      -18.679066\n      -14.689621\n      -8.748979\n      -11.958588\n      -2.836285\n      -3.958591\n      -1.858672\n      -9.234767\n      -4.551680\n      0.000000\n      0.000000\n    \n    \n      25%\n      54782.000000\n      47933.000000\n      -0.846135\n      -0.573728\n      -0.027154\n      -0.769256\n      -0.847346\n      -0.631835\n      -0.646730\n      -0.095948\n      -0.711444\n      -0.499563\n      -0.576969\n      -0.476890\n      -0.671601\n      -0.329905\n      -0.461596\n      -0.461077\n      -0.406675\n      -0.496990\n      -0.463035\n      -0.167927\n      -0.190418\n      -0.473099\n      -0.174478\n      -0.332540\n      -0.126080\n      -0.318330\n      -0.050983\n      -0.009512\n      5.990000\n      0.000000\n    \n    \n      50%\n      109564.000000\n      63189.000000\n      0.385913\n      0.046937\n      0.735895\n      0.064856\n      -0.229929\n      -0.087778\n      -0.098970\n      0.111219\n      -0.131323\n      -0.106034\n      0.090545\n      0.087649\n      -0.016837\n      0.049266\n      0.178975\n      0.054550\n      -0.013949\n      -0.039451\n      -0.002935\n      -0.037702\n      -0.042858\n      -0.032856\n      -0.063307\n      0.038708\n      0.145934\n      -0.086388\n      0.015905\n      0.022163\n      21.900000\n      0.000000\n    \n    \n      75%\n      164346.000000\n      77519.000000\n      1.190661\n      0.814145\n      1.306110\n      0.919353\n      0.356856\n      0.482388\n      0.385567\n      0.390976\n      0.583715\n      0.403967\n      0.917392\n      0.608480\n      0.695547\n      0.460837\n      0.791255\n      0.531777\n      0.410978\n      0.446448\n      0.455718\n      0.126750\n      0.109187\n      0.354910\n      0.060221\n      0.394566\n      0.402926\n      0.253869\n      0.076814\n      0.066987\n      68.930000\n      0.000000\n    \n    \n      max\n      219128.000000\n      120580.000000\n      2.430494\n      16.068473\n      6.145578\n      12.547997\n      34.581260\n      16.233967\n      39.824099\n      18.270586\n      13.423914\n      15.878405\n      9.417789\n      5.406614\n      5.976265\n      6.078453\n      4.693323\n      5.834992\n      8.845303\n      4.847887\n      4.090974\n      15.407839\n      22.062945\n      6.163541\n      12.734391\n      4.572739\n      3.111624\n      3.402344\n      13.123618\n      23.263746\n      7475.000000\n      1.000000\n    \n  \n\n\n\n\n\ntest.describe()\n\n\n\n\n\n  \n    \n      \n      id\n      Time\n      V1\n      V2\n      V3\n      V4\n      V5\n      V6\n      V7\n      V8\n      V9\n      V10\n      V11\n      V12\n      V13\n      V14\n      V15\n      V16\n      V17\n      V18\n      V19\n      V20\n      V21\n      V22\n      V23\n      V24\n      V25\n      V26\n      V27\n      V28\n      Amount\n    \n  \n  \n    \n      count\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n      146087.000000\n    \n    \n      mean\n      292172.000000\n      144637.928166\n      0.512929\n      -0.013098\n      -0.697478\n      -0.273258\n      0.321856\n      -0.050204\n      0.073419\n      0.043803\n      -0.071620\n      0.013962\n      -0.249980\n      0.108453\n      -0.127648\n      -0.151857\n      -0.199467\n      0.027958\n      -0.052971\n      0.128470\n      -0.008261\n      -0.056678\n      0.044729\n      0.175461\n      0.018471\n      0.016029\n      -0.118352\n      -0.015199\n      0.006236\n      0.002035\n      66.182463\n    \n    \n      std\n      42171.828725\n      14258.025396\n      1.628455\n      1.247749\n      1.292522\n      1.365752\n      1.146215\n      1.332880\n      0.946681\n      0.749513\n      0.924996\n      0.932453\n      0.881086\n      0.686018\n      0.916833\n      0.832182\n      0.774293\n      0.811819\n      0.713056\n      0.798006\n      0.722225\n      0.458364\n      0.449017\n      0.710704\n      0.359597\n      0.633929\n      0.479720\n      0.446154\n      0.255935\n      0.174613\n      153.151535\n    \n    \n      min\n      219129.000000\n      120580.000000\n      -34.755944\n      -37.803827\n      -18.934952\n      -5.497560\n      -25.639591\n      -14.133040\n      -18.715915\n      -26.926164\n      -4.823352\n      -12.333747\n      -4.333619\n      -8.836286\n      -4.131766\n      -14.172557\n      -4.072435\n      -7.639810\n      -11.868164\n      -4.342548\n      -4.823554\n      -26.412867\n      -13.087263\n      -5.392649\n      -12.814296\n      -2.789084\n      -3.361564\n      -1.743223\n      -9.412538\n      -8.262339\n      0.000000\n    \n    \n      25%\n      255650.500000\n      132698.000000\n      -0.679988\n      -0.715885\n      -1.619268\n      -1.021205\n      -0.418547\n      -0.891441\n      -0.570042\n      -0.231824\n      -0.634695\n      -0.636147\n      -0.957520\n      -0.324639\n      -0.717325\n      -0.617641\n      -0.737472\n      -0.451743\n      -0.572054\n      -0.380886\n      -0.383668\n      -0.237529\n      -0.166715\n      -0.393667\n      -0.135059\n      -0.368957\n      -0.409938\n      -0.284914\n      -0.066037\n      -0.057447\n      5.990000\n    \n    \n      50%\n      292172.000000\n      144493.000000\n      0.285798\n      0.009058\n      -0.719060\n      -0.482945\n      0.306851\n      -0.372813\n      0.118545\n      0.014979\n      -0.075909\n      -0.065457\n      -0.182940\n      0.124780\n      -0.098396\n      -0.065481\n      -0.167537\n      0.076469\n      -0.123968\n      0.123625\n      -0.002966\n      -0.096729\n      0.058393\n      0.250169\n      0.017835\n      0.029727\n      -0.142325\n      -0.069342\n      -0.003539\n      -0.026955\n      21.790000\n    \n    \n      75%\n      328693.500000\n      156140.000000\n      1.974015\n      0.827420\n      0.073874\n      0.369725\n      0.955997\n      0.302724\n      0.734503\n      0.296969\n      0.513770\n      0.564146\n      0.453913\n      0.581384\n      0.504763\n      0.395024\n      0.305768\n      0.546893\n      0.372321\n      0.677771\n      0.374562\n      0.065753\n      0.244817\n      0.749555\n      0.167514\n      0.562138\n      0.182937\n      0.216632\n      0.069334\n      0.066954\n      66.000000\n    \n    \n      max\n      365215.000000\n      172790.000000\n      2.452901\n      12.390128\n      4.492640\n      11.232928\n      24.352818\n      16.596635\n      27.023955\n      12.098322\n      7.888980\n      14.735004\n      6.204939\n      5.107089\n      3.928334\n      7.869385\n      5.374923\n      5.570906\n      7.136535\n      3.758750\n      4.929496\n      15.829261\n      15.333546\n      5.771245\n      17.481609\n      4.541724\n      4.555960\n      3.374748\n      12.673968\n      13.093229\n      4630.600000\n    \n  \n\n\n\n\nWe find:\n\nThe feature names don’t help us understand what the feature is about or how to interpret it.\nFor most of the features the minimum and maximum values are to different extremes whereas their 1st quatile, median, and 3rd quatile are close to each other.\n\nFor example, V1 has minimum value as -34.755944 and maximum value as 2.452901.\n25%: -0.679988, 50%: 0.285798, and 75%: 1.974015\n\n\n\n\n2.2. Missing values\n\n# Check for missing values in train set\nprint(f\"Number of missing values in training set: {sum(train.isna().sum())}\")\nprint(f\"Number of missing values in testing set: {sum(test.isna().sum())}\")\n\nNumber of missing values in training set: 0\nNumber of missing values in testing set: 0\n\n\nWe find:\n\nAs seen in the info() results we confirm we don’t have any missing values in the both datasets."
  },
  {
    "objectID": "posts/kaggle/pss3e3-eda.html#visualizations",
    "href": "posts/kaggle/pss3e3-eda.html#visualizations",
    "title": "EDA - Playground Series Season 3, Episode 4",
    "section": "3. Visualizations",
    "text": "3. Visualizations\n\n# Extract the columns which contains 'V'\nv_columns = [col for col in train.columns if col[0] == 'V']\nuseful_columns = [col for col in train.columns if col not in ['id', 'Time']]\n\n\n3.1. Univariate Analysis\n\nsns.countplot(x='Class', data=train)\nplt.title('Distribution of Class', fontsize=14)\nplt.show()\n\n\n\n\n\ntrain.Class.value_counts() / train.shape[0] * 100\n\n0    99.785971\n1     0.214029\nName: Class, dtype: float64\n\n\nWe find:\n\nThe two classes are highly imbalanced.\n~99.78% of the data is labelled as Class 0\n~0.21% of the data is labelled as Class 1.\n\n\nax = train[v_columns].plot(kind='box', figsize=(20, 8))\nplt.title('Box plots of features start\\'s with V', fontsize=14)\nplt.show()\n\n\n\n\nWe find:\n\nSimilar, to what we saw in the result from the describe() method, most of the data is centered around 0.\nAlso, there are a lot of data points that appear to be outliers.\nFew of the columns, for example, V1 appear to be skewed.\n\n\n# Explore distribution of each feature for train and test sets.\n\nfig, axes = plt.subplots(nrows=29, ncols=3, figsize=(20, 5*29))\n\nfor row, col in enumerate(v_columns + ['Amount']):\n    sns.kdeplot(data=train, x=col, ax=axes[row, 0], fill=True)\n    sns.kdeplot(data=test, x=col, ax=axes[row, 0], fill=True)\n    axes[row, 0].set_title('Density plot: ' + col, fontsize=14)\n    axes[row, 0].legend()\n    axes[row, 0].set_xlabel('')\n\n    sns.boxplot(data=train, x=col, ax=axes[row, 1], orient='h')\n    axes[row, 1].set_title('Box plot (Train): ' + col, fontsize=14)\n    axes[row, 1].set_xlabel('')\n\n    sns.boxplot(data=test, x=col, ax=axes[row, 2], orient='h')\n    axes[row, 2].set_title('Box plot (Test): ' + col, fontsize=14)\n    axes[row, 2].set_xlabel('')\n\nfig.tight_layout()\nplt.show()\n\n\n\n\nWe find:\n\nThe distribution of train and test data are quite similar.\nThis helps to the model to better perform on the unseen data.\n\n\n\n3.2. Bivariate Analysis\n\nCreating a scatter plot for all combinations of features would be explode and be overwhelming.\nI would encourage you to play with different combinations and look at the data distribution.\nUsing pairplot is also an good option but the graphs are too tiny to observe. You can definititely try using it and then explore any plot you find interesting.\n\nBelow are some plot I found interesting.\n\nfig, axes = plt.subplots(nrows=3, ncols=3, figsize=(18, 12))\n\nsns.scatterplot(data=train, x='V24', y='V2', hue=train.Class, ax=axes[0, 0])\naxes[0, 0].set_title('V24 vs V2', fontsize=14)\n\nsns.scatterplot(data=train, x='V10', y='V9', hue=train.Class, ax=axes[0, 1])\naxes[0, 1].set_title('V10 vs V9', fontsize=14)\n\nsns.scatterplot(data=train, x='V17', y='V2', hue=train.Class, ax=axes[0, 2])\naxes[0, 2].set_title('V17 vs V2', fontsize=14)\n\nsns.scatterplot(data=train, x='V20', y='V21', hue=train.Class, ax=axes[1, 0])\naxes[1, 0].set_title('V20 vs V21', fontsize=14)\n\nsns.scatterplot(data=train, x='V21', y='V22', hue=train.Class, ax=axes[1, 1])\naxes[1, 1].set_title('V21 vs V22', fontsize=14)\n\nsns.scatterplot(data=train, x='V21', y='V2', hue=train.Class, ax=axes[1, 2])\naxes[1, 2].set_title('V21 vs V2', fontsize=14)\n\nsns.scatterplot(data=train, x='V24', y='V1', hue=train.Class, ax=axes[2, 0])\naxes[2, 0].set_title('V24 vs V1', fontsize=14)\n\nsns.scatterplot(data=train, x='V15', y='V19', hue=train.Class, ax=axes[2, 1])\naxes[2, 1].set_title('V15 vs V19', fontsize=14)\n\nsns.scatterplot(data=train, x='V20', y='Amount',\n                hue=train.Class, ax=axes[2, 2])\naxes[2, 2].set_title('V20 vs Amount', fontsize=14)\n\nfig.tight_layout()\nplt.show()\n\n\n\n\nWe find:\n\nFeatures such as V9 and V10, V21 and V22 show some degree of correlation.\nWhereas others are distributed in ramdom fashion.\nV15 and V19 are totall random and doesn’t show any patterns that can be useful for us.\nThere are small clusters, example in figure V24 vs V1 where we don’t find any samples of data with Class 1.\n\n\ntrain.V20/(train.Amount + 1e-6)\n\n0        -0.147964\n1         0.000782\n2        -0.007946\n3        -0.340089\n4        -0.203627\n            ...   \n219124   -0.000985\n219125   -0.004856\n219126   -0.214989\n219127   -0.002170\n219128    0.015379\nLength: 219129, dtype: float64\n\n\n\n# Look at heatmap for correlation between different numeric features\n\ncorr = train[v_columns + ['Amount']].corr()\nfig = plt.figure(figsize=(25, 12))\nsns.heatmap(corr, annot=True, fmt=\".2f\")\nplt.show()\n\n\n\n\nWe find:\n\nV20 and Amount has the highest value of positive correlation, followed by V5 and V6, followed by V21 and V22\nV2 and Amount has the highest value of negative correlation, followed by V5 and Amount, followed by V12 and V14"
  },
  {
    "objectID": "posts/kaggle/pss3e3-eda.html#conclusion",
    "href": "posts/kaggle/pss3e3-eda.html#conclusion",
    "title": "EDA - Playground Series Season 3, Episode 4",
    "section": "4. Conclusion",
    "text": "4. Conclusion\nThank you for reading and I hope you found this notebook helpful. You can find my modeling notebook here\nAny feedback is welcomed, I aim to learn and improve my skillset in my kaggle journey.\nUpvote if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/kaggle/pss3e4-ensemble-model.html",
    "href": "posts/kaggle/pss3e4-ensemble-model.html",
    "title": "Modeling - Playground Series Season 3, Episode 4",
    "section": "",
    "text": "To read more about Exploratory Data Analysis for this problem statement, you can read my notebook here\nIt was my first try at a kaggle comptetion and I got a lot to learn. This notebook helped me get a score of:\nPosition: 138/641"
  },
  {
    "objectID": "posts/kaggle/pss3e4-ensemble-model.html#data-description",
    "href": "posts/kaggle/pss3e4-ensemble-model.html#data-description",
    "title": "Modeling - Playground Series Season 3, Episode 4",
    "section": "1. Data Description",
    "text": "1. Data Description\nThe dataset for this competition (both train and test) was generated from a deep learning model trained on the Credit Card Fraud Detection. Feature distributions are close to, but not exactly the same, as the original.\nWe are given three files:\n\ntrain.csv - the training dataset; Class is the target\ntest.csv - the test dataset; our objective is to predict Class\nsample_submission.csv - a sample submission file in the correct format\n\nDescription of each column:\n\nFeature Description\n\n\n\n\n\n\nFeature\nDescription\n\n\n\n\nid\nIndentifier for unique rows\n\n\nTime\nNumber of seconds elapsed between this transaction and the first transaction in the dataset\n\n\nV1-V28\nFeatures generated from the original dataset\n\n\nAmount\nTransaction amount\n\n\nClass\nTarget Feature: 1 for fraudulent transactions, 0 otherwise"
  },
  {
    "objectID": "posts/kaggle/pss3e4-ensemble-model.html#data-preparation",
    "href": "posts/kaggle/pss3e4-ensemble-model.html#data-preparation",
    "title": "Modeling - Playground Series Season 3, Episode 4",
    "section": "2. Data Preparation",
    "text": "2. Data Preparation\n\n__dirname = '../input/playground-series-s3e4/'\nog_data = '/kaggle/input/creditcardfraud/creditcard.csv'\n\ntrain = pd.read_csv(__dirname + 'train.csv')\ntest = pd.read_csv(__dirname + 'test.csv')\noriginal = pd.read_csv(og_data)\nsubmissions = pd.read_csv(__dirname + 'sample_submission.csv')\n\n\nprint(f\"Training set has {train.shape[0]} rows and {train.shape[1]} columns\")\nprint(f\"Testing set has {test.shape[0]} rows and {test.shape[1]} columns\")\nprint(\n    f\"Original set has {original.shape[0]} rows and {original.shape[1]} columns\")\n\nTraining set has 219129 rows and 32 columns\nTesting set has 146087 rows and 31 columns\nOriginal set has 284807 rows and 31 columns\n\n\n\n# Check for missing values\nprint(f\"Number of missing values in training set: {sum(train.isna().sum())}\")\nprint(f\"Number of missing values in testing set: {sum(test.isna().sum())}\")\nprint(\n    f\"Number of missing values in original set: {sum(original.isna().sum())}\")\n\nNumber of missing values in training set: 0\nNumber of missing values in testing set: 0\nNumber of missing values in original set: 0\n\n\n\n# Merge train and original\ntrain = pd.concat([train, original], axis=0, ignore_index=True)\n\n\ncols = [col for col in train.columns if col not in ['id', 'Time']]\nprint(' Number of duplicates with new criteria:',\n      train[cols].duplicated().sum())\n\n Number of duplicates with new criteria: 9254\n\n\n\n# Drop Duplicates\ntrain.drop_duplicates(subset=cols, inplace=True, keep='first')\n\n\n# Drop columns\ntrain.drop(['id', 'Time'], axis=1, inplace=True)\ntest.drop(['id', 'Time'], axis=1, inplace=True)"
  },
  {
    "objectID": "posts/kaggle/pss3e4-ensemble-model.html#modeling",
    "href": "posts/kaggle/pss3e4-ensemble-model.html#modeling",
    "title": "Modeling - Playground Series Season 3, Episode 4",
    "section": "3. Modeling",
    "text": "3. Modeling\n\n# Perform feature scaling\nscaler = RobustScaler()\n\ncols = test.columns\ntrain[cols] = scaler.fit_transform(train[cols])\ntest[cols] = scaler.transform(test[cols])\n\n\nX_train, y_train = train.drop('Class', axis=1), train.Class\n\n\n# Dictionary to save model results\nresults = defaultdict(lambda: defaultdict(list))\n\n\n# Function to plot feature importance\ndef plot_feature_imp(df, col):\n    df = pd.concat(df, axis=1).head(15)\n    df.sort_values(col).plot(kind='barh', figsize=(\n        15, 10), title=\"Feature Imp Across Folds\")\n    plt.show()\n\n\n3.1. Baseline Model\n\nn_folds = 5\nseed = 42\nmodel = 'Logistic Regression'\n\nskf = StratifiedKFold(n_splits=n_folds, shuffle=True, random_state=seed)\ntest_pred = 0\n\nresults[model] = defaultdict(list)\n\nfor idx, (train_idx, test_idx) in enumerate(skf.split(X_train, y_train)):\n    X, y = X_train.iloc[train_idx], y_train.iloc[train_idx]\n    X_valid, y_valid = X_train.iloc[test_idx], y_train.iloc[test_idx]\n\n    lr = LogisticRegression()\n\n    # Fit the model\n    lr.fit(X, y)\n    # Predict on validation set\n    pred_proba = lr.predict_proba(X_valid)[:, 1]\n\n    # Predict on test set\n    test_pred_proba = lr.predict_proba(test)[:, 1]\n    test_pred += test_pred_proba/n_folds\n\n    # Calcualte AUC score\n    auc = roc_auc_score(y_valid, pred_proba)\n\n    # Feature Importance\n    feature_imp = pd.DataFrame(index=X_train.columns,\n                               data=lr.coef_[0],\n                               columns=[f\"{idx + 1}_importance\"])\n\n    print(f\"Fold={idx+1}, AUC score: {auc:.2f}\")\n\n    # Save Results\n    results[model]['auc'].append(auc)\n    results[model]['model'].append(lr)\n    results[model]['feature_imp'].append(feature_imp)\n\nresults[model]['test_pred'] = test_pred\nprint(f\"Mean AUC: {np.mean(results[model]['auc'])}\")\n\nFold=1, AUC score: 0.85\nFold=2, AUC score: 0.88\nFold=3, AUC score: 0.88\nFold=4, AUC score: 0.87\nFold=5, AUC score: 0.86\nMean AUC: 0.8679439362536849\n\n\n\n# Plot feature importance for logistic regression model\nplot_feature_imp(results[model]['feature_imp'], \"2_importance\")\n\n\n\n\n\n# Made a baseline submission to see how the model performs\nlr_submission = submissions.copy()\nlr_submission['Class'] = results[model]['test_pred']\nlr_submission.to_csv('lr_submission.csv', index=False)\n\n\nlr_submission.head()\n\n\n\n\n\n  \n    \n      \n      id\n      Class\n    \n  \n  \n    \n      0\n      219129\n      0.001192\n    \n    \n      1\n      219130\n      0.000621\n    \n    \n      2\n      219131\n      0.000201\n    \n    \n      3\n      219132\n      0.000699\n    \n    \n      4\n      219133\n      0.000361\n    \n  \n\n\n\n\n\n\n3.2. XGBoost Classifier\n\nxgb_params = {\n    'n_estimators': 2000,\n    'min_child_weight': 96,\n    'max_depth': 7,\n    'learning_rate': 0.18,\n    'subsample': 0.95,\n    'colsample_bytree': 0.95,\n    'reg_lambda': 1.50,\n    'reg_alpha': 1.50,\n    'gamma': 1.50,\n    'max_bin': 512,\n    'random_state': seed,\n    'objective': 'binary:logistic',\n    'tree_method': 'hist',\n    'eval_metric': 'auc'\n}\n\n\nn_folds = 5\nseed = 42\nmodel = 'XGBoostClassifier'\n\nskf = StratifiedKFold(n_splits=n_folds, shuffle=True, random_state=seed)\ntest_pred = 0\n\nresults[model] = defaultdict(list)\n\nfor idx, (train_idx, test_idx) in enumerate(skf.split(X_train, y_train)):\n    X, y = X_train.iloc[train_idx], y_train.iloc[train_idx]\n    X_valid, y_valid = X_train.iloc[test_idx], y_train.iloc[test_idx]\n\n    xgb = XGBClassifier(**xgb_params)\n\n    # Fit the model\n    xgb.fit(X, y)\n    # Predict on validation set\n    pred_proba = xgb.predict_proba(X_valid)[:, 1]\n\n    # Predict on test set\n    test_pred_proba = xgb.predict_proba(test)[:, 1]\n    test_pred += test_pred_proba/n_folds\n\n    # Calcualte AUC score\n    auc = roc_auc_score(y_valid, pred_proba)\n\n    # Feature Importance\n    feature_imp = pd.DataFrame(index=X_train.columns,\n                               data=xgb.feature_importances_,\n                               columns=[f\"{idx + 1}_importance\"])\n\n    print(f\"Fold={idx+1}, AUC score: {auc:.2f}\")\n\n    # Save Results\n    results[model]['auc'].append(auc)\n    results[model]['model'].append(lr)\n    results[model]['feature_imp'].append(feature_imp)\n\nresults[model]['test_pred'] = test_pred\nprint(f\"Mean AUC: {np.mean(results[model]['auc'])}\")\n\nFold=1, AUC score: 0.88\nFold=2, AUC score: 0.90\nFold=3, AUC score: 0.91\nFold=4, AUC score: 0.89\nFold=5, AUC score: 0.90\nMean AUC: 0.8951748159271997\n\n\n\n# Plot feature importance for XGBoost model\nplot_feature_imp(results[model]['feature_imp'], \"2_importance\")\n\n\n\n\n\n# Made a submission to see how the model performs\nxgb_submission = submissions.copy()\nxgb_submission['Class'] = results[model]['test_pred']\nxgb_submission.to_csv('xgb_submission.csv', index=False)\n\n\nxgb_submission.head()\n\n\n\n\n\n  \n    \n      \n      id\n      Class\n    \n  \n  \n    \n      0\n      219129\n      0.001166\n    \n    \n      1\n      219130\n      0.000573\n    \n    \n      2\n      219131\n      0.000367\n    \n    \n      3\n      219132\n      0.001084\n    \n    \n      4\n      219133\n      0.000131\n    \n  \n\n\n\n\n\n\n3.3. LightGBM Classifier\n\nlgbm_params = {\n    'n_estimators': 500,\n    'learning_rate': 0.1,\n    'num_leaves': 195,\n    'max_depth': 9,\n    'min_data_in_leaf': 46,\n    'lambda_l1': 0.01,\n    'lambda_l2': 0.6,\n    'min_gain_to_split': 1.42,\n    'bagging_fraction': 0.45,\n    'feature_fraction': 0.3,\n    'verbosity': -1,\n    'boosting_type': 'dart',\n    'random_state': seed,\n    'objective': 'binary'\n}\n\n\nn_folds = 5\nseed = 42\nmodel = 'LGBMClassifier'\n\nskf = StratifiedKFold(n_splits=n_folds, shuffle=True, random_state=seed)\ntest_pred = 0\n\nresults[model] = defaultdict(list)\n\nfor idx, (train_idx, test_idx) in enumerate(skf.split(X_train, y_train)):\n    X, y = X_train.iloc[train_idx], y_train.iloc[train_idx]\n    X_valid, y_valid = X_train.iloc[test_idx], y_train.iloc[test_idx]\n\n    lgbm = LGBMClassifier(**lgbm_params)\n\n    # Fit the model\n    lgbm.fit(X, y)\n    # Predict on validation set\n    pred_proba = lgbm.predict_proba(X_valid)[:, 1]\n\n    # Predict on test set\n    test_pred_proba = lgbm.predict_proba(test)[:, 1]\n    test_pred += test_pred_proba/n_folds\n\n    # Calcualte AUC score\n    auc = roc_auc_score(y_valid, pred_proba)\n\n    # Feature Importance\n    feature_imp = pd.DataFrame(index=X_train.columns,\n                               data=lgbm.feature_importances_,\n                               columns=[f\"{idx + 1}_importance\"])\n\n    print(f\"Fold={idx+1}, AUC score: {auc:.2f}\")\n\n    # Save Results\n    results[model]['auc'].append(auc)\n    results[model]['model'].append(lr)\n    results[model]['feature_imp'].append(feature_imp)\n\nresults[model]['test_pred'] = test_pred\nprint(f\"Mean AUC: {np.mean(results[model]['auc'])}\")\n\n[LightGBM] [Warning] lambda_l1 is set=0.01, reg_alpha=0.0 will be ignored. Current value: lambda_l1=0.01\n[LightGBM] [Warning] bagging_fraction is set=0.45, subsample=1.0 will be ignored. Current value: bagging_fraction=0.45\n[LightGBM] [Warning] min_data_in_leaf is set=46, min_child_samples=20 will be ignored. Current value: min_data_in_leaf=46\n[LightGBM] [Warning] feature_fraction is set=0.3, colsample_bytree=1.0 will be ignored. Current value: feature_fraction=0.3\n[LightGBM] [Warning] min_gain_to_split is set=1.42, min_split_gain=0.0 will be ignored. Current value: min_gain_to_split=1.42\n[LightGBM] [Warning] lambda_l2 is set=0.6, reg_lambda=0.0 will be ignored. Current value: lambda_l2=0.6\nFold=1, AUC score: 0.89\n[LightGBM] [Warning] lambda_l1 is set=0.01, reg_alpha=0.0 will be ignored. Current value: lambda_l1=0.01\n[LightGBM] [Warning] bagging_fraction is set=0.45, subsample=1.0 will be ignored. Current value: bagging_fraction=0.45\n[LightGBM] [Warning] min_data_in_leaf is set=46, min_child_samples=20 will be ignored. Current value: min_data_in_leaf=46\n[LightGBM] [Warning] feature_fraction is set=0.3, colsample_bytree=1.0 will be ignored. Current value: feature_fraction=0.3\n[LightGBM] [Warning] min_gain_to_split is set=1.42, min_split_gain=0.0 will be ignored. Current value: min_gain_to_split=1.42\n[LightGBM] [Warning] lambda_l2 is set=0.6, reg_lambda=0.0 will be ignored. Current value: lambda_l2=0.6\nFold=2, AUC score: 0.90\n[LightGBM] [Warning] lambda_l1 is set=0.01, reg_alpha=0.0 will be ignored. Current value: lambda_l1=0.01\n[LightGBM] [Warning] bagging_fraction is set=0.45, subsample=1.0 will be ignored. Current value: bagging_fraction=0.45\n[LightGBM] [Warning] min_data_in_leaf is set=46, min_child_samples=20 will be ignored. Current value: min_data_in_leaf=46\n[LightGBM] [Warning] feature_fraction is set=0.3, colsample_bytree=1.0 will be ignored. Current value: feature_fraction=0.3\n[LightGBM] [Warning] min_gain_to_split is set=1.42, min_split_gain=0.0 will be ignored. Current value: min_gain_to_split=1.42\n[LightGBM] [Warning] lambda_l2 is set=0.6, reg_lambda=0.0 will be ignored. Current value: lambda_l2=0.6\nFold=3, AUC score: 0.91\n[LightGBM] [Warning] lambda_l1 is set=0.01, reg_alpha=0.0 will be ignored. Current value: lambda_l1=0.01\n[LightGBM] [Warning] bagging_fraction is set=0.45, subsample=1.0 will be ignored. Current value: bagging_fraction=0.45\n[LightGBM] [Warning] min_data_in_leaf is set=46, min_child_samples=20 will be ignored. Current value: min_data_in_leaf=46\n[LightGBM] [Warning] feature_fraction is set=0.3, colsample_bytree=1.0 will be ignored. Current value: feature_fraction=0.3\n[LightGBM] [Warning] min_gain_to_split is set=1.42, min_split_gain=0.0 will be ignored. Current value: min_gain_to_split=1.42\n[LightGBM] [Warning] lambda_l2 is set=0.6, reg_lambda=0.0 will be ignored. Current value: lambda_l2=0.6\nFold=4, AUC score: 0.89\n[LightGBM] [Warning] lambda_l1 is set=0.01, reg_alpha=0.0 will be ignored. Current value: lambda_l1=0.01\n[LightGBM] [Warning] bagging_fraction is set=0.45, subsample=1.0 will be ignored. Current value: bagging_fraction=0.45\n[LightGBM] [Warning] min_data_in_leaf is set=46, min_child_samples=20 will be ignored. Current value: min_data_in_leaf=46\n[LightGBM] [Warning] feature_fraction is set=0.3, colsample_bytree=1.0 will be ignored. Current value: feature_fraction=0.3\n[LightGBM] [Warning] min_gain_to_split is set=1.42, min_split_gain=0.0 will be ignored. Current value: min_gain_to_split=1.42\n[LightGBM] [Warning] lambda_l2 is set=0.6, reg_lambda=0.0 will be ignored. Current value: lambda_l2=0.6\nFold=5, AUC score: 0.90\nMean AUC: 0.8997556737837178\n\n\n\n# Plot feature importance for LightGBM model\nplot_feature_imp(results[model]['feature_imp'], \"4_importance\")\n\n\n\n\n\n# Made a submission to see how the model performs\nlgbm_submission = submissions.copy()\nlgbm_submission['Class'] = results[model]['test_pred']\nlgbm_submission.to_csv('lgbm_submission.csv', index=False)\n\n\nlgbm_submission.head()\n\n\n\n\n\n  \n    \n      \n      id\n      Class\n    \n  \n  \n    \n      0\n      219129\n      0.001045\n    \n    \n      1\n      219130\n      0.000622\n    \n    \n      2\n      219131\n      0.000337\n    \n    \n      3\n      219132\n      0.000817\n    \n    \n      4\n      219133\n      0.000307\n    \n  \n\n\n\n\n\n\n3.4. CatBoot Classifier\n\ncatboost_params = {\n    'n_estimators': 500,\n    'learning_rate': 0.1,\n    'one_hot_max_size': 12,\n    'depth': 9,\n    'l2_leaf_reg': 0.6,\n    'colsample_bylevel': 0.06,\n    'min_data_in_leaf': 12,\n    'bootstrap_type': 'Bernoulli',\n    'verbose': False,\n    'random_state': seed,\n    'objective': 'Logloss',\n    'eval_metric': 'AUC'\n}\n\n\nn_folds = 5\nseed = 42\nmodel = 'CatBoostClassifier'\n\nskf = StratifiedKFold(n_splits=n_folds, shuffle=True, random_state=seed)\ntest_pred = 0\n\nresults[model] = defaultdict(list)\n\nfor idx, (train_idx, test_idx) in enumerate(skf.split(X_train, y_train)):\n    X, y = X_train.iloc[train_idx], y_train.iloc[train_idx]\n    X_valid, y_valid = X_train.iloc[test_idx], y_train.iloc[test_idx]\n\n    catb = CatBoostClassifier(**catboost_params)\n\n    # Fit the model\n    catb.fit(X, y)\n    # Predict on validation set\n    pred_proba = catb.predict_proba(X_valid)[:, 1]\n\n    # Predict on test set\n    test_pred_proba = catb.predict_proba(test)[:, 1]\n    test_pred += test_pred_proba/n_folds\n\n    # Calcualte AUC score\n    auc = roc_auc_score(y_valid, pred_proba)\n\n    # Feature Importance\n    feature_imp = pd.DataFrame(index=X_train.columns,\n                               data=catb.feature_importances_,\n                               columns=[f\"{idx + 1}_importance\"])\n\n    print(f\"Fold={idx+1}, AUC score: {auc:.2f}\")\n\n    # Save Results\n    results[model]['auc'].append(auc)\n    results[model]['model'].append(lr)\n    results[model]['feature_imp'].append(feature_imp)\n\nresults[model]['test_pred'] = test_pred\nprint(f\"Mean AUC: {np.mean(results[model]['auc'])}\")\n\nFold=1, AUC score: 0.87\nFold=2, AUC score: 0.88\nFold=3, AUC score: 0.88\nFold=4, AUC score: 0.89\nFold=5, AUC score: 0.89\nMean AUC: 0.877921430469104\n\n\n\n# Plot feature importance for CatBoost model\nplot_feature_imp(results[model]['feature_imp'], \"2_importance\")\n\n\n\n\n\n# Made a submission to see how the model performs\ncatb_submission = submissions.copy()\ncatb_submission['Class'] = results[model]['test_pred']\ncatb_submission.to_csv('catb_submission.csv', index=False)\n\n\ncatb_submission.head()\n\n\n\n\n\n  \n    \n      \n      id\n      Class\n    \n  \n  \n    \n      0\n      219129\n      0.000671\n    \n    \n      1\n      219130\n      0.000433\n    \n    \n      2\n      219131\n      0.000124\n    \n    \n      3\n      219132\n      0.000599\n    \n    \n      4\n      219133\n      0.000103\n    \n  \n\n\n\n\n\n\n3.5. Ensemble Results\n\na = 0.1\nb = 0.4\nc = 0.3\nd = 0.2\n\npred = a * lr_submission['Class'] + b * xgb_submission['Class'] + \\\n    c * lgbm_submission['Class'] + d * catb_submission['Class']\n\n# Made a submission to see how the model performs\nsubmission = submissions.copy()\nsubmission['Class'] = pred\nsubmission.to_csv('submission_CatB.csv', index=False)\n\n\na = 0\nb = 0.4\nc = 0.4\nd = 0.2\n\npred = a * lr_submission['Class'] + b * xgb_submission['Class'] + \\\n    c * lgbm_submission['Class'] + d * catb_submission['Class']\n\n# Made a submission to see how the model performs\nsubmission = submissions.copy()\nsubmission['Class'] = pred\nsubmission.to_csv('submission_noLR.csv', index=False)"
  },
  {
    "objectID": "posts/kaggle/pss3e4-ensemble-model.html#conclusion",
    "href": "posts/kaggle/pss3e4-ensemble-model.html#conclusion",
    "title": "Modeling - Playground Series Season 3, Episode 4",
    "section": "4. Conclusion",
    "text": "4. Conclusion\nThank you for reading so far and I hope you found this notebook helpful.\nUpvote if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/kaggle/song-popularity-eda.html",
    "href": "posts/kaggle/song-popularity-eda.html",
    "title": "Song Popularity EDA",
    "section": "",
    "text": "This Python notebook is the Python version of Song Popularity EDA - Live Coding Fun by Martin Henze\nPurpose of this notebook is to recreate the plots in python for learning purpose.\nThe recording of the live-coding session can be found on Abhishek Thakur’s YouTube channel:"
  },
  {
    "objectID": "posts/kaggle/song-popularity-eda.html#introduction",
    "href": "posts/kaggle/song-popularity-eda.html#introduction",
    "title": "Song Popularity EDA",
    "section": "1. Introduction",
    "text": "1. Introduction\nThe competition is about Song Prediction based on a set of different features. The dataset contains the basic file such as train.csv, test.csv and submission_sample.csv. The dataset used in this competition is in tabular format. The evaluation metric used for this competition is AUC score."
  },
  {
    "objectID": "posts/kaggle/song-popularity-eda.html#preparation",
    "href": "posts/kaggle/song-popularity-eda.html#preparation",
    "title": "Song Popularity EDA",
    "section": "2. Preparation",
    "text": "2. Preparation\nInitially we’ll load different libraries used in our analysis. Also, load the train and test data.\n\n\nCode\n# Import libraries and load the data\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\nimport random\nimport warnings\n\nfrom plotnine import *\n\n%matplotlib inline\nwarnings.filterwarnings(\"ignore\")\n\n\n\n\nCode\n# Load the data\ntrain = pd.read_csv(\"/kaggle/input/song-popularity-prediction/train.csv\")\ntest = pd.read_csv(\"/kaggle/input/song-popularity-prediction/test.csv\")"
  },
  {
    "objectID": "posts/kaggle/song-popularity-eda.html#overview-structure-and-data-content",
    "href": "posts/kaggle/song-popularity-eda.html#overview-structure-and-data-content",
    "title": "Song Popularity EDA",
    "section": "3. Overview: structure and data content",
    "text": "3. Overview: structure and data content\nThe first step we’ll do is look at the raw data. This tell us about the different features in the dataset, missing values, and types of features (numeric, string, categorical, etc.).\n\n3.1. Look at the data\nLet’s look at the basic structure of the data\n\n\nCode\nprint('\\nInformation about Data')\ndisplay(train.info())\n\n\n\nInformation about Data\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 40000 entries, 0 to 39999\nData columns (total 15 columns):\n #   Column            Non-Null Count  Dtype  \n---  ------            --------------  -----  \n 0   id                40000 non-null  int64  \n 1   song_duration_ms  35899 non-null  float64\n 2   acousticness      36008 non-null  float64\n 3   danceability      35974 non-null  float64\n 4   energy            36025 non-null  float64\n 5   instrumentalness  36015 non-null  float64\n 6   key               35935 non-null  float64\n 7   liveness          35914 non-null  float64\n 8   loudness          36043 non-null  float64\n 9   audio_mode        40000 non-null  int64  \n 10  speechiness       40000 non-null  float64\n 11  tempo             40000 non-null  float64\n 12  time_signature    40000 non-null  int64  \n 13  audio_valence     40000 non-null  float64\n 14  song_popularity   40000 non-null  int64  \ndtypes: float64(11), int64(4)\nmemory usage: 4.6 MB\n\n\nNone\n\n\nWe find:\n\nThere are 40000 entries and 15 features in total.\nAll the column data type is either int or float i.e. all the columns are numeric. This make is comparatively easier to work with compared to columns contains string type data.\nWe can also observe there are columns that contain less than 40K Non-Null values which indicates missing values in the dataset.\n\nLet’s now look at the top 20 rows of the data.\n\n\nCode\n\"\"\"Display top 20 rows of the train data\"\"\"\ndisplay(train.head(20).style.set_caption(\"First Twenty rows of Training Data\"))\n\n\n\n\n\n  First Twenty rows of Training Data\n  \n    \n       \n      id\n      song_duration_ms\n      acousticness\n      danceability\n      energy\n      instrumentalness\n      key\n      liveness\n      loudness\n      audio_mode\n      speechiness\n      tempo\n      time_signature\n      audio_valence\n      song_popularity\n    \n  \n  \n    \n      0\n      0\n      212990.000000\n      0.642286\n      0.856520\n      0.707073\n      0.002001\n      10.000000\n      nan\n      -5.619088\n      0\n      0.082570\n      158.386236\n      4\n      0.734642\n      0\n    \n    \n      1\n      1\n      nan\n      0.054866\n      0.733289\n      0.835545\n      0.000996\n      8.000000\n      0.436428\n      -5.236965\n      1\n      0.127358\n      102.752988\n      3\n      0.711531\n      1\n    \n    \n      2\n      2\n      193213.000000\n      nan\n      0.188387\n      0.783524\n      -0.002694\n      5.000000\n      0.170499\n      -4.951759\n      0\n      0.052282\n      178.685791\n      3\n      0.425536\n      0\n    \n    \n      3\n      3\n      249893.000000\n      0.488660\n      0.585234\n      0.552685\n      0.000608\n      0.000000\n      0.094805\n      -7.893694\n      0\n      0.035618\n      128.715630\n      3\n      0.453597\n      0\n    \n    \n      4\n      4\n      165969.000000\n      0.493017\n      nan\n      0.740982\n      0.002033\n      10.000000\n      0.094891\n      -2.684095\n      0\n      0.050746\n      121.928157\n      4\n      0.741311\n      0\n    \n    \n      5\n      5\n      188891.000000\n      0.035655\n      0.825919\n      0.804528\n      -0.000005\n      4.000000\n      0.120758\n      -6.122926\n      0\n      0.039012\n      115.679128\n      4\n      0.709408\n      0\n    \n    \n      6\n      6\n      161061.000000\n      0.081743\n      0.673588\n      0.880181\n      0.000327\n      0.000000\n      0.535411\n      -2.909607\n      1\n      0.030902\n      98.046205\n      4\n      0.982729\n      0\n    \n    \n      7\n      7\n      196202.000000\n      0.259747\n      0.813214\n      0.554385\n      0.000390\n      8.000000\n      0.276580\n      -7.794237\n      0\n      0.207067\n      158.626764\n      3\n      0.662987\n      1\n    \n    \n      8\n      8\n      169660.000000\n      nan\n      0.653263\n      0.917034\n      0.001748\n      0.000000\n      nan\n      -4.422089\n      0\n      0.031608\n      122.382398\n      3\n      0.297683\n      1\n    \n    \n      9\n      9\n      167245.000000\n      0.019617\n      0.595235\n      0.820039\n      0.761884\n      5.000000\n      0.181098\n      -5.154293\n      0\n      0.054493\n      110.524824\n      4\n      0.535453\n      0\n    \n    \n      10\n      10\n      128274.000000\n      0.614007\n      0.397899\n      0.346820\n      0.002853\n      3.000000\n      0.132549\n      nan\n      1\n      0.059512\n      87.363516\n      3\n      0.671581\n      1\n    \n    \n      11\n      11\n      213121.000000\n      0.044053\n      0.817874\n      0.729679\n      0.003660\n      5.000000\n      0.137938\n      -4.880149\n      0\n      0.038814\n      124.199541\n      4\n      0.816472\n      1\n    \n    \n      12\n      12\n      219730.000000\n      0.339275\n      0.660707\n      nan\n      nan\n      0.000000\n      0.223173\n      -12.005655\n      0\n      0.089726\n      164.877811\n      3\n      0.322253\n      1\n    \n    \n      13\n      13\n      nan\n      0.455778\n      0.448538\n      0.754924\n      nan\n      nan\n      0.076379\n      -3.158905\n      0\n      0.034837\n      118.664526\n      3\n      0.862989\n      0\n    \n    \n      14\n      14\n      nan\n      0.462876\n      0.384318\n      0.653525\n      0.781326\n      6.000000\n      nan\n      -10.362441\n      0\n      0.065149\n      141.581118\n      3\n      0.432883\n      0\n    \n    \n      15\n      15\n      nan\n      0.059284\n      0.164167\n      0.877743\n      0.002113\n      8.000000\n      0.227997\n      -3.627678\n      0\n      0.246330\n      174.445180\n      4\n      0.530006\n      1\n    \n    \n      16\n      16\n      248851.000000\n      0.097600\n      0.718901\n      0.618376\n      0.002925\n      4.000000\n      0.075377\n      -7.715512\n      1\n      0.083494\n      96.831665\n      4\n      0.935569\n      0\n    \n    \n      17\n      17\n      153340.000000\n      0.012866\n      0.715635\n      0.796742\n      0.002236\n      6.000000\n      0.101808\n      -4.879090\n      0\n      0.172036\n      120.830046\n      3\n      0.497743\n      0\n    \n    \n      18\n      18\n      170983.000000\n      0.123631\n      0.524386\n      0.566983\n      nan\n      5.000000\n      nan\n      -7.312097\n      0\n      0.210055\n      114.609197\n      4\n      0.951705\n      1\n    \n    \n      19\n      19\n      266726.000000\n      0.021030\n      0.323277\n      nan\n      -0.000861\n      nan\n      0.239698\n      -12.692935\n      1\n      0.031522\n      124.811208\n      4\n      0.350090\n      1\n    \n  \n\n\n\nWe find:\n\nThere are missing values that can be seen as nan in the table above\nThe id column seems to have values in increasing order\nThe values in the features are in different scales\n\nNow, let’s look at some basic statistics about our features in the data\n\n\nCode\ndisplay(train.describe().style.set_caption(\"Basic statistics about Train Data\"))\n\n\n\n\n\n  Basic statistics about Train Data\n  \n    \n       \n      id\n      song_duration_ms\n      acousticness\n      danceability\n      energy\n      instrumentalness\n      key\n      liveness\n      loudness\n      audio_mode\n      speechiness\n      tempo\n      time_signature\n      audio_valence\n      song_popularity\n    \n  \n  \n    \n      count\n      40000.000000\n      35899.000000\n      36008.000000\n      35974.000000\n      36025.000000\n      36015.000000\n      35935.000000\n      35914.000000\n      36043.000000\n      40000.000000\n      40000.000000\n      40000.000000\n      40000.000000\n      40000.000000\n      40000.000000\n    \n    \n      mean\n      19999.500000\n      193165.847572\n      0.276404\n      0.570951\n      0.683932\n      0.036527\n      5.042605\n      0.198514\n      -7.407596\n      0.321150\n      0.094107\n      116.562815\n      3.394375\n      0.580645\n      0.364400\n    \n    \n      std\n      11547.149720\n      45822.127679\n      0.297928\n      0.190010\n      0.212662\n      0.150024\n      3.372728\n      0.151670\n      3.877198\n      0.466924\n      0.083591\n      26.167911\n      0.524405\n      0.237351\n      0.481268\n    \n    \n      min\n      0.000000\n      25658.000000\n      -0.013551\n      0.043961\n      -0.001682\n      -0.004398\n      0.000000\n      0.027843\n      -32.117911\n      0.000000\n      0.015065\n      62.055779\n      2.000000\n      0.013398\n      0.000000\n    \n    \n      25%\n      9999.750000\n      166254.500000\n      0.039618\n      0.424760\n      0.539276\n      0.000941\n      2.000000\n      0.111796\n      -9.578139\n      0.000000\n      0.038500\n      96.995309\n      3.000000\n      0.398669\n      0.000000\n    \n    \n      50%\n      19999.500000\n      186660.000000\n      0.140532\n      0.608234\n      0.704453\n      0.001974\n      5.000000\n      0.135945\n      -6.345413\n      0.000000\n      0.055881\n      113.795959\n      3.000000\n      0.598827\n      0.000000\n    \n    \n      75%\n      29999.250000\n      215116.000000\n      0.482499\n      0.718464\n      0.870503\n      0.003225\n      8.000000\n      0.212842\n      -4.620711\n      1.000000\n      0.118842\n      128.517383\n      4.000000\n      0.759635\n      1.000000\n    \n    \n      max\n      39999.000000\n      491671.000000\n      1.065284\n      0.957131\n      1.039741\n      1.075415\n      11.000000\n      1.065298\n      -0.877346\n      1.000000\n      0.560748\n      219.163578\n      5.000000\n      1.022558\n      1.000000\n    \n  \n\n\n\nWe find:\n\nMost of the features are in the range of 0 and 1\nThere are features with only negative values (loudness), binary features (audio_mode) , and seems to be categorical (key and time_signature)\n\n\n\n3.2. Missing data\nNow let’s take a closer look at the missing values in the dataset\n\n\nCode\n\"\"\"Missing Values\"\"\"\nprint(f\"Train set has {train.isnull().sum().sum()} missing values, and test set has {test.isnull().sum().sum()} missing values\")\n\n\nTrain set has 32187 missing values, and test set has 7962 missing values\n\n\n\n\nCode\n# Refrence (edited): https://datavizpyr.com/visualizing-missing-data-with-seaborn-heatmap-and-displot/\nfig = plt.figure(figsize=(18,6))\n\nsns.displot(\n    data=train.isna().melt(value_name=\"missing\"),\n    y=\"variable\",\n    hue=\"missing\",\n    multiple=\"fill\",\n    aspect=3\n)\nplt.title(\"Missing values shown using Bar plot\", fontsize=17)\nplt.ylabel(\"\")\nplt.xlabel(\"\")\n\nplt.figure(figsize=(18,10))\nsns.heatmap(train.isna().transpose())\nplt.title('Heatmap showing Missing Values in Train data', fontsize=17)\nplt.ylabel(\"\")\nplt.xlabel(\"\")\nplt.show()\n\n\n<Figure size 1296x432 with 0 Axes>\n\n\n\n\n\n\n\n\n\n\nCode\ntrain_null = train.isna().sum().sort_values(ascending = False)\ntest_null = test.isna().sum().sort_values(ascending = False)\n\nnon_zero_train_values = train_null[train_null.values > 0]\nnon_zero_test_values = test_null[test_null.values > 0]\n\nfig, axes = plt.subplots(1,2, figsize=(15,8))\nsns.barplot(y=non_zero_test_values.index , x=non_zero_test_values.values, ax=axes[1], palette = \"viridis\")\nsns.barplot(y=non_zero_train_values.index , x=non_zero_train_values.values, ax=axes[0], palette = \"viridis\")\naxes[0].set_title(\"Train data\", fontsize=14)\naxes[1].set_title(\"Test data\", fontsize=14)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "posts/kaggle/song-popularity-eda.html#visualization---individual-features",
    "href": "posts/kaggle/song-popularity-eda.html#visualization---individual-features",
    "title": "Song Popularity EDA",
    "section": "4. Visualization - Individual Features",
    "text": "4. Visualization - Individual Features\nAfter getting an initial idea about our features and their values, we can now dive into the visual part of the exploration. I recommend to always plot your data. Sometimes this might be challenging, e.g. because you have tons of features. In that case, you want to start at least with a subset before you run any dimensionality reduction or other tools. This step is as much about spotting issues and irregularities as it is about learning more about the shapes and distributions of your features.\n\n4.1. Predictor variables\n\nIn the live session, we were building this plot step by step. (Well, we got most of the way there.) It really pays off to take the time and investigate each feature separately. This is one of the most instructive steps in the EDA process, where you aim to learn how messed up your features are. No dataset is perfect. We want to figure out how severe those imperfections are, and whether we can live with them or have to address them.\nDifferent kind of data types go best with different kind of visuals. My recommendation is to start out with density plots or histograms for numerical features, and with barcharts for those that are better expressed as types of categories.\n\n\n\nCode\nuseful_cols = [col for col in train.columns if col not in [\"id\", \"song_popularity\"]]\nnumeric_cols = [col for col in useful_cols if col not in [\"key\", \"audio_mode\", \"time_signature\"]]\n\nn_rows = 5\nn_cols = 3\nindex = 1\n\ncolors = [\"red\", \"darkblue\", \"green\"]\n\nfig = plt.figure(figsize=(16,20))\n\nfor index, col in enumerate(train[useful_cols].columns):\n    plt.subplot(n_rows,n_cols,index+1)\n    \n    if col in numeric_cols:\n        sns.kdeplot(train[col], color=random.sample(colors, 1), fill=True)\n        plt.title(col, fontsize=14)\n        plt.xlabel(\"\")\n        plt.ylabel(\"\")\n        plt.tight_layout()\n    else:\n        sns.countplot(train[col])\n        plt.title(col, fontsize=14)\n        plt.xlabel(\"\")\n        plt.ylabel(\"\")\n        plt.tight_layout()\n\nplt.subplot(n_rows,n_cols,14)\nsns.kdeplot(np.log(train['instrumentalness']), color=random.sample(colors, 1), fill=True)\nplt.title('instrumentalness (log transformed)', fontsize=14)\nplt.ylabel(\" \")\nplt.xlabel(\" \")\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nWe find:\n\nOur initial impressions of the data types have largely been confirmed: audio_mode is a boolean feature, and time_signature and key are ordinal or categorical ones (or integer; although a better understanding of those musical concepts would certainly benefit from some domain knowledge.)\nA number of features are bounded between 0 and 1: accosticness, danceability, energy, liveliness, speechiness, and audio_valence.\nThe feature loudness looks like it refer to the decibel scale.\nThe distribution of instrumentalness is heavily right-skewed, and even after a log transform this feature doesn’t look very well-behaved. This might need a bit more work.\n\n\n\n4.2. Target: Song Popularity\nOn to the target itself. We figured out that song_popularity is a binary feature, and thus we can express it as boolean. Here we plot a barchart.\n\n\nCode\nsns.countplot(train.song_popularity.astype(\"bool\"))\nplt.title(\"Target: Song Popularity\", fontsize=14)\nplt.xlabel(\"\")\nplt.ylabel(\"\")\nplt.show()\n\n\n\n\n\nWe find:\n\nThere is a slight imbalance in the target distribution: a bit more than 60/40. Not super imbalanced, but something to keep in mind."
  },
  {
    "objectID": "posts/kaggle/song-popularity-eda.html#feature-interactions",
    "href": "posts/kaggle/song-popularity-eda.html#feature-interactions",
    "title": "Song Popularity EDA",
    "section": "5. Feature interactions",
    "text": "5. Feature interactions\nAfter learning more about each individual feature, we now want to see them interacting with one another. It’s best to perfom those steps in that order, so that you can understand and interpret the interactions in the context of the overall distributions.\n\n5.1. Target impact\nWe have seen all the feature distributions, now we want to investigate whether they look different based on the target value. Here’s an example for song_duration:\n\n\nCode\nfig = plt.figure(figsize=(16,18))\nn_rows = 4\nn_cols = 3\n\nfor index, col in enumerate(numeric_cols):\n    plt.subplot(n_rows, n_cols, index+1)\n    \n    sns.kdeplot(train[col], hue=train.song_popularity.astype(\"bool\"), fill=True)\n    plt.title(col, fontsize=14)\n    plt.xlabel(\"\")\n    plt.ylabel(\"\")\n    plt.tight_layout()\nplt.show()\n\n\n\n\n\nObservations:\n\nBy looking at the probability distribution of different variables we find that popular songs are almost exactly the same length as unpopular ones. There is a slight difference, but it’s pretty small.\n\nNow we can check the categorical features.\n\n\nCode\nfig = plt.figure(figsize=(18,5))\n\nfor index, col in enumerate([\"key\", \"audio_mode\", \"time_signature\"]):\n    plt.subplot(1,3,index+1)\n    \n    sns.countplot(train[col], hue=train.song_popularity.astype(\"bool\"))\n    plt.title(col, fontsize=14)\n    plt.xlabel(\"\")\n    plt.ylabel(\"\")\n    plt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n5.2. Feature Interaction\nHow do the predictor features interact with each other? Are there any redundancies or strong relationships? We will start out with a correlation matrix, and then look at features of interest in a bit more detail.\n\n5.2.1. Correlations overview\n\n\nCode\n# Refrence (edited): https://towardsdatascience.com/better-heatmaps-and-correlation-matrix-plots-in-python-41445d0f2bec\ndef heatmap(data):\n    corr = pd.melt(data.reset_index(), id_vars='index') # Unpivot the dataframe, so we can get pair of arrays for x and y\n    corr.columns = ['x', 'y', 'value']\n    x=corr['x']\n    y=corr['y']\n    size=corr['value'].abs()\n    color=corr['value']\n    \n    fig, ax = plt.subplots(figsize=(10,10))\n    plot_grid = plt.GridSpec(1, 15, hspace=0.2, wspace=0.1) # Setup a 1x15 grid\n    ax = plt.subplot(plot_grid[:,:-1]) # Use the leftmost 14 columns of the grid for the main plot\n    \n    n_colors = 256 # Use 256 colors for the diverging color palette\n    palette = sns.diverging_palette(20, 220, n=n_colors) # Create the palette\n    color_min, color_max = [-1, 1] # Range of values that will be mapped to the palette, i.e. min and max possible correlation\n    size_min, size_max = 0, 1\n    \n    def value_to_color(val):\n        val_position = float((val - color_min)) / (color_max - color_min) # position of value in the input range, relative to the length of the input range\n        val_position = min(max(val_position, 0), 1) # bound the position betwen 0 and 1\n        ind = int(val_position * (n_colors - 1)) # target index in the color palette\n        return palette[ind]\n    \n    def value_to_size(val):\n        val_position = (val - size_min) * 0.99 / (size_max - size_min) + 0.01 # position of value in the input range, relative to the length of the input range\n        val_position = min(max(val_position, 0), 1) # bound the position betwen 0 and 1\n        return val_position * size_scale\n        \n    # Mapping from column names to integer coordinates\n    x_labels = [v for v in sorted(x.unique())]\n    y_labels = [v for v in sorted(y.unique())]\n    x_to_num = {p[1]:p[0] for p in enumerate(x_labels)} \n    y_to_num = {p[1]:p[0] for p in enumerate(y_labels)} \n    \n    size_scale = 500\n    ax.scatter(\n        x=x.map(x_to_num), # Use mapping for x\n        y=y.map(y_to_num), # Use mapping for y\n        s=size.apply(value_to_size), # Vector of square sizes, proportional to size parameter\n        c=color.apply(value_to_color), # Vector of square color values, mapped to color palette\n        marker='s' # Use square as scatterplot marker\n    )\n    \n    # Show column labels on the axes\n    ax.set_xticks([x_to_num[v] for v in x_labels])\n    ax.set_xticklabels(x_labels, rotation=45, horizontalalignment='right')\n    ax.set_yticks([y_to_num[v] for v in y_labels])\n    ax.set_yticklabels(y_labels)\n    \n    ax.grid(False, 'major')\n    ax.grid(True, 'minor')\n    ax.set_xticks([t + 0.5 for t in ax.get_xticks()], minor=True)\n    ax.set_yticks([t + 0.5 for t in ax.get_yticks()], minor=True)\n        \n    ax.set_xlim([-0.5, max([v for v in x_to_num.values()]) + 0.5])\n    ax.set_ylim([-0.5, max([v for v in y_to_num.values()]) + 0.5])\n    ax.set_facecolor('#F1F1F1')\n    \n    # Add color legend on the right side of the plot\n    ax = plt.subplot(plot_grid[:,-1]) # Use the rightmost column of the plot\n\n    col_x = [0]*len(palette) # Fixed x coordinate for the bars\n    bar_y=np.linspace(color_min, color_max, n_colors) # y coordinates for each of the n_colors bars\n\n    bar_height = bar_y[1] - bar_y[0]\n    ax.barh(\n        y=bar_y,\n        width=[5]*len(palette), # Make bars 5 units wide\n        left=col_x, # Make bars start at 0\n        height=bar_height,\n        color=palette,\n        linewidth=0\n    )\n    ax.set_xlim(1, 2) # Bars are going from 0 to 5, so lets crop the plot somewhere in the middle\n    ax.grid(False) # Hide grid\n    ax.set_facecolor('white') # Make background white\n    ax.set_xticks([]) # Remove horizontal ticks\n    ax.set_yticks(np.linspace(min(bar_y), max(bar_y), 3)) # Show vertical ticks for min, middle and max\n    ax.yaxis.tick_right() # Show vertical ticks on the right\n    \n\n\n\n\nCode\nheatmap(train[numeric_cols].corr())\n\n\n\n\n\nBelow is a similar correlation heatmap but only using the lower triangle to show the correlation.\n\n\nCode\n# Refrence (edited): https://medium.com/@szabo.bibor/how-to-create-a-seaborn-correlation-heatmap-in-python-834c0686b88e\n\nfig = plt.figure(figsize=(10,10))\nmatrix = np.triu(np.ones_like(train[numeric_cols].corr(), dtype=np.bool))\nsns.heatmap(train[numeric_cols].corr(), mask=matrix, vmin=-1, vmax=1, annot=True, cmap=sns.diverging_palette(220, 20, as_cmap=True))\nplt.show()\n\n\n\n\n\nWe find:\n\nThere’s a strong anti-correlation between acousticness vs energy and loudness, respectively. Consequently, energy and loudness share a strong correlation.\nNone of the features individually show a notable correlation with the target song_popularity.\n\n\n\n5.2.2. Categorical feature interactions\nWhenever we’re looking at categorical features, we can assign a visualisation dimension like colour, size, or facets to those. We will start modifying our trusted density plots to look at the distributions of energy (potentially one of the more interesting numerical features) for the different values of time_signature (here encoded as colour):\n\n\nCode\nfig = plt.figure(figsize=(10,8))\nsns.kdeplot(x=\"energy\", hue=\"time_signature\", data=train, fill=True, bw=0.03)\nplt.show()\n\n\n\n\n\n\n\nCode\n(ggplot(train, aes(\"key\", \"time_signature\", fill = \"energy\")) \n + geom_tile()\n + theme(figure_size=(16,5))\n + scale_x_continuous(breaks=range(0,12)))\n\n\n\n\n\n<ggplot: (8777952485729)>\n\n\nWe find:\n\nFor time_signatures 2 and 5 we have no instances of key == 11. This is no big surprise, since those three values are already rare individually, which makes their combinations even more rare.\nThere are no clear clusters of high vs low energy features here.\nWe can see certain combinations that are particularly low energy, such as key == 2 and time_signature == 1 or 8. key == 3 and time_signature == 1 seems to be a particularly energetic combination.\n\n\n\n\n5.3. Feature Target Interaction\nOnce we have found interesting correlations we can look for clustering in the target variable.\n\n\nCode\n(ggplot(train, aes('key', 'time_signature')) \n + geom_tile(aes(fill='energy')) \n + facet_wrap(\"song_popularity\", nrow = 2) \n + theme_minimal() \n + theme(figure_size=(16, 8))\n + scale_x_continuous(breaks=range(0,12)))\n\n\n\n\n\n<ggplot: (8777950648995)>\n\n\n\n\nCode\nsns.displot(data=train, x=\"energy\", y=\"audio_valence\", col=\"song_popularity\", kind=\"kde\", fill=True, legend=True, height=8, aspect=0.75)\nplt.show()\n\n\n\n\n\n\n\nCode\nfig = plt.figure(figsize=(12,6))\nsns.scatterplot(x=\"energy\", y=\"acousticness\", hue=\"song_popularity\", data=train)\nplt.show()\n\n\n\n\n\n\n\nMore Resources:\n\nChoosing different color palette in Seaborn\nSee also\n\nPairGrid: Subplot grid for plotting pairwise relationships\nrelplot: Combine a relational plot and a FacetGrid\ndisplot: Combine a distribution plot and a FacetGrid\ncatplot: Combine a categorical plot and a FacetGrid\nlmplot: Combine a regression plot and a FacetGrid\n\n\nSpecial Thanks to Martin Henze for sharing his knowledge during the live coding session. Also, thank you Abhishek Thakur for hosting these wonderful sessions for people to learn. I look forward to learn more.\nShare if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/mlops/introduction.html",
    "href": "posts/mlops/introduction.html",
    "title": "Introduction to MLOps",
    "section": "",
    "text": "For as long as I can remember, Jupyter Notebooks have been my go-to tool for machine learning (ML) projects. When it comes to experimentation, prototyping, and data exploration, Jupyter Notebooks undoubtedly reign supreme. However, automating and operationalizing ML products presents a significant challenge.\nThat’s where MLOps (Machine Learning Operations) comes into play. MLOps refers to a set of practices aimed at fostering collaboration and communication between data scientists and operations professionals. It bridges the gap between ML development and deployment, streamlining the process and ensuring efficient and scalable ML product deployment.\nSource: Neptune.ai"
  },
  {
    "objectID": "posts/mlops/introduction.html#drawbacks-on-working-with-jupyter-notebooks",
    "href": "posts/mlops/introduction.html#drawbacks-on-working-with-jupyter-notebooks",
    "title": "Introduction to MLOps",
    "section": "Drawbacks on working with Jupyter Notebooks",
    "text": "Drawbacks on working with Jupyter Notebooks\n\nLack of reproducibility: The flexibility to execute cells independently and out of order can make reproducing experiments challenging. It is crucial to carefully document the order of cell execution and ensure that all necessary cells are run to achieve reproducible results.\nIssues with version control: Jupyter Notebooks are not designed to work seamlessly with version control systems like Git. The JSON-based structure of notebooks makes it difficult to track changes, merge conflicts, and collaborate effectively when multiple team members are working on the same notebook simultaneously.\nLack of scalability: Jupyter Notebooks may face limitations in dealing with large datasets or computationally demanding tasks. Due to their single kernel architecture, they may struggle with memory restrictions and long execution times when working with big data or complex machine learning models.\nLimited code organization: While Jupyter Notebooks allow for code organization using cells and sections, larger notebooks can become challenging to navigate and maintain. As the size of the notebook grows, it can be harder to find specific sections of code, leading to reduced code readability and maintainability.\nPerformance limitations: Jupyter Notebooks excel in providing an interactive and exploratory environment, but they may not be the most performant option for computationally intensive tasks. For tasks requiring high-speed execution or efficient memory utilization, alternative tools like Python scripts or specialized frameworks may be more suitable."
  },
  {
    "objectID": "posts/mlops/introduction.html#devops-vs-mlops",
    "href": "posts/mlops/introduction.html#devops-vs-mlops",
    "title": "Introduction to MLOps",
    "section": "DevOps vs MLOps",
    "text": "DevOps vs MLOps\nDevOps principles have gained widespread acceptance in the software development industry due to their ability to integrate and automate software development and IT operations, leading to iterative improvements, fast feedback, collaboration, and automation. MLOps principles, derived from DevOps, aim to bring these best practices to the realm of machine learning and enable faster deployment of ML models into production.\nHowever, there are notable differences in how MLOps operates compared to DevOps:\n\nExperimental nature: MLOps involves extensive experimentation by data scientists and ML/DL engineers. They need to manage data and code to ensure reproducibility while experimenting with different features such as hyperparameters, parameters, and models. Reproducibility remains a challenge in the ML/DL sector, which sets it apart from the more deterministic nature of traditional software development in DevOps.\nHybrid team composition: MLOps teams have a hybrid structure that includes data scientists or ML researchers alongside software engineers. While data scientists focus on experimentation, model development, and exploratory data analysis, they may lack the expertise of software engineers in building production-ready services. This combination of skill sets is essential for successfully deploying ML models in production. `\nTesting: Testing in MLOps goes beyond conventional code tests like unit testing and integration testing. It encompasses model validation, model training, and other specific tasks associated with testing an ML system. The unique challenges of testing ML models require specialized techniques and frameworks to ensure model accuracy and reliability.\nAutomated deployment: Deploying an offline-trained ML model as a prediction service requires a multi-step pipeline in MLOps. Automating the tasks that data scientists manually perform before model deployment adds complexity to the process. It involves automating model retraining, validation, and deployment steps to ensure efficient and seamless deployment of updated models.\nProduction performance degradation and Training-Serving Skew: ML models in production can experience reduced performance due to changing data profiles or suboptimal coding. Unlike traditional software systems, ML models are sensitive to changes in data and require monitoring and adaptation to maintain optimal performance. Training-Serving Skew refers to discrepancies between how data is handled in the training and serving pipelines, which can further impact model performance.\nMonitoring: Monitoring is essential for ML models in production. It involves tracking the performance of deployed models and monitoring the summary statistics of the data used to build the models. Monitoring helps identify deviations from expected values, triggering alerts or initiating a roll-back process when necessary. Since data profiles and statistics can change over time, ongoing monitoring is critical for maintaining model effectiveness."
  },
  {
    "objectID": "posts/mlops/introduction.html#mlops-principles",
    "href": "posts/mlops/introduction.html#mlops-principles",
    "title": "Introduction to MLOps",
    "section": "MLOps Principles",
    "text": "MLOps Principles\nMLOps, which stands for Machine Learning Operations, encompasses a set of principles and practices aimed at streamlining the lifecycle of machine learning projects and promoting collaboration and communication between teams. Here are some key principles of MLOps:\n\nVersion control: Implementing version control systems, such as Git, enables tracking and management of changes to ML models, code, and data. It ensures reproducibility, facilitates collaboration and helps teams work together effectively.\nContinuous Integration and Continuous Deployment (CI/CD): MLOps encourages the use of CI/CD pipelines for automating the build, testing, and deployment of ML models. This iterative approach enables fast feedback, reduces errors, and accelerates the development and deployment process.\nInfrastructure as Code (IaC): MLOps embraces the concept of treating infrastructure as code using tools like Terraform or AWS CloudFormation. By defining infrastructure configurations using code, teams can easily manage and version control their cloud infrastructure. IaC enables reproducibility by providing a consistent and automated way to provision and manage resources in the cloud. It also facilitates scalability, allowing teams to easily scale up or down their infrastructure as needed, ensuring efficient and cost-effective deployments for ML models.\nModel Monitoring: Monitoring ML models in production is vital to detect performance issues, data drift, and anomalies. Dedicated monitoring tools help track model performance, identify deviations, and trigger alerts for timely updates and maintenance.\nCollaboration and Communication: Effective collaboration and communication between data scientists, engineers, and operations teams are critical in MLOps. Sharing knowledge, documenting processes, and fostering a collaborative culture enhance team productivity and ensure the successful delivery of ML projects.\nAutomated Testing: Implementing automated testing frameworks ensures the quality and reliability of ML models. This includes unit tests, integration tests, and performance tests that validate model behavior and catch potential issues early in the development process.\n\n Source: End-to-End Machine Learning Platforms By Ian Hellström"
  },
  {
    "objectID": "posts/mlops/introduction.html#mlops-maturity-model",
    "href": "posts/mlops/introduction.html#mlops-maturity-model",
    "title": "Introduction to MLOps",
    "section": "MLOps maturity model",
    "text": "MLOps maturity model\nThe MLOps maturity model represents the level of proficiency and scalability in managing and operationalizing machine learning (ML) systems within an organization. It illustrates how effectively the company can develop, implement, monitor, and maintain ML models. The stages of MLOps maturity may vary depending on the framework or model used, but they generally progress as follows:\n\nLevel 0: No MLOps\n\nManaging the complete lifecycle of ML models is challenging.\nTeams are diverse, and releases are cumbersome.\nLack of transparency and feedback from deployed models.\n\nLevel 1: DevOps but no MLOps\n\nReleases are less cumbersome compared to Level 0 but still rely heavily on the Data Team for each new model.\nLimited feedback on model performance in production.\nDifficulties in tracing and reproducing results.\n\nLevel 2: Automated Training\n\nThe training environment is fully managed and traceable.\nModels can be easily reproduced.\nReleases are performed manually but with reduced friction.\n\nLevel 3: Automated Model Deployment\n\nReleases are automated and have low friction.\nFull traceability from deployment back to the original data.\nThe entire environment is managed, including training, testing, and production stages.\n\nLevel 4: Full MLOps Automated Operations\n\nThe entire system is automated and easily monitored.\nProduction systems provide insights for continuous improvement and can automatically incorporate new models.\nApproaching a zero-downtime system with high availability."
  },
  {
    "objectID": "posts/mlops/introduction.html#bonus-reading-materials",
    "href": "posts/mlops/introduction.html#bonus-reading-materials",
    "title": "Introduction to MLOps",
    "section": "Bonus Reading Materials",
    "text": "Bonus Reading Materials\n\nMLOps Maturity Model - Azure\nMade with ML - By Goku Mohandas\nMLOps Primer\n\nThank you for reading and I hope you found this notebook helpful. Upvote if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/mlops/aws_setup.html",
    "href": "posts/mlops/aws_setup.html",
    "title": "AWS Instance Setup",
    "section": "",
    "text": "Welcome to our blog post where we’ll guide you through setting up your AWS instance and installing all the necessary requirements for your work. We understand the importance of a smooth and efficient setup process, so we’ll provide step-by-step instructions to ensure you have everything you need to get started.\nLet’s dive in and get your environment up and running seamlessly!"
  },
  {
    "objectID": "posts/mlops/aws_setup.html#setup-aws-instance",
    "href": "posts/mlops/aws_setup.html#setup-aws-instance",
    "title": "AWS Instance Setup",
    "section": "Setup AWS Instance",
    "text": "Setup AWS Instance\n\nGo to https://aws.amazon.com to Sign in / Create an AWS Account.\nTo launch EC2 instance, click on to services on the left-top corner of the page. Select Compute and EC2.\n\n\n\nTo launch a new instance, click on Launch Instance.\n\n\n\nSet any Name to the instance and select Ubuntu in the Application and OS Images section. Also, choose Ubuntu Server 20.04 LTS (HVM), SSD Volume Type as the Amazon Machine Image (AMI).\n\n\n\nSelect t2.xlarge as the Instance type for our instance. As 16GiB of memory should be ideal for our work.\n\n\n\nIf you don’t already have a Key pair, you can create a new key pair. You would be asked to download and save your key pair.\n\n\n\n\n\n\n\nTip\n\n\n\nSave your key pair at ~/.ssh/ folder.\n\n\n\n\n\n\nLastly, increase the storage to 30 GiB as we would be working with large file and docker images with would consume some space.\n\n\n\nClick on Launch Instance to create and start the new instance."
  },
  {
    "objectID": "posts/mlops/aws_setup.html#connect-to-instance-via-ssh",
    "href": "posts/mlops/aws_setup.html#connect-to-instance-via-ssh",
    "title": "AWS Instance Setup",
    "section": "Connect to Instance via SSH",
    "text": "Connect to Instance via SSH\nOnce your instance is running, you can go to the instance summary page to checkout your Public IPv4 address which will be used to connect to the instance via ssh.\nTo check whether you can establish a connection to your instance:\nssh -i ~/.ssh/mlops-zc-key.pem ubuntu@<your-public-ipv4-address>\nEg. ssh -i ~/.ssh/mlops-zc-key ubuntu@34.236.146.20\n\n\n\n\n\n\nbad permissions error\n\n\n\nIf you receive an error like:\nIt is required that your private key files are NOT accessible by others. This private key will be ignored.\nChange the file permission using the command:\nchmod go-r ~/.ssh/mlops-zc-key.pem\n\n\nIf asked about “Are you sure you want to continue connecting (yes/no/[fingerprint])?”, type yes.\nRather than manually entering the whole command, you can save the configurations at ~/.ssh/config file. If you don’t already have an file name config in the ~/.ssh/ directory then go to your .ssh directory and use the command touch config to create the file.\nTo edit the file use the command vim ~/.ssh/config.\nIn the file add the following details:\nHost mlops-zoomcamp\n    HostName <your-public-ipv4-address>\n    User ubuntu\n    IdentityFile ~/.ssh/mlops-zc-key.pem\n\n\n\n\n\n\nCaution\n\n\n\nEvery time you stop and start your instance you would have to edit the config file and change the public ipv4 address with the new ipv4 address."
  },
  {
    "objectID": "posts/mlops/aws_setup.html#install-softwares",
    "href": "posts/mlops/aws_setup.html#install-softwares",
    "title": "AWS Instance Setup",
    "section": "Install Softwares",
    "text": "Install Softwares\n\nPython\n\nCreate a directory called downloads and move into the directory.\n\nmkdir downloads\ncd downloads\n\nDownload and Install Anaconda\n\nwget https://repo.anaconda.com/archive/Anaconda3-2023.03-1-Linux-x86_64.sh\nbash Anaconda3-2023.03-1-Linux-x86_64.sh\n\nFor the following prompts:\n\nAnaconda3 will now be installed into this location:\n/home/ubuntu/anaconda3\nPress Enter\nDo you wish the installer to initialize Anaconda3\nby running conda init? [yes|no]\n[no] >>>\nType yes\nPython installed 🎉\n\n\nDocker\n\nUpdate packages using the command\n\nsudo apt update\n\nInstall Docker\n\nsudo apt install docker.io\n\nCheck docker is installed by running hello-world program in docker:\n\nsudo docker run hello-world\nWe don’t want to use sudo everytime we run docker. To do that, create the docker group and add your user:\n\nCreate the docker group.\n\nsudo groupadd docker\n\nAdd your user to the docker group.\n\nsudo usermod -aG docker $USER\n\nLog out and log back in so that your group membership is re-evaluated.\n\n\n\n\n\n\n\nNote\n\n\n\nIf you’re running Linux in a virtual machine, it may be necessary to restart the virtual machine for changes to take effect.\n\n\n\nTo check if you can run docker without using sudo, use the command\n\ndocker --help\nDocker installed 🎉\n\n\ndocker-compose\n\nMove to the home directory. It will look like\n\nubuntu@ip-172-31-19-228:~/downloads$ cd ..\nubuntu@ip-172-31-19-228:~$ ls\nanaconda3 downloads\n\nCreate a folder named soft and move into the folder.\n\nmkdir soft\ncd soft\n\nDownload docker-compose and make the file executable\n\nwget https://github.com/docker/compose/releases/download/v2.18.1/docker-compose-linux-x86_64 -O docker-compose\n\nchmod +x docker-compose\nTo access docker-compose from any location we need to add the PATH to the bashrc file. Again move to the home directory.\n\nOpen the .bashrc file using the command\n\nvim .bashrc\n\nMove to the end of the file and press i to go into Insert Mode.\nAdd the following peice of code in the file.\n\nexport PATH=\"${HOME}/soft:${PATH}\"\n\nSave and Exit the file:\n\nPress esc key\nType :wq and hit enter\n\n\n\nRun the command to execute the file:\n\nsource .bashrc\n\nCross-check by typing which docker-compose. You’ll get the output as /home/ubuntu/soft/docker-compose\n\ndocker-compose installed 🎉\n\n\n\n\n\n\nSTOP EC2 instance\n\n\n\nPlease remember to stop the EC2 instance after completing your work to avoid incurring any additional charges.\n\n\nThank you for reading and I hope you found this notebook helpful. Upvote if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/mlops/mlflow.html",
    "href": "posts/mlops/mlflow.html",
    "title": "Introduction to MLflow",
    "section": "",
    "text": "Welcome to our latest blog post, where we delve into the fascinating world of experiment tracking and its powerful implementation using MLflow. 📚 We’ll explore the concept of experiment tracking and learn how MLflow can revolutionize the way we track and manage our machine learning experiments.\nIn this comprehensive guide, we will walk you through the process of leveraging MLflow to effectively track your experiments, enabling you to gain valuable insights into model performance, parameter tuning, and results. Discover how MLflow’s model registry feature empowers you to version your models, ensuring reproducibility and seamless collaboration."
  },
  {
    "objectID": "posts/mlops/mlflow.html#what-is-experiment-tracking",
    "href": "posts/mlops/mlflow.html#what-is-experiment-tracking",
    "title": "Introduction to MLflow",
    "section": "What is Experiment Tracking?",
    "text": "What is Experiment Tracking?\nIn a nutshell, it is the process of building an ML model. More formally, Experiment tracking is the process of keeping track of all the relevant information from an ML experiment, which includes:\n\nSource code\nEnvironment\nData\nModel\nHyperparameters\nMetrics\n\nTerminologies associated with ML Experiments:\n\nExperiment Run: Each trail while building an ML model is called an experiment run. Whether it’s training a vanilla Linear Regression model or conducting hyperparameter tuning with various combinations, each distinct attempt is considered an experiment run. It allows for systematic organization and analysis of different approaches and variations.\nRun Artifact: Any file that is associated with an ML run is an Artifact. Example: Model weights, Model predictions, Model metrics, etc.\nExperiment Metadata: Additional information such as Model Signature - description of a model’s inputs and outputs, Model Input Example - example of a valid model input."
  },
  {
    "objectID": "posts/mlops/mlflow.html#why-is-experiment-tracking-important",
    "href": "posts/mlops/mlflow.html#why-is-experiment-tracking-important",
    "title": "Introduction to MLflow",
    "section": "Why is Experiment Tracking Important?",
    "text": "Why is Experiment Tracking Important?\n\nReproducibility: It is important to be able to reproduce the results of an experiment. This is especially true in the case of ML experiments where the results are not deterministic. Experiment tracking helps us to reproduce the results of an experiment by keeping track of all the relevant information.\nOrganization: Any file associated with an ML run is considered an artifact. These artifacts can include crucial components such as model weights, model predictions, model metrics, or any other files generated during the experiment. They serve as valuable resources for evaluating and understanding the outcomes of each run.\nOptimization: In addition to the core elements of an ML experiment, there is additional metadata that provides valuable context and insights. This metadata includes the model signature, which describes the inputs and outputs of the model, and the model input example, which provides an example of a valid input for the model. These details contribute to a comprehensive understanding of the experiment and aid in reproducibility.\n\nIn the past, before the advent of dedicated experiment tracking tools, researchers and data scientists relied on spreadsheets to keep track of their experiments. However, this manual approach presented several challenges and limitations. Let’s explore the major points of concern:\n\nError Prone: The process of manually copying and pasting the results of an experiment from a Jupyter notebook or other sources into a spreadsheet was tedious and error-prone. It often led to mistakes or inaccuracies in recording the data, undermining the reliability and integrity of the experiment records.\nNo standard format: Without a standardized format for organizing and documenting experiment results, researchers faced difficulties in comparing and analyzing the outcomes of different experiments. The lack of consistency hindered the ability to draw meaningful insights and make informed decisions based on the collected data.\nVisibility & Collaboration: Sharing experiment results with other team members was a cumbersome task. Spreadsheet-based tracking offered limited visibility and collaboration capabilities, impeding effective teamwork and knowledge sharing. It was challenging to provide access, gather feedback, or collaborate on an experiment in a seamless manner."
  },
  {
    "objectID": "posts/mlops/mlflow.html#getting-started-with-mlflow",
    "href": "posts/mlops/mlflow.html#getting-started-with-mlflow",
    "title": "Introduction to MLflow",
    "section": "Getting Started with MLflow",
    "text": "Getting Started with MLflow\nMLflow is an open-source platform for managing the end-to-end machine learning lifecycle. It provides a comprehensive set of tools for tracking experiments, packaging ML code, and deploying models. MLflow is designed to work with any ML library and language, and it is built on an open API, enabling seamless integration with other platforms and tools.\nTo see MLflow in action, let’s walk through a simple example of training a Linear Regression model on NY Green Taxi Trips dataset. We will use MLflow to track the experiment and record the results.\n\nInstall MLflow and Setup Environment\nCreate a new virtual environment and install MLflow and other libraries using the following command:\n\n\nrequirements.txt\n\nmlflow\njupyter\nscikit-learn\npandas\nxgboost\nfastparquet\nhyperopt\noptuna\n\n# Create conda environment\nconda create -p venv python=3.9 -y\n\n# Activate conda environment\nconda activate venv/\n\n# Install required libraries\npip install -r requirements.txt --no-cache-dir\nDownload the dataset using the following command:\n# Create data directory\nmkdir data\n\n# Move to data directory\ncd data\n\n# Download dataset\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-01.parquet # January 2022\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-02.parquet # February 2022\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-03.parquet # March 2022\nWe’ll also create a jupyter notebook named mlflow.ipynb to run our experiment. After following the above steps, you should have the following directory structure:\n.\n├── data\n│   ├── green_tripdata_2022-01.parquet\n│   ├── green_tripdata_2022-02.parquet\n│   └── green_tripdata_2022-03.parquet\n├── mlflow.ipynb\n├── requirements.txt\n└── venv\nTo see MLflow UI in action, we’ll run the following command while you’re in the root directory in the terminal:\nmlflow ui\nThis will start the MLflow server on port 5000. You can access the MLflow UI at http://127.0.0.1:5000. Shown below:\n\n\n\n\n\n\n\nNote\n\n\n\nIf you face an Access to 127.0.0.1 was denied. You don’t have authorization to view this page. HTTP ERROR 403 error while accessing the MLflow UI, you can resolve it by clearing the browser cache and cookies.\n\n\nOne interesting thing to note here is that MLflow will create a new directory named mlruns in the current working directory. This directory will contain all the experiment runs and artifacts. This configuration of backend and artifact storage is called MLflow on localhost. There are other configurations available as well, which we will explore in another post.\n\n\n\nSource: MLflow Documentation\n\n\n\n\nLoad Dataset\nLet’s start by importing the required libraries and loading the dataset.\n\n\nShow the code\nimport os\nimport numpy as np\nimport pandas as pd\nimport pickle\nimport mlflow\nimport optuna\n\nfrom mlflow.entities import ViewType\nfrom mlflow.tracking import MlflowClient\nfrom optuna.samplers import TPESampler\nfrom sklearn.feature_extraction import DictVectorizer\nfrom sklearn.linear_model import LinearRegression, Lasso\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_squared_error\n\n\n\ndef read_dataframe(filename: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a Parquet file into a pandas DataFrame, performs data transformations, and returns the resulting DataFrame.\n\n    Parameters:\n        filename (str): The path to the Parquet file to be read.\n\n    Returns:\n        pandas.DataFrame: The processed DataFrame containing the data from the Parquet file.\n\n    Raises:\n        [Any exceptions raised by pandas.read_parquet()]\n\n    Notes:\n        - The function performs the following transformations on the DataFrame:\n            - Converts 'lpep_dropoff_datetime' and 'lpep_pickup_datetime' columns to pandas datetime objects.\n            - Computes the 'duration' column by subtracting 'lpep_pickup_datetime' from 'lpep_dropoff_datetime'\n              and converting the result to minutes.\n            - Filters the DataFrame to include rows where the 'duration' is between 1 and 60 minutes (inclusive).\n            - Converts 'PULocationID' and 'DOLocationID' columns to string type.\n\n    Example:\n        filename = 'data.parquet'\n        df = read_dataframe(filename)\n    \"\"\"\n    # Read the Parquet file into a DataFrame\n    df = pd.read_parquet(filename)\n\n    # Convert 'lpep_dropoff_datetime' and 'lpep_pickup_datetime' columns to pandas datetime objects\n    df.lpep_dropoff_datetime = pd.to_datetime(df.lpep_dropoff_datetime)\n    df.lpep_pickup_datetime = pd.to_datetime(df.lpep_pickup_datetime)\n\n    # Compute the 'duration' column by subtracting 'lpep_pickup_datetime' from 'lpep_dropoff_datetime' and converting to minutes\n    df['duration'] = df.lpep_dropoff_datetime - df.lpep_pickup_datetime\n    df.duration = df.duration.apply(lambda td: td.total_seconds() / 60)\n\n    # Filter the DataFrame to include rows where the 'duration' is between 1 and 60 minutes (inclusive)\n    df = df[(df.duration >= 1) & (df.duration <= 60)]\n\n    # Convert 'PULocationID' and 'DOLocationID' columns to string type\n    categorical = ['PULocationID', 'DOLocationID']\n    df[categorical] = df[categorical].astype(str)\n    \n    # Return the processed DataFrame\n    return df\n\n\n# Read the Parquet file for training data into a DataFrame\ndf_train = read_dataframe('./data/green_tripdata_2022-01.parquet')\n\n# Read the Parquet file for validation data into a DataFrame\ndf_val = read_dataframe('./data/green_tripdata_2022-02.parquet')\n\n# Read the Parquet file for testing data into a DataFrame\ndf_test = read_dataframe('./data/green_tripdata_2022-03.parquet')\n\n\n\nPrepare and Transform Dataset\n\ndef preprocess(df: pd.DataFrame, dv: DictVectorizer, fit_dv: bool = False):\n    \"\"\"\n    Preprocesses a pandas DataFrame by creating new features, transforming categorical features into a numerical format,\n    and returning the transformed data along with the DictVectorizer.\n\n    Parameters:\n        df (pandas.DataFrame): The input DataFrame to be preprocessed.\n        dv (sklearn.feature_extraction.DictVectorizer): The DictVectorizer instance to be used for transforming categorical features.\n        fit_dv (bool, optional): Indicates whether to fit the DictVectorizer on the data. Defaults to False.\n\n    Returns:\n        tuple: A tuple containing the transformed feature matrix and the DictVectorizer instance.\n\n    Notes:\n        - The function assumes that the DataFrame contains the columns 'PULocationID' and 'DOLocationID'.\n        - The function creates a new feature 'PU_DO' by concatenating 'PULocationID' and 'DOLocationID'.\n        - The categorical feature 'PU_DO' and numerical feature 'trip_distance' are selected for transformation.\n        - The function transforms the selected features into a dictionary representation and applies the DictVectorizer.\n        - If fit_dv is True, the DictVectorizer is fitted on the data. Otherwise, the existing fitted DictVectorizer is used.\n\n    Example:\n        df = read_dataframe('data.parquet')\n        dv = DictVectorizer()\n        X, dv = preprocess(df, dv, fit_dv=True)\n    \"\"\"\n    # Create a new feature 'PU_DO' by concatenating 'PULocationID' and 'DOLocationID'\n    df['PU_DO'] = df['PULocationID'] + '_' + df['DOLocationID']\n\n    # Select categorical and numerical features for transformation\n    categorical = ['PU_DO']\n    numerical = ['trip_distance']\n\n    # Convert the selected features into a dictionary representation\n    dicts = df[categorical + numerical].to_dict(orient='records')\n\n    # Apply DictVectorizer for transforming categorical features\n    if fit_dv:\n        # Fit the DictVectorizer on the data\n        X = dv.fit_transform(dicts)\n    else:\n        # Transform using the existing fitted DictVectorizer\n        X = dv.transform(dicts)\n\n    # Return the transformed feature matrix and DictVectorizer\n    return X, dv\n\n\n# Extract the target variable\ntarget = 'duration'\n\n# Extract the target variable from the training, validation and testing datasets\ny_train = df_train[target].values\ny_val = df_val[target].values\ny_test = df_test[target].values\n\n# Initialize a DictVectorizer for preprocessing\ndv = DictVectorizer()\n\n# Preprocess the training data\nX_train, dv = preprocess(df_train, dv, fit_dv=True)\n\n# Preprocess the validation data using the fitted DictVectorizer from the training data\nX_val, _ = preprocess(df_val, dv, fit_dv=False)\n\n# Preprocess the testing data using the fitted DictVectorizer from the training data\nX_test, _ = preprocess(df_test, dv, fit_dv=False)\n\n\ndef dump_pickle(obj, filename: str):\n    \"\"\"\n    Pickles (serializes) an object and saves it to a file.\n\n    Parameters:\n        obj (Any): The object to be pickled.\n        filename (str): The path and filename to save the pickled object.\n\n    Returns:\n        None\n\n    Notes:\n        - The function uses the 'pickle' module to serialize the object and save it to a file.\n        - The file is opened in binary mode for writing using the \"wb\" mode.\n    \"\"\"\n    with open(filename, \"wb\") as f_out:\n        return pickle.dump(obj, f_out)\n\n\n# Specify the destination path for saving files\ndest_path = './outputs'\n\n# Create dest_path folder unless it already exists\nos.makedirs(dest_path, exist_ok=True)\n\n# Save DictVectorizer object as a pickle file\ndump_pickle(dv, os.path.join(dest_path, \"dv.pkl\"))\n\n\n\nTrain Linear Regression Model with MLflow\nIn mlflow you create one experiment and all the runs are stored under that experiment. You can create a new experiment using the following command:\n\n# Create a new experiment\nmlflow.set_experiment(\"nyc-taxi-experiment\")\n\nIf you check your MLflow UI, you’ll notice a new experiment named ny-taxi-experiment has been created under Experiments section. All the runs and artifacts will be stored under this experiment.\n\n\n# Specify the destination path for saving model files\nmodel_path = \"./outputs/models\"\n\n# Start an MLflow run\nwith mlflow.start_run():\n    # Set a tag for the developer\n    mlflow.set_tag(\"developer\", \"Sagar\")\n\n    # Initialize and train a LinearRegression model\n    lr = LinearRegression()\n    lr.fit(X_train, y_train)\n\n    # Make predictions on the validation data\n    yhat = lr.predict(X_val)\n\n    # Calculate the root mean squared error (RMSE)\n    rmse = mean_squared_error(y_val, yhat, squared=False)\n\n    # Log the RMSE metric to MLflow\n    mlflow.log_metric(\"rmse\", rmse)\n\n    # Create dest_path folder unless it already exists\n    os.makedirs(model_path, exist_ok=True)\n\n    # Save the trained model as a pickle file\n    dump_pickle(lr, os.path.join(model_path, \"lin_reg.pkl\"))\n\n    # Log the trained model as an artifact to MLflow\n    mlflow.log_artifact(local_path=f\"{model_path}/lin_reg.pkl\", artifact_path=\"models_pickle\")\n\nAfter running an experiment run, go to your MLflow UI and there you can see an entry of the run. If you click on the run you have observer other details associated with the run such as Metrics, Tags, Artifacts. In the Artifacts section you can see the model_pickle folder which contains the model file. You can download the model file from there and use it for prediction.\n\n\n\n\n\n\nTip\n\n\n\nIf you don’t see your run on the UI, you can refresh using Refresh button on the right side of the page above the table.\n\n\n\n\nVoila 🎉! You have successfully trained a Linear Regression model and tracked the experiment using MLflow. You can find the complete code.\n\n\nTraing a Lasso Regression Model\n\n# Specify the destination path for saving model files\nmodel_path = \"./outputs/models\"\n\n# Start an MLflow run\nwith mlflow.start_run():\n    # Set a tag for the developer\n    mlflow.set_tag(\"developer\", \"Sagar\")\n\n    # Set the value for the regularization parameter (alpha)\n    alpha = 0.1\n\n    # Log the regularization parameter (alpha) as a parameter in MLflow\n    mlflow.log_param(\"alpha\", alpha)\n\n    # Initialize and train a Lasso Regression model\n    lasso = Lasso(alpha=alpha)\n    lasso.fit(X_train, y_train)\n\n    # Make predictions on the validation data\n    yhat = lasso.predict(X_val)\n\n    # Calculate the root mean squared error (RMSE)\n    rmse = mean_squared_error(y_val, yhat, squared=False)\n\n    # Log the RMSE metric to MLflow\n    mlflow.log_metric(\"rmse\", rmse)\n\n    # Create the destination folder for saving model files if it doesn't exist\n    os.makedirs(model_path, exist_ok=True)\n\n    # Save the trained Lasso Regression model as a pickle file\n    dump_pickle(lr, os.path.join(model_path, \"lasso_reg.pkl\"))\n\n    # Log the trained model as an artifact to MLflow\n    mlflow.log_artifact(local_path=f\"{model_path}/lasso_reg.pkl\", artifact_path=\"models_pickle\")\n\nSimilar to Linear Regression, we can train a Lasso Regression model and track the experiment using MLflow."
  },
  {
    "objectID": "posts/mlops/mlflow.html#hyperparameter-tuning",
    "href": "posts/mlops/mlflow.html#hyperparameter-tuning",
    "title": "Introduction to MLflow",
    "section": "Hyperparameter Tuning",
    "text": "Hyperparameter Tuning\nTools such as MLflow shine when it comes to hyperparameter tuning and model selection. Let’s see how we can leverage MLflow to tune the hyperparameters of our model.\nWe’ll setup a new experiment for hyperparameter tuning and use MLflow to track the results. We’ll use Hyperopt and Optuna libraries for hyperparameter tuning.\n\n# Create a new experiment\nmlflow.set_experiment(\"random-forest-hyperopt\")\n\n\ndef run_optimization(num_trials: int = 10):\n    \"\"\"\n    Runs the optimization process using Optuna library to find the optimal hyperparameters for RandomForestRegressor.\n\n    Parameters:\n        num_trials (int): The number of optimization trials to perform. Default is 10.\n\n    Returns:\n        None\n\n    Notes:\n        - The function defines an objective function for Optuna to minimize the root mean squared error (RMSE).\n        - The objective function samples hyperparameters, trains a RandomForestRegressor model with those hyperparameters,\n          evaluates the model on the validation data, and logs the RMSE metric to MLflow.\n        - Optuna performs the optimization process by searching for the set of hyperparameters that minimizes the RMSE.\n    \"\"\"\n\n    def objective(trial):\n        \"\"\"\n        Objective function for Optuna optimization.\n\n        Parameters:\n            trial (optuna.Trial): A trial object representing a single optimization trial.\n\n        Returns:\n            float: The value of the objective function (RMSE).\n\n        Notes:\n            - The objective function samples hyperparameters from the defined search space.\n            - It initializes and trains a RandomForestRegressor model with the sampled hyperparameters.\n            - The model is evaluated on the validation data, and the RMSE is calculated.\n            - The RMSE and the sampled hyperparameters are logged to MLflow.\n        \"\"\"\n        params = {\n            'n_estimators': trial.suggest_int('n_estimators', 10, 50, 1),\n            'max_depth': trial.suggest_int('max_depth', 1, 20, 1),\n            'min_samples_split': trial.suggest_int('min_samples_split', 2, 10, 1),\n            'min_samples_leaf': trial.suggest_int('min_samples_leaf', 1, 4, 1),\n            'random_state': 42,\n            'n_jobs': -1\n        }\n        \n        # Start a new MLflow run for each trial\n        with mlflow.start_run():\n            # Set a tag for the model type\n            mlflow.set_tag(\"model\", \"RandomForestRegressor\")\n            \n            # Log the sampled hyperparameters to MLflow\n            mlflow.log_params(params)\n\n            # Initialize a RandomForestRegressor model with the sampled hyperparameters\n            rf = RandomForestRegressor(**params)\n\n            # Train the model on the training data\n            rf.fit(X_train, y_train)\n\n            # Make predictions on the validation data\n            y_pred = rf.predict(X_val)\n\n            # Calculate the root mean squared error (RMSE)\n            rmse = mean_squared_error(y_val, y_pred, squared=False)\n\n            # Log the RMSE metric to MLflow\n            mlflow.log_metric(\"rmse\", rmse)\n\n        return rmse\n\n    # Use the Tree-structured Parzen Estimator (TPE) sampler for efficient hyperparameter search\n    sampler = TPESampler(seed=42)\n\n    # Create an Optuna study with the defined objective function and search direction\n    study = optuna.create_study(direction=\"minimize\", sampler=sampler)\n\n    # Run the optimization process with the specified number of trials\n    study.optimize(objective, n_trials=num_trials)\n\nrun_optimization()\n\n[I 2023-05-26 12:23:03,233] A new study created in memory with name: no-name-19f4f970-eafc-402c-89b3-2aa461ab17fc\n[I 2023-05-26 12:23:04,744] Trial 0 finished with value: 6.012747224033297 and parameters: {'n_estimators': 25, 'max_depth': 20, 'min_samples_split': 8, 'min_samples_leaf': 3}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:04,872] Trial 1 finished with value: 6.249433998787504 and parameters: {'n_estimators': 16, 'max_depth': 4, 'min_samples_split': 2, 'min_samples_leaf': 4}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:06,223] Trial 2 finished with value: 6.039045655830305 and parameters: {'n_estimators': 34, 'max_depth': 15, 'min_samples_split': 2, 'min_samples_leaf': 4}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:06,636] Trial 3 finished with value: 6.179387143797025 and parameters: {'n_estimators': 44, 'max_depth': 5, 'min_samples_split': 3, 'min_samples_leaf': 1}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:07,140] Trial 4 finished with value: 6.075505898039151 and parameters: {'n_estimators': 22, 'max_depth': 11, 'min_samples_split': 5, 'min_samples_leaf': 2}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:07,316] Trial 5 finished with value: 6.441117537172997 and parameters: {'n_estimators': 35, 'max_depth': 3, 'min_samples_split': 4, 'min_samples_leaf': 2}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:08,432] Trial 6 finished with value: 6.0285791267371165 and parameters: {'n_estimators': 28, 'max_depth': 16, 'min_samples_split': 3, 'min_samples_leaf': 3}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:08,532] Trial 7 finished with value: 7.881244954282265 and parameters: {'n_estimators': 34, 'max_depth': 1, 'min_samples_split': 7, 'min_samples_leaf': 1}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:09,146] Trial 8 finished with value: 6.025608014492215 and parameters: {'n_estimators': 12, 'max_depth': 19, 'min_samples_split': 10, 'min_samples_leaf': 4}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-26 12:23:09,239] Trial 9 finished with value: 7.071070856187059 and parameters: {'n_estimators': 22, 'max_depth': 2, 'min_samples_split': 8, 'min_samples_leaf': 2}. Best is trial 0 with value: 6.012747224033297.\n\n\nAfter running the experiment, you can see the results in the MLflow UI. You can also select multiple runs and compare them using the Compare button on the top left corner of the table.\n\n\n\nOne of the most interesting plot in the MLflow UI is the Parallel Coordinates Plot. It allows you to visualize the relationship between the hyperparameters and the metrics.\nScatter plot allows you to visualize the relationship between a single hyperparameter and the metric.\nBox Plot are similar to scatter plot in terms of visualization.\nContour Plot allows you to visualize the relationship between two hyperparameters and the metric.\n\nApart from the visualizations, they also provide more information of the Run Duration, Parameters, Metrics and Tags associated with the run in a tabular format to compare the runs."
  },
  {
    "objectID": "posts/mlops/mlflow.html#model-registry",
    "href": "posts/mlops/mlflow.html#model-registry",
    "title": "Introduction to MLflow",
    "section": "Model Registry",
    "text": "Model Registry\nMLflow Model Registry is a centralized model store, set of APIs, and UI, to collaboratively manage the full lifecycle of an MLflow Model. It provides model lineage (which MLflow Experiment and Run produced the model), model versioning, stage transitions (for example from staging to production), annotations, and other functionality to track the model lifecycle.\nFrom our example above for hyperparameter tuning, we can register the best model which performs well on the test dataset.\nTo interact with an MLflow Tracking Server and an MLflow Registry Server, we utilize the Client class. It allows us to create and manage experiments and runs in the Tracking Server, as well as create and manage registered models and model versions in the Registry Server. The mlflow.client module offers a Python interface for performing CRUD operations on MLflow Experiments, Runs, Model Versions, and Registered Models. It serves as a lower-level API that directly corresponds to MLflow’s REST API calls.\nMore information about the MLflow Client can be found here.\n\n# Hyperparameter optimization experiment name\nHPO_EXPERIMENT_NAME = \"random-forest-hyperopt\"\n\n# Best model experiment name\nEXPERIMENT_NAME = \"random-forest-best-models\"\n\n# Create a new experiment for the best models\nmlflow.set_experiment(EXPERIMENT_NAME)\n\n\n# Automatically log parameters and metrics\nmlflow.sklearn.autolog()\n\n\n# RandomForest Parameters\nRF_PARAMS = ['max_depth', 'n_estimators', 'min_samples_split',\n             'min_samples_leaf', 'random_state', 'n_jobs']\n\n\ndef train_and_log_model(params):\n    \"\"\"\n    Trains a RandomForestRegressor model with the given hyperparameters and logs evaluation metrics to MLflow.\n\n    Parameters:\n        params (dict): Dictionary of hyperparameters for RandomForestRegressor.\n\n    Returns:\n        None\n\n    Notes:\n        - The function starts an MLflow run to track the model training and evaluation process.\n        - It converts certain hyperparameters to integers.\n        - A RandomForestRegressor model is initialized with the provided hyperparameters.\n        - The model is trained on the training data.\n        - The trained model is evaluated on the validation and test sets, and the root mean squared error (RMSE) is calculated and logged to MLflow as evaluation metrics.\n    \"\"\"\n\n    with mlflow.start_run():\n        # Convert specific hyperparameters to integers\n        for param in RF_PARAMS:\n            params[param] = int(params[param])\n\n        # Initialize a RandomForestRegressor model with the given hyperparameters\n        rf = RandomForestRegressor(**params)\n\n        # Train the model on the training data\n        rf.fit(X_train, y_train)\n\n        # Evaluate the trained model on the validation set\n        val_rmse = mean_squared_error(y_val, rf.predict(X_val), squared=False)\n\n        # Log the validation RMSE metric to MLflow\n        mlflow.log_metric(\"val_rmse\", val_rmse)\n\n        # Evaluate the trained model on the test set\n        test_rmse = mean_squared_error(y_test, rf.predict(X_test), squared=False)\n\n        # Log the test RMSE metric to MLflow\n        mlflow.log_metric(\"test_rmse\", test_rmse)\n\n\ndef run_register_model(top_n: int):\n    \"\"\"\n    Runs the process to register the best model based on the top_n model runs with the lowest test RMSE.\n\n    Parameters:\n        top_n (int): The number of top model runs to consider.\n\n    Returns:\n        None\n\n    Notes:\n        - The function interacts with the MLflow tracking server to retrieve and register models.\n        - It retrieves the top_n model runs based on the lowest validation RMSE.\n        - For each run, it trains a model using the hyperparameters from the run and logs evaluation metrics to MLflow.\n        - After evaluating the models, it selects the one with the lowest test RMSE.\n        - The selected model is registered with a specified name in MLflow.\n    \"\"\"\n\n    # Connect to the MLflow tracking server\n    client = MlflowClient()\n\n    # Retrieve the top_n model runs and log the models\n    experiment = client.get_experiment_by_name(HPO_EXPERIMENT_NAME)\n\n    # Retrieve the top_n model runs based on the lowest validation RMSE\n    runs = client.search_runs(\n        experiment_ids=experiment.experiment_id,\n        run_view_type=ViewType.ACTIVE_ONLY,\n        max_results=top_n,\n        order_by=[\"metrics.rmse ASC\"]\n    )\n\n    # Train and log the model for each run\n    for run in runs:\n        # Train and log the model based on the hyperparameters from the run\n        train_and_log_model(params=run.data.params)\n\n    # Select the model with the lowest test RMSE\n    experiment = client.get_experiment_by_name(EXPERIMENT_NAME)\n\n    # Retrieve model runs based on the lowest test RMSE, and select the first run (with the lowest test RMSE)\n    best_run = client.search_runs(\n        experiment_ids=experiment.experiment_id,\n        run_view_type=ViewType.ACTIVE_ONLY,\n        order_by=[\"metrics.test_rmse ASC\"]\n    )[0]\n\n    # Register the best model\n    model_uri = f\"runs:/{best_run.info.run_id}/model\"\n\n    # Register the best model with a specified name\n    mlflow.register_model(\n        model_uri=model_uri,\n        name=\"random-forest-best-model\"\n    )\n\n\n# The number of top model runs to consider\ntop_n = 5\n\nrun_register_model(top_n=top_n)\n\n2023/05/26 13:27:30 WARNING mlflow.utils.autologging_utils: MLflow autologging encountered a warning: \"/Users/wizard/Astronaut/Dev/MLOps/week2/venv/lib/python3.9/site-packages/_distutils_hack/__init__.py:33: UserWarning: Setuptools is replacing distutils.\"\nSuccessfully registered model 'random-forest-best-model'.\n2023/05/26 13:27:40 INFO mlflow.tracking._model_registry.client: Waiting up to 300 seconds for model version to finish creation. Model name: random-forest-best-model, version 1\nCreated version '1' of model 'random-forest-best-model'.\n\n\nBy following the mentioned steps, a new experiment called random-forest-best-models will be created, displaying five runs. You may observe that each run provides additional information. This is due to the utilization of MLflow’s autologging feature.\nRead more about autologging here\nAutologging captures more parameters, metrics, and tags, and also saves the model as an artifact along with environment details. This feature proves particularly beneficial when you aim to reproduce the results. You have the option to download the model and environment details, enabling you to replicate the outcomes accurately.\n\nClick on the run with the best model stored and access additional details about the run.\n\nBy clicking on the link to model registry in the above image, you will be redirected to the model registry page.\n\nAnother way to access the model registry is by clicking on the model registry tab on the left side of the MLflow UI. You will be able to see the model registry page with the best model registered.\n\nYou also have an option to change the stage of the model to Staging, Production, or Archived. You can do this by clicking on the stage transition button on the right side of the model name.\nIn the MLflow ecosystem, the responsibility of determining which models are ready for production lies with the Data Scientist. Once a model is registered in the model registry, the Deployment Engineer can review important details such as the model’s parameters, size, and performance. Based on this information, they can make informed decisions on moving the model across different stages.\nIt’s important to note that the model registry itself does not handle the deployment of models. It serves as a centralized repository to list the models that are considered production-ready, with stages acting as labels. To complete the deployment process, it is recommended to complement the model registry with a CI/CD pipeline specifically designed for deploying models. This pipeline would handle the actual deployment process, incorporating the production-ready models identified in the model registry."
  },
  {
    "objectID": "posts/mlops/mlflow.html#mlflow-limitations",
    "href": "posts/mlops/mlflow.html#mlflow-limitations",
    "title": "Introduction to MLflow",
    "section": "MLflow Limitations",
    "text": "MLflow Limitations\nMLflow, while a powerful tool for experiment tracking and model management, has certain limitations to consider.\n\nAuthentication & Users: It lacks built-in authentication and user management capabilities, making it less suitable for environments requiring strict access control.\nData versioning: MLflow does not provide a native solution for data versioning, requiring alternative approaches.\nModel/Data Monitoring & Alerting: Moreover, for model and data monitoring, as well as alerting, other specialized tools may be more appropriate."
  },
  {
    "objectID": "posts/mlops/mlflow.html#alternatives-to-mlflow",
    "href": "posts/mlops/mlflow.html#alternatives-to-mlflow",
    "title": "Introduction to MLflow",
    "section": "Alternatives to MLflow",
    "text": "Alternatives to MLflow\n\nNeptune.ai\nComet\nWeights & Biases\n\nCongratulation 🎉! You have successfully trained ML model and tracked the experiment using MLflow.\nThank you for reading and I hope you found this notebook helpful. Upvote if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/mlops/mlflow_on_aws.html",
    "href": "posts/mlops/mlflow_on_aws.html",
    "title": "MLflow on AWS",
    "section": "",
    "text": "In this blog post we explore how to set up MLflow on AWS, leveraging EC2 to host MLFlow Server, S3 for artifact storage and RDS-PostgreSQL for backend entity storager.\nIf you’re interested in learning about MLflow or need an introduction to its workings, I recommend checking out my previous blog post titled “Introduction to MLflow”."
  },
  {
    "objectID": "posts/mlops/mlflow_on_aws.html#create-aws-ec2-instance",
    "href": "posts/mlops/mlflow_on_aws.html#create-aws-ec2-instance",
    "title": "MLflow on AWS",
    "section": "Create AWS EC2 Instance",
    "text": "Create AWS EC2 Instance\n\nGo to https://aws.amazon.com to Sign in / Create an AWS Account.\nTo launch EC2 instance, click on to services on the left-top corner of the page. Select Compute and EC2.\n\n\n\nTo launch a new instance, click on Launch Instance.\n\n\n\nName our Instance\n\n\n\nKeep the default settings for Application and OS Image, and Instance Type.\nIf you don’t already have a Key pair, you can create a new key pair. You would be asked to download and save your key pair.\n\n\n\n\n\n\n\nTip\n\n\n\nSave your key pair at ~/.ssh/ folder.\n\n\n\n\n\n\nKeep all the other settings as default and click on Launch Instance."
  },
  {
    "objectID": "posts/mlops/mlflow_on_aws.html#configure-security-group",
    "href": "posts/mlops/mlflow_on_aws.html#configure-security-group",
    "title": "MLflow on AWS",
    "section": "Configure Security Group",
    "text": "Configure Security Group\n\nAfter the instance is launched, click on Security Section on the Instance Summary Page.\n\n\n\nClick on Edit Inbound Rules and add a new rule for Custom TCP with port 5000 and source. Save the changes."
  },
  {
    "objectID": "posts/mlops/mlflow_on_aws.html#create-s3-bucket",
    "href": "posts/mlops/mlflow_on_aws.html#create-s3-bucket",
    "title": "MLflow on AWS",
    "section": "Create S3 Bucket",
    "text": "Create S3 Bucket\n\nGo to services on the left-top corner of the page. Select Storage and S3. Click on Create Bucket.\n\n\n\nName your bucket and select the region. Keep all the other settings as default and click on Create Bucket.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nPlease make note of the bucket name for later use."
  },
  {
    "objectID": "posts/mlops/mlflow_on_aws.html#create-rds-database",
    "href": "posts/mlops/mlflow_on_aws.html#create-rds-database",
    "title": "MLflow on AWS",
    "section": "Create RDS Database",
    "text": "Create RDS Database\n\nGo to services on the left-top corner of the page. Select Database and RDS. Click on Create Database.\n\n\n\nChoose Standard create and select PostgreSQL as the engine.\nSelect Free tier in the Templates section.\nIn the Settings section, name your database i.e., DB Instance Identifier (eg. mlflow-database). In the Credentials section, enter a username (eg. mlflow) and Tick the Auto generate a password checkbox.\nIn the Additional configuration section, Set the Initial database name (eg. mlflow_db) under the Database options.\n\n\n\n\n\n\n\nImportant\n\n\n\nPlease make note of the username and the database name for later use.\n\n\n\nKeep all the other settings as default and click on Create Database.\nThe database would take a few minutes to be created. To check the password, click on View credential details.\n\n\n\n\n\n\n\nWarning\n\n\n\nYou would need the password save the password for later use. This is the only time you would be able to view the password. However, you can always reset the password.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nAfter the database is created, please save the endpoint and port for later use. You can find the endpoint and port on the database summary page. Marked in the image below with a green dotted box.\n\n\n\nNext, you would need to add an inbound rule to the security group of the database. To do so, click on the Security section on the database summary page. Click on Edit Inbound Rules and add a new rule for PostgreSQL with port 5432 and source. Save the changes. This allows the EC2 instance to connect to the database.\n\n\n\nSelect the security group that was created automatically when we launched the EC2 instance."
  },
  {
    "objectID": "posts/mlops/mlflow_on_aws.html#install-mlflow",
    "href": "posts/mlops/mlflow_on_aws.html#install-mlflow",
    "title": "MLflow on AWS",
    "section": "Install MLflow",
    "text": "Install MLflow\n\nWe’ll utilize the easiest way to connect to the EC2 instance. Click on the Connect button on the EC2 instance summary page. In the EC2 Instance Connect section, click on Connect.\n\n\n\nThis would open a terminal window in the browser.\n\nRun the following commands to install MLflow.\n\nsudo yum update\n\npip3 install mlflow boto3 psycopg2-binary\n\n\n\n\n\n\nNote\n\n\n\nIf you get an error saying No module named pip, run the following command to install pip.\npython3 -m ensurepip --upgrade\n\n\n\nNext, we need to set up the MLflow Tracking Server. To do so, run the following command.\n\nmlflow server -h 0.0.0.0 -p 5000 --backend-store-uri postgresql://DB_USER:DB_PASSWORD@DB_ENDPOINT:PORT/DB_NAME --default-artifact-root s3://S3_BUCKET_NAME\n\n# Example, Replace the following values\nmlflow server -h 0.0.0.0 -p 5000 --backend-store-uri postgresql://mlflow:WJgpP1lv4PQVnhzdq7T5@mlflow-database.c4rrlovvb5cx.us-east-1.rds.amazonaws.com:5432/mlflow_db --default-artifact-root s3://mlflow-artifact-remote-storage\n\n\n\n\n\n\nNote\n\n\n\nWe made note of the ENDPOINT and PORT which can be replaced for DB_ENDPOINT and PORT respectively. We also saved the PASSWORD when creating the RDS-Postgresql database which can be replaced for DB_PASSWORD respectively.\nSimilarly, we made note of the USERNAME and DATABASE_NAME which can be replaced for DB_USER and DB_NAME respectively. We also made note of the BUCKET_NAME which can be replaced for S3_BUCKET_NAME.\n\n\n\nTo checkout the MLflow UI, open a new tab in the browser and enter the following URL.\n\nhttp://EC2_INSTANCE_PUBLIC_IPv4_ADDRESS:5000\n\n# Example, Replace the following values\nhttp://52.91.235.206:5000/\n\nVoila! You have successfully set up MLflow on AWS EC2 instance."
  },
  {
    "objectID": "posts/mlops/mlflow_on_aws.html#setup-aws-cli-and-profile-on-local",
    "href": "posts/mlops/mlflow_on_aws.html#setup-aws-cli-and-profile-on-local",
    "title": "MLflow on AWS",
    "section": "Setup AWS CLI and Profile on local",
    "text": "Setup AWS CLI and Profile on local\n\nInstall AWS CLI on your local machine. You can follow the instructions here.\nGo to IAM on AWS Console and click on Policies on the left panel. Click on Create Policy.\n\n\n\nSearch for S3 and click on s3.\n\n\n\nSelect all the access level for List, and Read. Select all the marked options for Write.\n\n\n\n\nMark all the checkboxes in the Resources section. Click on Next.\n\n\n\nGive the name for the Policy and click on Create Policy.\n\n\n\nGo to IAM and click on UsersGroup on the left panel. Click on Create group. Give a name for the group and select the policy that was created in the previous step. Click on Create group.\n\n\n\nGo to IAM and click on Users on the left panel. Click on Add user. Give a name for the user and click on Next.\n\n\n\n\nSelect Add user to group Permission option and select the group that was created in the previous step. Click on Next. Review the details and click on Create user.\n\n\n\nGo to Users again and click on the user that was created in the previous step. Click on Security credentials tab. Click on Create access key.\n\n\n\nClick on Other and click on Next Button. Then Click on Create Access Key.\nClick on Download .csv file and save the file. This file contains the Access Key ID and Secret Access Key which would be used to configure the AWS CLI.\nOpen the terminal and run the following command.\n\naws configure\n\nEnter the Access Key ID and Secret Access Key that was saved in the previous step. For other options like Default region name and Default output format, keep the default values by pressing enter.\nYou can check if the AWS CLI is configured correctly by running the following command.\n\naws s3 ls\nYou should be able to see the list of buckets that are present in your AWS account."
  },
  {
    "objectID": "posts/mlops/mlflow_on_aws.html#mlflow-in-action",
    "href": "posts/mlops/mlflow_on_aws.html#mlflow-in-action",
    "title": "MLflow on AWS",
    "section": "MLflow in Action",
    "text": "MLflow in Action\nI’ll refer to the Introduction to MLflow post for this section. I’ll be using the same code and data for this section.\n\nSetup\nCreate a new virtual environment and install MLflow and other libraries using the following command:\n\n\nrequirements.txt\n\nmlflow\njupyter\nscikit-learn\npandas\nxgboost\nfastparquet\nhyperopt\noptuna\n\n# Create conda environment\nconda create -p venv python=3.9 -y\n\n# Activate conda environment\nconda activate venv/\n\n# Install required libraries\npip install -r requirements.txt --no-cache-dir\nDownload the dataset using the following command:\n# Create data directory\nmkdir data\n\n# Move to data directory\ncd data\n\n# Download dataset\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-01.parquet # January 2022\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-02.parquet # February 2022\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-03.parquet # March 2022\nWe’ll also create a jupyter notebook named mlflow.ipynb to run our experiment. After following the above steps, you should have the following directory structure:\n.\n├── data\n│   ├── green_tripdata_2022-01.parquet\n│   ├── green_tripdata_2022-02.parquet\n│   └── green_tripdata_2022-03.parquet\n├── mlflow.ipynb\n├── requirements.txt\n└── venv\nThe below hidden code block imports the required libraries, loads & transforms the dataset, and splits the dataset into train, validation, and test sets.\n\n\nShow the code\nimport os\nimport numpy as np\nimport pandas as pd\nimport pickle\nimport mlflow\nimport optuna\n\nfrom mlflow.entities import ViewType\nfrom mlflow.tracking import MlflowClient\nfrom optuna.samplers import TPESampler\nfrom sklearn.feature_extraction import DictVectorizer\nfrom sklearn.linear_model import LinearRegression, Lasso\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_squared_error\n\ndef read_dataframe(filename: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a Parquet file into a pandas DataFrame, performs data transformations, and returns the resulting DataFrame.\n\n    Parameters:\n        filename (str): The path to the Parquet file to be read.\n\n    Returns:\n        pandas.DataFrame: The processed DataFrame containing the data from the Parquet file.\n\n    Raises:\n        [Any exceptions raised by pandas.read_parquet()]\n\n    Notes:\n        - The function performs the following transformations on the DataFrame:\n            - Converts 'lpep_dropoff_datetime' and 'lpep_pickup_datetime' columns to pandas datetime objects.\n            - Computes the 'duration' column by subtracting 'lpep_pickup_datetime' from 'lpep_dropoff_datetime'\n              and converting the result to minutes.\n            - Filters the DataFrame to include rows where the 'duration' is between 1 and 60 minutes (inclusive).\n            - Converts 'PULocationID' and 'DOLocationID' columns to string type.\n\n    Example:\n        filename = 'data.parquet'\n        df = read_dataframe(filename)\n    \"\"\"\n    # Read the Parquet file into a DataFrame\n    df = pd.read_parquet(filename)\n\n    # Convert 'lpep_dropoff_datetime' and 'lpep_pickup_datetime' columns to pandas datetime objects\n    df.lpep_dropoff_datetime = pd.to_datetime(df.lpep_dropoff_datetime)\n    df.lpep_pickup_datetime = pd.to_datetime(df.lpep_pickup_datetime)\n\n    # Compute the 'duration' column by subtracting 'lpep_pickup_datetime' from 'lpep_dropoff_datetime' and converting to minutes\n    df['duration'] = df.lpep_dropoff_datetime - df.lpep_pickup_datetime\n    df.duration = df.duration.apply(lambda td: td.total_seconds() / 60)\n\n    # Filter the DataFrame to include rows where the 'duration' is between 1 and 60 minutes (inclusive)\n    df = df[(df.duration >= 1) & (df.duration <= 60)]\n\n    # Convert 'PULocationID' and 'DOLocationID' columns to string type\n    categorical = ['PULocationID', 'DOLocationID']\n    df[categorical] = df[categorical].astype(str)\n    \n    # Return the processed DataFrame\n    return df\n\n# Read the Parquet file for training data into a DataFrame\ndf_train = read_dataframe('./data/green_tripdata_2022-01.parquet')\n\n# Read the Parquet file for validation data into a DataFrame\ndf_val = read_dataframe('./data/green_tripdata_2022-02.parquet')\n\n# Read the Parquet file for testing data into a DataFrame\ndf_test = read_dataframe('./data/green_tripdata_2022-03.parquet')\n\ndef preprocess(df: pd.DataFrame, dv: DictVectorizer, fit_dv: bool = False):\n    \"\"\"\n    Preprocesses a pandas DataFrame by creating new features, transforming categorical features into a numerical format,\n    and returning the transformed data along with the DictVectorizer.\n\n    Parameters:\n        df (pandas.DataFrame): The input DataFrame to be preprocessed.\n        dv (sklearn.feature_extraction.DictVectorizer): The DictVectorizer instance to be used for transforming categorical features.\n        fit_dv (bool, optional): Indicates whether to fit the DictVectorizer on the data. Defaults to False.\n\n    Returns:\n        tuple: A tuple containing the transformed feature matrix and the DictVectorizer instance.\n\n    Notes:\n        - The function assumes that the DataFrame contains the columns 'PULocationID' and 'DOLocationID'.\n        - The function creates a new feature 'PU_DO' by concatenating 'PULocationID' and 'DOLocationID'.\n        - The categorical feature 'PU_DO' and numerical feature 'trip_distance' are selected for transformation.\n        - The function transforms the selected features into a dictionary representation and applies the DictVectorizer.\n        - If fit_dv is True, the DictVectorizer is fitted on the data. Otherwise, the existing fitted DictVectorizer is used.\n\n    Example:\n        df = read_dataframe('data.parquet')\n        dv = DictVectorizer()\n        X, dv = preprocess(df, dv, fit_dv=True)\n    \"\"\"\n    # Create a new feature 'PU_DO' by concatenating 'PULocationID' and 'DOLocationID'\n    df['PU_DO'] = df['PULocationID'] + '_' + df['DOLocationID']\n\n    # Select categorical and numerical features for transformation\n    categorical = ['PU_DO']\n    numerical = ['trip_distance']\n\n    # Convert the selected features into a dictionary representation\n    dicts = df[categorical + numerical].to_dict(orient='records')\n\n    # Apply DictVectorizer for transforming categorical features\n    if fit_dv:\n        # Fit the DictVectorizer on the data\n        X = dv.fit_transform(dicts)\n    else:\n        # Transform using the existing fitted DictVectorizer\n        X = dv.transform(dicts)\n\n    # Return the transformed feature matrix and DictVectorizer\n    return X, dv\n\n# Extract the target variable\ntarget = 'duration'\n\n# Extract the target variable from the training, validation and testing datasets\ny_train = df_train[target].values\ny_val = df_val[target].values\ny_test = df_test[target].values\n\n# Initialize a DictVectorizer for preprocessing\ndv = DictVectorizer()\n\n# Preprocess the training data\nX_train, dv = preprocess(df_train, dv, fit_dv=True)\n\n# Preprocess the validation data using the fitted DictVectorizer from the training data\nX_val, _ = preprocess(df_val, dv, fit_dv=False)\n\n# Preprocess the testing data using the fitted DictVectorizer from the training data\nX_test, _ = preprocess(df_test, dv, fit_dv=False)\n\ndef dump_pickle(obj, filename: str):\n    \"\"\"\n    Pickles (serializes) an object and saves it to a file.\n\n    Parameters:\n        obj (Any): The object to be pickled.\n        filename (str): The path and filename to save the pickled object.\n\n    Returns:\n        None\n\n    Notes:\n        - The function uses the 'pickle' module to serialize the object and save it to a file.\n        - The file is opened in binary mode for writing using the \"wb\" mode.\n    \"\"\"\n    with open(filename, \"wb\") as f_out:\n        return pickle.dump(obj, f_out)\n\n\nSet up the MLflow Tracking Server URI.\n\nTRACKING_SERVER_HOST = \"52.91.235.206\" # fill in with the public IPv4 of the EC2 instance\nmlflow.set_tracking_uri(f\"http://{TRACKING_SERVER_HOST}:5000\")\n\n\nprint(f\"tracking URI: '{mlflow.get_tracking_uri()}'\")\n\ntracking URI: 'http://52.91.235.206:5000'\n\n\n\n# Create a new experiment\nmlflow.set_experiment(\"nyc-taxi-experiment\")\n\n2023/05/31 11:43:55 INFO mlflow.tracking.fluent: Experiment with name 'nyc-taxi-experiment' does not exist. Creating a new experiment.\n\n\n<Experiment: artifact_location='s3://mlflow-artifact-remote-storage/1', creation_time=1685547835140, experiment_id='1', last_update_time=1685547835140, lifecycle_stage='active', name='nyc-taxi-experiment', tags={}>\n\n\n\n\nTrain Model\nTrain a simple Linear Regression model and log the model parameters, metrics, and artifacts.\n\n# Specify the destination path for saving model files\nmodel_path = \"./outputs/models\"\n\n# Start an MLflow run\nwith mlflow.start_run():\n    # Set a tag for the developer\n    mlflow.set_tag(\"developer\", \"Sagar\")\n\n    # Initialize and train a LinearRegression model\n    lr = LinearRegression()\n    lr.fit(X_train, y_train)\n\n    # Make predictions on the validation data\n    yhat = lr.predict(X_val)\n\n    # Calculate the root mean squared error (RMSE)\n    rmse = mean_squared_error(y_val, yhat, squared=False)\n\n    # Log the RMSE metric to MLflow\n    mlflow.log_metric(\"rmse\", rmse)\n\n    # Create dest_path folder unless it already exists\n    os.makedirs(model_path, exist_ok=True)\n\n    # Save the trained model as a pickle file\n    dump_pickle(lr, os.path.join(model_path, \"lin_reg.pkl\"))\n\n    # Log the trained model as an artifact to MLflow\n    mlflow.log_artifact(local_path=f\"{model_path}/lin_reg.pkl\", artifact_path=\"model\")\n\nBelow you can see the MLflow UI with the experiment run.\n\n\nYou can also see that the artifacts are stored in S3 bucket.\n\n\n\nHyperparameter Tuning\nNext, we’ll create a new experiment to perform hyperparameter tuning using Hyperopt and Optuna.\n\n# Create a new experiment\nmlflow.set_experiment(\"random-forest-hyperopt\")\n\n<Experiment: artifact_location='s3://mlflow-artifact-remote-storage/3', creation_time=1685548270366, experiment_id='3', last_update_time=1685548270366, lifecycle_stage='active', name='random-forest-hyperopt', tags={}>\n\n\n\ndef run_optimization(num_trials: int = 10):\n    \"\"\"\n    Runs the optimization process using Optuna library to find the optimal hyperparameters for RandomForestRegressor.\n\n    Parameters:\n        num_trials (int): The number of optimization trials to perform. Default is 10.\n\n    Returns:\n        None\n\n    Notes:\n        - The function defines an objective function for Optuna to minimize the root mean squared error (RMSE).\n        - The objective function samples hyperparameters, trains a RandomForestRegressor model with those hyperparameters,\n          evaluates the model on the validation data, and logs the RMSE metric to MLflow.\n        - Optuna performs the optimization process by searching for the set of hyperparameters that minimizes the RMSE.\n    \"\"\"\n\n    def objective(trial):\n        \"\"\"\n        Objective function for Optuna optimization.\n\n        Parameters:\n            trial (optuna.Trial): A trial object representing a single optimization trial.\n\n        Returns:\n            float: The value of the objective function (RMSE).\n\n        Notes:\n            - The objective function samples hyperparameters from the defined search space.\n            - It initializes and trains a RandomForestRegressor model with the sampled hyperparameters.\n            - The model is evaluated on the validation data, and the RMSE is calculated.\n            - The RMSE and the sampled hyperparameters are logged to MLflow.\n        \"\"\"\n        params = {\n            'n_estimators': trial.suggest_int('n_estimators', 10, 50, 1),\n            'max_depth': trial.suggest_int('max_depth', 1, 20, 1),\n            'min_samples_split': trial.suggest_int('min_samples_split', 2, 10, 1),\n            'min_samples_leaf': trial.suggest_int('min_samples_leaf', 1, 4, 1),\n            'random_state': 42,\n            'n_jobs': -1\n        }\n        \n        # Start a new MLflow run for each trial\n        with mlflow.start_run():\n            # Set a tag for the model type\n            mlflow.set_tag(\"model\", \"RandomForestRegressor\")\n            \n            # Log the sampled hyperparameters to MLflow\n            mlflow.log_params(params)\n\n            # Initialize a RandomForestRegressor model with the sampled hyperparameters\n            rf = RandomForestRegressor(**params)\n\n            # Train the model on the training data\n            rf.fit(X_train, y_train)\n\n            # Make predictions on the validation data\n            y_pred = rf.predict(X_val)\n\n            # Calculate the root mean squared error (RMSE)\n            rmse = mean_squared_error(y_val, y_pred, squared=False)\n\n            # Log the RMSE metric to MLflow\n            mlflow.log_metric(\"rmse\", rmse)\n\n        return rmse\n\n    # Use the Tree-structured Parzen Estimator (TPE) sampler for efficient hyperparameter search\n    sampler = TPESampler(seed=42)\n\n    # Create an Optuna study with the defined objective function and search direction\n    study = optuna.create_study(direction=\"minimize\", sampler=sampler)\n\n    # Run the optimization process with the specified number of trials\n    study.optimize(objective, n_trials=num_trials)\n\nrun_optimization()\n\n[I 2023-05-31 11:57:34,678] A new study created in memory with name: no-name-41ada3cf-dabd-4100-a384-dd6a2ee09103\n[I 2023-05-31 11:57:38,080] Trial 0 finished with value: 6.012747224033297 and parameters: {'n_estimators': 25, 'max_depth': 20, 'min_samples_split': 8, 'min_samples_leaf': 3}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:38,649] Trial 1 finished with value: 6.249433998787504 and parameters: {'n_estimators': 16, 'max_depth': 4, 'min_samples_split': 2, 'min_samples_leaf': 4}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:42,149] Trial 2 finished with value: 6.039045655830305 and parameters: {'n_estimators': 34, 'max_depth': 15, 'min_samples_split': 2, 'min_samples_leaf': 4}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:43,620] Trial 3 finished with value: 6.179387143797027 and parameters: {'n_estimators': 44, 'max_depth': 5, 'min_samples_split': 3, 'min_samples_leaf': 1}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:45,445] Trial 4 finished with value: 6.075505898039151 and parameters: {'n_estimators': 22, 'max_depth': 11, 'min_samples_split': 5, 'min_samples_leaf': 2}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:46,134] Trial 5 finished with value: 6.441117537172997 and parameters: {'n_estimators': 35, 'max_depth': 3, 'min_samples_split': 4, 'min_samples_leaf': 2}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:49,416] Trial 6 finished with value: 6.0285791267371165 and parameters: {'n_estimators': 28, 'max_depth': 16, 'min_samples_split': 3, 'min_samples_leaf': 3}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:49,958] Trial 7 finished with value: 7.881244954282265 and parameters: {'n_estimators': 34, 'max_depth': 1, 'min_samples_split': 7, 'min_samples_leaf': 1}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:51,295] Trial 8 finished with value: 6.025608014492215 and parameters: {'n_estimators': 12, 'max_depth': 19, 'min_samples_split': 10, 'min_samples_leaf': 4}. Best is trial 0 with value: 6.012747224033297.\n[I 2023-05-31 11:57:51,848] Trial 9 finished with value: 7.071070856187059 and parameters: {'n_estimators': 22, 'max_depth': 2, 'min_samples_split': 8, 'min_samples_leaf': 2}. Best is trial 0 with value: 6.012747224033297.\n\n\n\n\n\nModel Registry\nFinally, we’ll take the top 5 models from the hyperparameter tuning experiment and run them on the test dataset. We’ll log the metrics and artifacts for each model. We’ll register the model with the best metrics to the model registry.\n\n# Hyperparameter optimization experiment name\nHPO_EXPERIMENT_NAME = \"random-forest-hyperopt\"\n\n# Best model experiment name\nEXPERIMENT_NAME = \"random-forest-best-models\"\n\n# Create a new experiment for the best models\nmlflow.set_experiment(EXPERIMENT_NAME)\n\n<Experiment: artifact_location='s3://mlflow-artifact-remote-storage/2', creation_time=1685548138856, experiment_id='2', last_update_time=1685548138856, lifecycle_stage='active', name='random-forest-best-models', tags={}>\n\n\n\n# Automatically log parameters and metrics\nmlflow.sklearn.autolog()\n\n\n# RandomForest Parameters\nRF_PARAMS = ['max_depth', 'n_estimators', 'min_samples_split',\n             'min_samples_leaf', 'random_state', 'n_jobs']\n\n\ndef train_and_log_model(params):\n    \"\"\"\n    Trains a RandomForestRegressor model with the given hyperparameters and logs evaluation metrics to MLflow.\n\n    Parameters:\n        params (dict): Dictionary of hyperparameters for RandomForestRegressor.\n\n    Returns:\n        None\n\n    Notes:\n        - The function starts an MLflow run to track the model training and evaluation process.\n        - It converts certain hyperparameters to integers.\n        - A RandomForestRegressor model is initialized with the provided hyperparameters.\n        - The model is trained on the training data.\n        - The trained model is evaluated on the validation and test sets, and the root mean squared error (RMSE) is calculated and logged to MLflow as evaluation metrics.\n    \"\"\"\n\n    with mlflow.start_run():\n        # Convert specific hyperparameters to integers\n        for param in RF_PARAMS:\n            params[param] = int(params[param])\n\n        # Initialize a RandomForestRegressor model with the given hyperparameters\n        rf = RandomForestRegressor(**params)\n\n        # Train the model on the training data\n        rf.fit(X_train, y_train)\n\n        # Evaluate the trained model on the validation set\n        val_rmse = mean_squared_error(y_val, rf.predict(X_val), squared=False)\n\n        # Log the validation RMSE metric to MLflow\n        mlflow.log_metric(\"val_rmse\", val_rmse)\n\n        # Evaluate the trained model on the test set\n        test_rmse = mean_squared_error(y_test, rf.predict(X_test), squared=False)\n\n        # Log the test RMSE metric to MLflow\n        mlflow.log_metric(\"test_rmse\", test_rmse)\n\ndef run_register_model(top_n: int):\n    \"\"\"\n    Runs the process to register the best model based on the top_n model runs with the lowest test RMSE.\n\n    Parameters:\n        top_n (int): The number of top model runs to consider.\n\n    Returns:\n        None\n\n    Notes:\n        - The function interacts with the MLflow tracking server to retrieve and register models.\n        - It retrieves the top_n model runs based on the lowest validation RMSE.\n        - For each run, it trains a model using the hyperparameters from the run and logs evaluation metrics to MLflow.\n        - After evaluating the models, it selects the one with the lowest test RMSE.\n        - The selected model is registered with a specified name in MLflow.\n    \"\"\"\n\n    # Connect to the MLflow tracking server\n    client = MlflowClient()\n\n    # Retrieve the top_n model runs and log the models\n    experiment = client.get_experiment_by_name(HPO_EXPERIMENT_NAME)\n\n    # Retrieve the top_n model runs based on the lowest validation RMSE\n    runs = client.search_runs(\n        experiment_ids=experiment.experiment_id,\n        run_view_type=ViewType.ACTIVE_ONLY,\n        max_results=top_n,\n        order_by=[\"metrics.rmse ASC\"]\n    )\n\n    # Train and log the model for each run\n    for run in runs:\n        # Train and log the model based on the hyperparameters from the run\n        train_and_log_model(params=run.data.params)\n\n    # Select the model with the lowest test RMSE\n    experiment = client.get_experiment_by_name(EXPERIMENT_NAME)\n\n    # Retrieve model runs based on the lowest test RMSE, and select the first run (with the lowest test RMSE)\n    best_run = client.search_runs(\n        experiment_ids=experiment.experiment_id,\n        run_view_type=ViewType.ACTIVE_ONLY,\n        order_by=[\"metrics.test_rmse ASC\"]\n    )[0]\n\n    # Register the best model\n    model_uri = f\"runs:/{best_run.info.run_id}/model\"\n\n    # Register the best model with a specified name\n    mlflow.register_model(\n        model_uri=model_uri,\n        name=\"random-forest-best-model\"\n    )\n\n\n# The number of top model runs to consider\ntop_n = 5\n\nrun_register_model(top_n=top_n)\n\n2023/05/31 11:58:21 WARNING mlflow.utils.autologging_utils: MLflow autologging encountered a warning: \"/Users/wizard/Astronaut/Dev/MLOps/week2/venv/lib/python3.9/site-packages/_distutils_hack/__init__.py:33: UserWarning: Setuptools is replacing distutils.\"\nSuccessfully registered model 'random-forest-best-model'.\n2023/05/31 11:58:49 INFO mlflow.tracking._model_registry.client: Waiting up to 300 seconds for model version to finish creation. Model name: random-forest-best-model, version 1\nCreated version '1' of model 'random-forest-best-model'.\n\n\n\nCongratulations! 🎉 You have successfully set up MLflow on AWS EC2 instance and used it to track your machine learning experiments.\n\n\n\n\n\n\nSTOP EC2 instance\n\n\n\nPlease remember to stop the EC2 instance after completing your work to avoid incurring any additional charges.\n\n\nThank you for reading and I hope you found this post helpful. Upvote if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/mlops/prefect-blocks.html",
    "href": "posts/mlops/prefect-blocks.html",
    "title": "Prefect Blocks",
    "section": "",
    "text": "In this post, we’ll be building up on the concepts we discussed in the previous post. If you haven’t read that, I highly recommend checking it out before you continue reading this. You can find the post here.\nIn the previous post, we build a simple prefect flow that downloads a file from a URL and saves it to a local directory. We used MLflow to track our experiment - train a XGBoost model on the downloaded data. In this post, we’ll be implementing the same workflow but this time we’ll fetch the data from S3 instead of downloading it from a URL.\nWe’ll setup the S3 bucket and also create a new IAM user and attach the AmazonS3FullAccess policy to it. We’ll use the Access key and Secret key to access the S3 bucket from our code."
  },
  {
    "objectID": "posts/mlops/prefect-blocks.html#setup-s3-bucket",
    "href": "posts/mlops/prefect-blocks.html#setup-s3-bucket",
    "title": "Prefect Blocks",
    "section": "Setup S3 Bucket",
    "text": "Setup S3 Bucket\n\nLog into your AWS account and click on Services on the top left corner. Search for S3 and click on it.\nClick on Create bucket and give it a name. Note: Bucket names must be unique across all AWS accounts.\nKeep the default settings and click on Create bucket."
  },
  {
    "objectID": "posts/mlops/prefect-blocks.html#upload-the-data-to-the-s3-bucket",
    "href": "posts/mlops/prefect-blocks.html#upload-the-data-to-the-s3-bucket",
    "title": "Prefect Blocks",
    "section": "Upload the data to the S3 bucket",
    "text": "Upload the data to the S3 bucket\nDownload the data on your local machine and upload it to the S3 bucket. To keep it simple we’ll use the GUI to upload the data to the S3 bucket. Use the following command in your terminal / command prompt to download the data.\n# Download dataset\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-01.parquet # January 2022\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-02.parquet # February 2022\nwget https://d37ci6vzurychx.cloudfront.net/trip-data/green_tripdata_2022-03.parquet # March 2022\nNow, let’s upload the data to the S3 bucket. Follow the steps below to upload the data to the S3 bucket.\n\nClick on the bucket you just created.\nCreate a new folder by clicking on Create folder and give it a name data.\nClick on Upload and select the file you want to upload.\nClick on Upload again and wait for the upload to complete.\n\nAwesome! We now have the data in the S3 bucket."
  },
  {
    "objectID": "posts/mlops/prefect-blocks.html#create-iam-user",
    "href": "posts/mlops/prefect-blocks.html#create-iam-user",
    "title": "Prefect Blocks",
    "section": "Create IAM user",
    "text": "Create IAM user\nWe’ll now create a new IAM user and attach the AmazonS3FullAccess policy to it. We’ll use the Access key and Secret key to access the S3 bucket from our code. Follow the steps below to create a new IAM user.\n\nClick on Services on the top left corner. Search for IAM and click on it.\nClick on Users on the left sidebar and then click on Add user.\nGive the user a name and click on Next.\nIt is recommended to use groups to manage user’s permissions. Click on Create group and give it a name. Search for AmazonS3FullAccess in the Permissions policies table and select it. Click on Create user group.\nNow, select the group you just created and click on Next.\nClick on Create User.\n\n\nGenerate Access key and Secret key\n\nClick on the user you just created.\nClick on Security credentials tab and under the Access keys section click on Create access key.\nSelect the Other option and click on Next and then click on Create access key.\nClick on Show to view the Access key and Secret key. Note: You won’t be able to view the Secret key again so make sure you save it somewhere safe. Alternatively, you can also download the CSV file using the Download .csv file button.\n\nWe’re all setup now. Let’s get started with Prefect Blocks."
  },
  {
    "objectID": "posts/mlops/prefect-blocks.html#prefect-blocks",
    "href": "posts/mlops/prefect-blocks.html#prefect-blocks",
    "title": "Prefect Blocks",
    "section": "Prefect Blocks",
    "text": "Prefect Blocks\nBlocks serve as a fundamental element in Prefect, allowing the storage of configuration information and providing an interface for seamless interaction with external systems.\nBlocks offer a secure way to store authentication credentials for various services such as AWS, GitHub, Slack, and more, enabling seamless integration with Prefect.\nBy utilizing blocks, you gain access to convenient methods that facilitate interactions with external systems. For instance, you can effortlessly download or upload data from/to an S3 bucket, query or write data in a database, or send messages to Slack channels.\nConfiguring blocks can be done either programmatically or through the user-friendly interfaces of Prefect Cloud and the Prefect server UI. This flexibility allows you to manage blocks based on your preferred approach.\nYou can find blocks on the Prefect UI under the Blocks section. Click on Add Block to see the different blocks available.\n\n\n\n\n\n\n\nNote\n\n\n\nDon’t worry if you don’t see the different blocks in your UI. We’ll be adding them in the next section. You can skip this section if you find S3 Bucket and AWS Credentials Blocks in the UI.\n\n\n\nAdding blocks to Prefect UI\n\n\n\n\n\n\nNote\n\n\n\nWe’ll be using the same environment we created in the previous post. If you haven’t created the environment, you can find the instructions here.\n\n\nTo see the different blocks Prefect has to offer you can find them here. Prefect also allows you to create your own custom blocks. You can find the documentation here.\nFor this post, we’ll be using the AWS integration prefect-aws to use the following blocks:\n\nS3Bucket\nAwsCredentials\n\nTo use these blocks you can pip install the package, then register the blocks you want to use with Prefect Cloud or a Prefect server. Follow the steps below:\n\nInstall the prefect_aws package in your environment.\n\npip install prefect_aws\n\nRegister the blocks using the prefect register command. -m flag is used to specify the module name.\n\nprefect block register -m prefect_aws\nNow you should be able to see the blocks in the Prefect UI.\n\n\nCreate S3 Bucket block\nWe’ll now create a new file create_s3_bucket.py to store the credentials and the S3 bucket configurations. We’ll be using the AwsCredentials and S3Bucket blocks to create the S3 bucket.\n\n\ncreate_s3_bucket.py\n\nfrom time import sleep\nfrom prefect_aws import S3Bucket, AwsCredentials\n\n# Create and save AWS credentials block\ndef create_aws_creds_block():\n    # Create AWS credentials object\n    my_aws_creds_obj = AwsCredentials(\n        aws_access_key_id = \"<ACCESS_KEY>\", # Replace with your access key\n        aws_secret_access_key = \"<SECRET_KEY>\" # Replace with your secret key\n    )\n    \n    # Save the AWS credentials block\n    my_aws_creds_obj.save(name=\"my-aws-creds\", overwrite=True)\n\n# Create and save S3 bucket block\ndef create_s3_bucket_block():\n    # Load AWS credentials block\n    aws_creds = AwsCredentials.load(\"my-aws-creds\")\n    \n    # Create S3 bucket object\n    my_s3_bucket_obj = S3Bucket(\n        bucket_name = \"<BUCKET_NAME>\", # Replace with your bucket name\n        credentials = aws_creds\n    )\n    \n    # Save the S3 bucket block\n    my_s3_bucket_obj.save(name=\"s3-bucket-example\", overwrite=True)\n\n\nif __name__ == \"__main__\":\n    # Create and save AWS credentials block\n    create_aws_creds_block()\n    \n    # Sleep for 5 seconds to allow time for the AWS credentials to be saved\n    sleep(5)\n    \n    # Create and save S3 bucket block\n    create_s3_bucket_block()\n\nLet’s understand what’s happening in the code above.\n\nWe first create an AwsCredentials object and pass the Access key and Secret key to it. We then save the object as a block using the save method. We also pass the overwrite argument as True to overwrite the block if it already exists. (Note: Use the Access key and Secret key you created in the previous section)\nWe then create an S3Bucket object and pass the bucket name and the AwsCredentials object to it. We then save the object as a block using the save method. We also pass the overwrite argument as True to overwrite the block if it already exists.\n\nThis allows to store the credentials and configurations in a secure way, and use them in our workflows.\nprefect block ls command can be used to list all the blocks. However, since we haven’t registered the above below in Prefect, we won’t be able to see them.\nWe’ll run the script to create and save the blocks in Prefect. Before running the script, make sure you start the prefect server.\n# Make sure to start the prefect server before running the script\nprefect server start\n\n# Run the script (In new terminal window)\npython create_s3_bucket.py\nIf you run the command prefect block ls you should be able to see the blocks. Similarly if you go to the Prefect UI you should be able to see the blocks under the Blocks section.\n\n\nNow that we have the blocks setup, we can use them in our workflow."
  },
  {
    "objectID": "posts/mlops/prefect-blocks.html#workflow",
    "href": "posts/mlops/prefect-blocks.html#workflow",
    "title": "Prefect Blocks",
    "section": "Workflow",
    "text": "Workflow\nWe’ll be using the same workflow we created in the previous post with some modifications. We’ll be using the S3Bucket block to download the data from the S3 bucket.\nWe import the S3Bucket Block using the command from prefect_aws import S3Bucket.\n\n\norchestration_s3.py\n\nimport os\nimport pickle\nimport pathlib\nimport scipy\nimport mlflow\nimport sklearn\nimport argparse\nimport pandas as pd\nimport numpy as np\nimport xgboost as xgb\nfrom sklearn.feature_extraction import DictVectorizer\nfrom sklearn.metrics import mean_squared_error\nfrom prefect import flow, task\nfrom prefect_aws import S3Bucket\n\n@task(name=\"Read a Parquet file\")\ndef read_data(filename: str) -> pd.DataFrame:\n    \"\"\"Read data into DataFrame\"\"\"\n    df = pd.read_parquet(filename)\n\n    df.lpep_dropoff_datetime = pd.to_datetime(df.lpep_dropoff_datetime)\n    df.lpep_pickup_datetime = pd.to_datetime(df.lpep_pickup_datetime)\n\n    df[\"duration\"] = df.lpep_dropoff_datetime - df.lpep_pickup_datetime\n    df.duration = df.duration.apply(lambda td: td.total_seconds() / 60)\n\n    df = df[(df.duration >= 1) & (df.duration <= 60)]\n\n    categorical = [\"PULocationID\", \"DOLocationID\"]\n    df[categorical] = df[categorical].astype(str)\n\n    return df\n\n@task(name=\"Add Features\")\ndef add_features(df_train: pd.DataFrame, df_val: pd.DataFrame) -> tuple([\n        scipy.sparse._csr.csr_matrix,\n        scipy.sparse._csr.csr_matrix,\n        np.ndarray,\n        np.ndarray,\n        sklearn.feature_extraction.DictVectorizer,\n    ]):\n    \"\"\"Add features to the model\"\"\"\n    df_train[\"PU_DO\"] = df_train[\"PULocationID\"] + \"_\" + df_train[\"DOLocationID\"]\n    df_val[\"PU_DO\"] = df_val[\"PULocationID\"] + \"_\" + df_val[\"DOLocationID\"]\n\n    categorical = [\"PU_DO\"]  #'PULocationID', 'DOLocationID']\n    numerical = [\"trip_distance\"]\n\n    dv = DictVectorizer()\n\n    train_dicts = df_train[categorical + numerical].to_dict(orient=\"records\")\n    X_train = dv.fit_transform(train_dicts)\n\n    val_dicts = df_val[categorical + numerical].to_dict(orient=\"records\")\n    X_val = dv.transform(val_dicts)\n\n    y_train = df_train[\"duration\"].values\n    y_val = df_val[\"duration\"].values\n    return X_train, X_val, y_train, y_val, dv\n\n@task(name=\"Train Model\", log_prints=True)\ndef train_best_model(\n    X_train: scipy.sparse._csr.csr_matrix,\n    X_val: scipy.sparse._csr.csr_matrix,\n    y_train: np.ndarray,\n    y_val: np.ndarray,\n    dv: sklearn.feature_extraction.DictVectorizer,\n) -> None:\n    \"\"\"train a model with best hyperparams and write everything out\"\"\"\n\n    with mlflow.start_run():\n        train = xgb.DMatrix(X_train, label=y_train)\n        valid = xgb.DMatrix(X_val, label=y_val)\n\n        best_params = {\n            \"learning_rate\": 0.09585355369315604,\n            \"max_depth\": 30,\n            \"min_child_weight\": 1.060597050922164,\n            \"objective\": \"reg:linear\",\n            \"reg_alpha\": 0.018060244040060163,\n            \"reg_lambda\": 0.011658731377413597,\n            \"seed\": 42,\n        }\n\n        mlflow.log_params(best_params)\n\n        booster = xgb.train(\n            params=best_params,\n            dtrain=train,\n            num_boost_round=100,\n            evals=[(valid, \"validation\")],\n            early_stopping_rounds=20,\n        )\n\n        y_pred = booster.predict(valid)\n        rmse = mean_squared_error(y_val, y_pred, squared=False)\n        mlflow.log_metric(\"rmse\", rmse)\n\n        pathlib.Path(\"models\").mkdir(exist_ok=True)\n        with open(\"models/preprocessor.b\", \"wb\") as f_out:\n            pickle.dump(dv, f_out)\n        mlflow.log_artifact(\"models/preprocessor.b\", artifact_path=\"preprocessor\")\n\n        mlflow.xgboost.log_model(booster, artifact_path=\"models_mlflow\")\n    return None\n\n@flow(name=\"Main Flow\")\ndef main_flow():\n    \"\"\"Main flow of the program\"\"\"\n    \n    # MLflow settings\n    mlflow.set_tracking_uri(\"sqlite:///mlflow.db\")\n    mlflow.set_experiment(\"nyc-taxi-experiment\")\n\n    # Load\n    s3_bucket_block = S3Bucket.load(\"s3-bucket-example\")\n    s3_bucket_block.download_folder_to_path(from_folder=\"data\", to_folder=\"data\")\n\n    df_train = read_data(\"./data/green_tripdata_2021-01.parquet\")\n    df_val = read_data(\"./data/green_tripdata_2021-02.parquet\")\n\n    # Transform\n    X_train, X_val, y_train, y_val, dv = add_features(df_train, df_val)\n\n    # Train\n    train_best_model(X_train, X_val, y_train, y_val, dv)\n\nif __name__ == \"__main__\":\n    main_flow()\n\nTo keep the workflow simple, we have removed the fetch and download_and_read (Subflow) functions. We have also made some changes to how the main_flow is called. The main change is that we are using the S3Bucket block to download the data from the S3 bucket.\nTo better understand the above script you can read my previous post here.\n# Loads the configuration of the S3 Bucket from the S3Bucket Block\ns3_bucket_block = S3Bucket.load(\"s3-bucket-block\")\n\n# Downloads the data from the S3 bucket folder name \"data\" to the local folder \"data\"\ns3_bucket_block.download_folder_to_path(from_folder=\"data\", to_folder=\"data\")\nRun the above script using the command python orchestration_s3.py"
  },
  {
    "objectID": "posts/mlops/prefect-blocks.html#conclusion",
    "href": "posts/mlops/prefect-blocks.html#conclusion",
    "title": "Prefect Blocks",
    "section": "Conclusion",
    "text": "Conclusion\nPrefect Blocks are a great way to reuse code and configurations, and to share them with your team. They also help secure your credentials and other sensitive information. In this tutorial, we have seen how to create a Prefect Block for the S3 Bucket. We have also seen how to use the S3 Bucket Block in a Prefect Flow.\nThank you for reading and I hope you found this notebook helpful. Upvote if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/mlops/intro_workflow_orchestration.html",
    "href": "posts/mlops/intro_workflow_orchestration.html",
    "title": "Prefect: An Workflow Orchestration Tool",
    "section": "",
    "text": "Prefect is an open-source workflow orchestration tool that helps you automate and manage the flow of work across your data stack.\nPrefect is built on Python and uses a modular architecture that makes it easy to build and deploy complex workflows. Prefect also includes a rich set of features for monitoring, debugging, and managing your workflows.\nBefore we dive into Prefect, let’s first understand what is workflow orchestration, why do we need it, and where does Prefect come into play."
  },
  {
    "objectID": "posts/mlops/intro_workflow_orchestration.html#what-is-workflow-orchestration",
    "href": "posts/mlops/intro_workflow_orchestration.html#what-is-workflow-orchestration",
    "title": "Prefect: An Workflow Orchestration Tool",
    "section": "What is Workflow Orchestration?",
    "text": "What is Workflow Orchestration?\nBuilding a ML system has a lot of moving parts. We have to deal with data collection, data preprocessing, model training, model serving, etc. Each of these steps can be further broken down into sub-steps. For example, data preprocessing can be broken down into feature engineering, feature selection, etc.\nWorkflow Orchestration is the process of automating and managing the flow of work across these steps. It helps us build complex workflows by combining multiple steps together. It also helps us manage the dependencies between these steps."
  },
  {
    "objectID": "posts/mlops/intro_workflow_orchestration.html#negative-engineering",
    "href": "posts/mlops/intro_workflow_orchestration.html#negative-engineering",
    "title": "Prefect: An Workflow Orchestration Tool",
    "section": "Negative Engineering",
    "text": "Negative Engineering\nInspite of building a robust system, there are chances that something might go wrong. For example, the data might not be available, the model might fail to train, etc.\n\nOften time while developing any application, we find ourselves spending a lot of time fixing bugs and making sure that everything works as expected. We spend time writing code to handle edge cases and make sure that our application is robust enough to handle any unexpected situation. Exmaples of such situations are:\n\nWriting Retries logic when APIs go down\nBuild Notifications for when a job fails\nRecord logs for observability and debugging\nWrite conditional logic to handle edge cases\nHandle cases when requests timeouts or fails\n\nNegative Engineering refers to ideology that we spend most of our time writing code to handle edge cases rather than writing code that actually solves the problem. This is where Workflow Orchestration comes into play.\nWorflow Orchestration tools provide set of features off the shelf that aim to eliminate the need for negative engineering. These tools provide features like retries, notifications, logging, lineage tracking, etc. out of the box."
  },
  {
    "objectID": "posts/mlops/intro_workflow_orchestration.html#prefect",
    "href": "posts/mlops/intro_workflow_orchestration.html#prefect",
    "title": "Prefect: An Workflow Orchestration Tool",
    "section": "Prefect",
    "text": "Prefect\nPrefect aims to eliminate the need for negative engineering by providing a rich set of features out of the box.\n\nSetup\nIt is a good practice to create a virtual environment for each project. This helps us keep our dependencies separate and avoid any version conflicts.\n\n\nrequirements.txt\n\nfastparquet==2023.4.0\nmlflow==2.3.1\npandas==2.0.1\nprefect==2.10.8\nscikit_learn==1.2.2\nxgboost==1.7.5\npsycopg2-binary==2.9.5\n\nLet’s create a virtual environment named venv and install all the dependencies.\n# Create a virtual environment\nconda create -p venv python=3.10 -y\n\n# Activate the virtual environment\nconda activate venv/\n\n# Install all the dependencies\npip install -r requirements.txt --no-cache-dir\n\n\nPrefect Flow\nWe will be using the NYC Taxi Dataset for this tutorial. The dataset contains information about green taxi trips in New York City. The dataset is available in parquet format.\nSteps that we’ll cover:\n\nWe’ll download the dataset from the NY Taxi website and load it into a pandas dataframe.\nPreprocess the data.\nTrain a model on the preprocessed data.\nLog the model and the metrics to MLflow.\n\nYou’ll wonder where do we use Prefect in this? Answer is in each step.\nWe’ll go through each step in detail. At the end you’ll find the complete code for the workflow.\n\n\nImport Libraries\nimport os\nimport pickle\nimport pathlib\nimport scipy\nimport mlflow\nimport sklearn\nimport argparse\nimport pandas as pd\nimport numpy as np\nimport xgboost as xgb\nfrom sklearn.feature_extraction import DictVectorizer\nfrom sklearn.metrics import mean_squared_error\nfrom prefect import flow, task\nfrom prefect.tasks import task_input_hash\nfrom datetime import timedelta\n\n\nTwo most important building blocks in Prefect are Task and Flow. We’ll start by importing these two. More on these later.\nfrom prefect import task, flow\n\n\nDownload the dataset\nWe have created a python function named fetch what will download the data from the NY Taxi website and save it to the data directory.\n@task(name=\"Fetch Data\", log_prints=True, retries=3, cache_key_fn=task_input_hash, cache_expiration=timedelta(days=1))\ndef fetch(year: int, month: int, color: str) -> None:\n    \"\"\"Fetches data from the NYC Taxi dataset and saves it locally\"\"\"\n\n    # Download the data from the NYC Taxi dataset\n\n    url = f\"https://d37ci6vzurychx.cloudfront.net/trip-data/{color}_tripdata_{year}-{month:0>2}.parquet\"\n    file_name = f\"{color}_tripdata_{year}-{month:0>2}.parquet\"\n\n    pathlib.Path(\"data\").mkdir(exist_ok=True)\n\n    os.system(f\"wget {url} -O ./data/{file_name}\")\nLet’s understand what is happening here.\nThe function is defined in the same way as any other python function. The only difference is that we have added a decorator @task to the function. This decorator converts the python function into a Prefect Task. The decorator takes a few arguments:\n\n@task is a decorator that converts a python function into a Prefect Task.\nname is the name of the task. This is used to identify the task in the Prefect UI.\nlog_prints is a boolean flag that tells Prefect to log the output of the task.\nretries is the number of times the task should be retried in case of failure.\ncache_key_fn is a function that returns a unique key for the task. This is used to cache the output of the task.\ncache_expiration is the time after which the cache should expire.\n\n\n\n\n\n\n\nTerminology Alert: Task\n\n\n\nA task is a unit of work that needs to be done. It can be anything from downloading a file to training a model. Prefect provides a decorator @task that converts a python function into a Prefect Task.\nImagine you are preparing a sandwich. To prepare a delicious sandwich you need to perform a few tasks like: get the bread, apply butter, add cheese, cut down the veggies, etc. Each of these tasks is a unit of work that needs to be done to prepare the sandwich. In Prefect, each of these tasks can be represented as a Prefect Task.\n\n\n\n\n\n\n\n\nNote\n\n\n\nTo enable caching we specified a cache_key_fn which is a function that returns a cache key on our task. We cachec our task based on its input by using task_input_hash which is a function that returns a unique hash for the input of the task.\nIt hashes all inputs to the task and returns a unique hash. If the task inputs do not change, the hash will remain the same and the cachec results are used instead of running the task again until cache expires.\nWe also specified a cache_expiration of 1 day. This means that the cache will expire after 1 day.\n\n\nThis is a good practice while working with large datasets. It helps us avoid downloading the same dataset again and again.\nNext up, we have function named read_data that takes a filename and load the data into a pandas dataframe.\n@task(name=\"Read a Parquet file\")\ndef read_data(filename: str) -> pd.DataFrame:\n    \"\"\"Read data into DataFrame\"\"\"\n    df = pd.read_parquet(filename)\n\n    df.lpep_dropoff_datetime = pd.to_datetime(df.lpep_dropoff_datetime)\n    df.lpep_pickup_datetime = pd.to_datetime(df.lpep_pickup_datetime)\n\n    df[\"duration\"] = df.lpep_dropoff_datetime - df.lpep_pickup_datetime\n    df.duration = df.duration.apply(lambda td: td.total_seconds() / 60)\n\n    df = df[(df.duration >= 1) & (df.duration <= 60)]\n\n    categorical = [\"PULocationID\", \"DOLocationID\"]\n    df[categorical] = df[categorical].astype(str)\n\n    return df\nThis function is also decorated with @task decorator. Nothing new here.\n\n\nPreprocess the data\nNow that we have the data, we need to preprocess it before we can train a model on it. We’ll create a function named add_features that combines PULocationID and DOLocationID. Also, we’ll represent our features using the DictVectorizer. We’ll perform these steps for both training and validation data.\nAgain, we’ll decorate the function with @task decorator.\n@task(name=\"Add Features\")\ndef add_features(df_train: pd.DataFrame, df_val: pd.DataFrame) -> tuple([\n        scipy.sparse._csr.csr_matrix,\n        scipy.sparse._csr.csr_matrix,\n        np.ndarray,\n        np.ndarray,\n        sklearn.feature_extraction.DictVectorizer,\n    ]):\n    \"\"\"Add features to the model\"\"\"\n    df_train[\"PU_DO\"] = df_train[\"PULocationID\"] + \"_\" + df_train[\"DOLocationID\"]\n    df_val[\"PU_DO\"] = df_val[\"PULocationID\"] + \"_\" + df_val[\"DOLocationID\"]\n\n    categorical = [\"PU_DO\"]  #['PULocationID', 'DOLocationID']\n    numerical = [\"trip_distance\"]\n\n    dv = DictVectorizer()\n\n    train_dicts = df_train[categorical + numerical].to_dict(orient=\"records\")\n    X_train = dv.fit_transform(train_dicts)\n\n    val_dicts = df_val[categorical + numerical].to_dict(orient=\"records\")\n    X_val = dv.transform(val_dicts)\n\n    y_train = df_train[\"duration\"].values\n    y_val = df_val[\"duration\"].values\n    return X_train, X_val, y_train, y_val, dv\n\n\nTrain the model\nWe have an XGBoost model that we want to train. We’ll create a function named train_best_model that takes the training and validation data along with the DictVectorizer and trains the model. We’ll use the best hyperparameters that we found seperately.\nOne awesome thing you’ll observe is that we are also using mlflow to log the model and the hyperparameters. This is a great way to track the model performance and the hyperparameters that were used to train the model.\nDue to the log_prints flag, Prefect will log the output of the task including the output logs from mlflow. This is a great way to visualize the logs in the Prefect UI.\n@task(name=\"Train Model\", log_prints=True)\ndef train_best_model(\n    X_train: scipy.sparse._csr.csr_matrix,\n    X_val: scipy.sparse._csr.csr_matrix,\n    y_train: np.ndarray,\n    y_val: np.ndarray,\n    dv: sklearn.feature_extraction.DictVectorizer,\n) -> None:\n    \"\"\"train a model with best hyperparams and write everything out\"\"\"\n\n    with mlflow.start_run():\n        train = xgb.DMatrix(X_train, label=y_train)\n        valid = xgb.DMatrix(X_val, label=y_val)\n\n        best_params = {\n            \"learning_rate\": 0.09585355369315604,\n            \"max_depth\": 30,\n            \"min_child_weight\": 1.060597050922164,\n            \"objective\": \"reg:linear\",\n            \"reg_alpha\": 0.018060244040060163,\n            \"reg_lambda\": 0.011658731377413597,\n            \"seed\": 42,\n        }\n\n        mlflow.log_params(best_params)\n\n        booster = xgb.train(\n            params=best_params,\n            dtrain=train,\n            num_boost_round=100,\n            evals=[(valid, \"validation\")],\n            early_stopping_rounds=20,\n        )\n\n        y_pred = booster.predict(valid)\n        rmse = mean_squared_error(y_val, y_pred, squared=False)\n        mlflow.log_metric(\"rmse\", rmse)\n\n        pathlib.Path(\"models\").mkdir(exist_ok=True)\n        with open(\"models/preprocessor.b\", \"wb\") as f_out:\n            pickle.dump(dv, f_out)\n        mlflow.log_artifact(\"models/preprocessor.b\", artifact_path=\"preprocessor\")\n\n        mlflow.xgboost.log_model(booster, artifact_path=\"models_mlflow\")\n    return None\nNow, we have our indenpendent tasks ready. Let’s create a flow that will run these tasks in the order we want.\n\n\nCreate a flow\nWe’ll create a flow named main_flow that will run the tasks in the order we want. We’ll also set the name of the flow to “Main Flow”. This is a great way to identify the flow in the Prefect UI.\nObserve that yet again the flow is simply a function decorated with @flow decorator. We’ll also set the params argument to the flow. These paramarater also get recorded in the Prefect UI which can be very useful to track the flow runs.\n\n\n\n\n\n\nTerminology Alert: Flow\n\n\n\nA flow is a collection of tasks that are executed in a particular order. A flow is a function decorated with @flow decorator. The flow function can take arguments and return values.\nImagine flow is a container that holds all the tasks and the order in which they are executed. Making a delicious sandwich is a flow and the actions you take to make the sandwich are the tasks.\n\n\n@flow(name=\"Main Flow\")\ndef main_flow(params):\n    \"\"\"Main flow of the program\"\"\"\n    \n    # MLflow settings\n    mlflow.set_tracking_uri(\"sqlite:///mlflow.db\")\n    mlflow.set_experiment(\"nyc-taxi-experiment\")\n\n    # Download and read data\n    df_train, df_val = download_and_read(params.years, params.months, params.color)\n\n    # Transform\n    X_train, X_val, y_train, y_val, dv = add_features(df_train, df_val)\n\n    # Train\n    train_best_model(X_train, X_val, y_train, y_val, dv)\nIf you observe closely, you’ll notice that we have a download_and_read function but we didn’t define that anywhere to avoid confusion until now. We’ll define that function next but that function will be a Subflow in our main flow.\n\n\nCreate a subflow\nImage a subflow as a flow within a flow. A subflow is a function decorated with the same @flow decorator but it is called from within another flow. A subflow can also take arguments and return values.\nWe’ll create a subflow named download_and_read that will call the previously defined functions (tasks) to download the data and read it into a pandas dataframe. We’ll also set the name of the subflow to “Download and Read”. This is a great way to identify the subflow in the Prefect UI.\n@flow(name=\"Subflow - Download and Read Data\", log_prints=True)\ndef download_and_read(years: list, months: list, color: str):\n    # Download the data from the NYC Taxi dataset\n    for year in years:\n        for month in months:\n            print(f\"Download: Year-Month: {year}-{month} ({color})\")\n            fetch(year, month, color)\n\n    # Read the data into a DataFrame\n    track_data =[[], []]\n    df_train = pd.DataFrame()\n    for month in months[:-1]:\n        print(f\"Read: Year-Month: {year}-{month:0>2} ({color})\")\n        df = read_data(f\"./data/{color}_tripdata_{year}-{month:0>2}.parquet\")\n        df_train = pd.concat([df_train, df], ignore_index=True)\n        track_data[0].append(month)\n\n    print(f\"Read: Year-Month: {year}-{months[-1]:0>2} ({color})\")\n    df_val = read_data(f\"./data/{color}_tripdata_{year}-{months[-1]:0>2}.parquet\")\n    track_data[1].append(months[-1])\n\n    print(f\"Training data consists of months: {track_data[0]}\")\n    print(f\"Validation data consists of months: {track_data[1]}\")\n\n    return df_train, df_val\n\n\n\n\n\n\nTerminology Alert: Subflow\n\n\n\nA subflow is a flow within a flow. A subflow is a function decorated with @flow decorator. The subflow function can take arguments and return values.\nImagine you want to make a spicy sauce to have with your sandwich. To make a sauce you need to follow a recipe with multiple steps. Consider this as a subflow within the flow of making a sandwich.\n\n\n\n\nRun the flow\nWe’ll run the script by calling the main_flow with the necessary arguments.\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Ingest CSV data to Postgres')\n\n    parser.add_argument(\"--years\", nargs=\"+\", required=True, help=\"Data from year\")\n    parser.add_argument(\"--months\", nargs=\"+\", required=True, help=\"Data from months\")\n    parser.add_argument(\"--color\", required=True, help=\"Taxi color\", default=\"green\")\n\n    args = parser.parse_args()\n\n    main_flow(args)\nExample, to run the flow for the months of January, February and March of 2021 for green taxis, we’ll run the following command:\npython orchestration.py --years 2021 --months 1 2 3 --color green\nIllustration of the flow of execution of the tasks in the flow.\nmain_flow                       (Flow)\n    |\n    |---- download_and_read     (Subflow)\n    |           |\n    |           |---- fetch     (Task)\n    |           |---- read_data (Task)\n    |---- add_features          (Task)\n    |---- train_best_model      (Task)\n\nThis will run the flow and log all the tasks in the Prefect UI.\nBelow you’ll find some screenshots of the Prefect UI, sample output on terminal, and MLflow UI.\nSample output on terminal:\n\nPrefect UI:\nYou can start the Prefect server using the command prefect server start and then navigate to http://127.0.0.1:4200 to view the Prefect UI.\n\nYou’ll find both the main flow and the subflow on the page as it records all the flows that are run. You can click on the flow to view the details of the flow. Main flow:\n\nSubflow:\n\nLastly you’ll find your experiment in the MLflow UI:\nRun the mlflow UI using the command mlflow server --backend-store-uri sqlite:///mlflow.db --host 0.0.0.0 --port 8080 and then navigate to http://127.0.0.1:8080 to view the MLflow UI. Note: MLflow runs on port 5000 by default but we are running it on port 8080.\n\nCongratulations on running your first Prefect flow! 🎉\nYou can find the whole code below:\n\n\norchestration.py\n\nimport os\nimport pickle\nimport pathlib\nimport scipy\nimport mlflow\nimport sklearn\nimport argparse\nimport pandas as pd\nimport numpy as np\nimport xgboost as xgb\nfrom sklearn.feature_extraction import DictVectorizer\nfrom sklearn.metrics import mean_squared_error\nfrom prefect import flow, task\nfrom prefect.tasks import task_input_hash\nfrom datetime import timedelta\n\n@task(name=\"Fetch Data\", log_prints=True, retries=3, cache_key_fn=task_input_hash, cache_expiration=timedelta(days=1))\ndef fetch(year: int, month: int, color: str) -> None:\n    \"\"\"Fetches data from the NYC Taxi dataset and saves it locally\"\"\"\n\n    # Download the data from the NYC Taxi dataset\n\n    url = f\"https://d37ci6vzurychx.cloudfront.net/trip-data/{color}_tripdata_{year}-{month:0>2}.parquet\"\n    file_name = f\"{color}_tripdata_{year}-{month:0>2}.parquet\"\n\n    pathlib.Path(\"data\").mkdir(exist_ok=True)\n\n    os.system(f\"wget {url} -O ./data/{file_name}\")\n\n@task(name=\"Read a Parquet file\")\ndef read_data(filename: str) -> pd.DataFrame:\n    \"\"\"Read data into DataFrame\"\"\"\n    df = pd.read_parquet(filename)\n\n    df.lpep_dropoff_datetime = pd.to_datetime(df.lpep_dropoff_datetime)\n    df.lpep_pickup_datetime = pd.to_datetime(df.lpep_pickup_datetime)\n\n    df[\"duration\"] = df.lpep_dropoff_datetime - df.lpep_pickup_datetime\n    df.duration = df.duration.apply(lambda td: td.total_seconds() / 60)\n\n    df = df[(df.duration >= 1) & (df.duration <= 60)]\n\n    categorical = [\"PULocationID\", \"DOLocationID\"]\n    df[categorical] = df[categorical].astype(str)\n\n    return df\n\n@task(name=\"Add Features\")\ndef add_features(df_train: pd.DataFrame, df_val: pd.DataFrame) -> tuple([\n        scipy.sparse._csr.csr_matrix,\n        scipy.sparse._csr.csr_matrix,\n        np.ndarray,\n        np.ndarray,\n        sklearn.feature_extraction.DictVectorizer,\n    ]):\n    \"\"\"Add features to the model\"\"\"\n    df_train[\"PU_DO\"] = df_train[\"PULocationID\"] + \"_\" + df_train[\"DOLocationID\"]\n    df_val[\"PU_DO\"] = df_val[\"PULocationID\"] + \"_\" + df_val[\"DOLocationID\"]\n\n    categorical = [\"PU_DO\"]  #'PULocationID', 'DOLocationID']\n    numerical = [\"trip_distance\"]\n\n    dv = DictVectorizer()\n\n    train_dicts = df_train[categorical + numerical].to_dict(orient=\"records\")\n    X_train = dv.fit_transform(train_dicts)\n\n    val_dicts = df_val[categorical + numerical].to_dict(orient=\"records\")\n    X_val = dv.transform(val_dicts)\n\n    y_train = df_train[\"duration\"].values\n    y_val = df_val[\"duration\"].values\n    return X_train, X_val, y_train, y_val, dv\n\n\n@flow(name=\"Subflow - Download and Read Data\", log_prints=True)\ndef download_and_read(years: list, months: list, color: str):\n    # Download the data from the NYC Taxi dataset\n    for year in years:\n        for month in months:\n            print(f\"Download: Year-Month: {year}-{month} ({color})\")\n            fetch(year, month, color)\n\n    # Read the data into a DataFrame\n    track_data =[[], []]\n    df_train = pd.DataFrame()\n    for month in months[:-1]:\n        print(f\"Read: Year-Month: {year}-{month:0>2} ({color})\")\n        df = read_data(f\"./data/{color}_tripdata_{year}-{month:0>2}.parquet\")\n        df_train = pd.concat([df_train, df], ignore_index=True)\n        track_data[0].append(month)\n\n    print(f\"Read: Year-Month: {year}-{months[-1]:0>2} ({color})\")\n    df_val = read_data(f\"./data/{color}_tripdata_{year}-{months[-1]:0>2}.parquet\")\n    track_data[1].append(months[-1])\n\n    print(f\"Training data consists of months: {track_data[0]}\")\n    print(f\"Validation data consists of months: {track_data[1]}\")\n\n    return df_train, df_val\n\n@task(name=\"Train Model\", log_prints=True)\ndef train_best_model(\n    X_train: scipy.sparse._csr.csr_matrix,\n    X_val: scipy.sparse._csr.csr_matrix,\n    y_train: np.ndarray,\n    y_val: np.ndarray,\n    dv: sklearn.feature_extraction.DictVectorizer,\n) -> None:\n    \"\"\"train a model with best hyperparams and write everything out\"\"\"\n\n    with mlflow.start_run():\n        train = xgb.DMatrix(X_train, label=y_train)\n        valid = xgb.DMatrix(X_val, label=y_val)\n\n        best_params = {\n            \"learning_rate\": 0.09585355369315604,\n            \"max_depth\": 30,\n            \"min_child_weight\": 1.060597050922164,\n            \"objective\": \"reg:linear\",\n            \"reg_alpha\": 0.018060244040060163,\n            \"reg_lambda\": 0.011658731377413597,\n            \"seed\": 42,\n        }\n\n        mlflow.log_params(best_params)\n\n        booster = xgb.train(\n            params=best_params,\n            dtrain=train,\n            num_boost_round=100,\n            evals=[(valid, \"validation\")],\n            early_stopping_rounds=20,\n        )\n\n        y_pred = booster.predict(valid)\n        rmse = mean_squared_error(y_val, y_pred, squared=False)\n        mlflow.log_metric(\"rmse\", rmse)\n\n        pathlib.Path(\"models\").mkdir(exist_ok=True)\n        with open(\"models/preprocessor.b\", \"wb\") as f_out:\n            pickle.dump(dv, f_out)\n        mlflow.log_artifact(\"models/preprocessor.b\", artifact_path=\"preprocessor\")\n\n        mlflow.xgboost.log_model(booster, artifact_path=\"models_mlflow\")\n    return None\n\n@flow(name=\"Main Flow\")\ndef main_flow(params):\n    \"\"\"Main flow of the program\"\"\"\n    \n    # MLflow settings\n    mlflow.set_tracking_uri(\"sqlite:///mlflow.db\")\n    mlflow.set_experiment(\"nyc-taxi-experiment\")\n\n    # Download and read data\n    df_train, df_val = download_and_read(params.years, params.months, params.color)\n\n    # Transform\n    X_train, X_val, y_train, y_val, dv = add_features(df_train, df_val)\n\n    # Train\n    train_best_model(X_train, X_val, y_train, y_val, dv)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Ingest CSV data to Postgres')\n\n    parser.add_argument(\"--years\", nargs=\"+\", required=True, help=\"Data from year\")\n    parser.add_argument(\"--months\", nargs=\"+\", required=True, help=\"Data from months\")\n    parser.add_argument(\"--color\", required=True, help=\"Taxi color\", default=\"green\")\n\n    args = parser.parse_args()\n\n    main_flow(args)"
  },
  {
    "objectID": "posts/mlops/intro_workflow_orchestration.html#further-reading",
    "href": "posts/mlops/intro_workflow_orchestration.html#further-reading",
    "title": "Prefect: An Workflow Orchestration Tool",
    "section": "Further Reading",
    "text": "Further Reading\n\nPrefect Flows\nPrefect Tasks\nPrefect Tutorials\n\nIn the next post, we will see what are prefect blocks and how to use them to build a more complex flow. Also, how to deploy our flows to Prefect Cloud and run them on a schedule.\nThank you for reading and I hope you found this notebook helpful. Upvote if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/ml/machine-learning-expert-path.html",
    "href": "posts/ml/machine-learning-expert-path.html",
    "title": "Path to become a Machine Learning Expert",
    "section": "",
    "text": "Path to becoming a Machine Learning (ML) Expert made easy. There are a lot of resources out there that can be overwhelming at the start. But don’t worry this learning path would provide structure and lay the foundational knowledge to begin a career in ML."
  },
  {
    "objectID": "posts/ml/machine-learning-expert-path.html#learn-the-basics-of-descriptive-statistics-inferential-statistics-and-math-used-in-machine-learning",
    "href": "posts/ml/machine-learning-expert-path.html#learn-the-basics-of-descriptive-statistics-inferential-statistics-and-math-used-in-machine-learning",
    "title": "Path to become a Machine Learning Expert",
    "section": "1. Learn the basics of Descriptive Statistics, Inferential Statistics and Math used in Machine Learning",
    "text": "1. Learn the basics of Descriptive Statistics, Inferential Statistics and Math used in Machine Learning\nUnderstanding the math used in ML can help in building the foundation strong. Udacity offers courses on descriptive statistics and inferential statistics. These courses are free and use excel to teach the concepts.\nAlong with statistics and probabilities, concepts on linear algebra, multivariate calculus, optimization functions and many more form the building blocks for ML. There is an awesome youtube channel that makes these concepts very easy to learn. 3Brown1Blue focuses on teaching mathematics using a distinct visual perspective.\nMore resources:\n\nComputational Linear Algebra for Coders\nProf. Gilbert Strang’s Linear Algebra book/course\nMatrix Cookbook by Kaare Brandt Petersen & Michael Syskind Pedersen\nThink Stats (Exploratory Data Analysis in Python) by Allen Downey\nConvex Optimization by Stephen Boyd and Lieven Vandenberghe\nEssentials of Metaheuristics by Sean Luke"
  },
  {
    "objectID": "posts/ml/machine-learning-expert-path.html#learn-the-basics-of-python-and-its-packages",
    "href": "posts/ml/machine-learning-expert-path.html#learn-the-basics-of-python-and-its-packages",
    "title": "Path to become a Machine Learning Expert",
    "section": "2. Learn the basics of Python and it’s packages",
    "text": "2. Learn the basics of Python and it’s packages\nFirst, let’s install Python. The easiest way to do this is by installing Anaconda. All the packages that are required come along with Anaconda.\nYou can start from learning the basics of Python i.e. data structures, functions, class, etc. and it’s libraries. I started learning about python in my college days, I read the book Learn Python the Hard Way. A very good book for beginners. Introduction to Python Programming by Udacity is a free course that covers the basics of Python. Introduction to Python is another free course by Analytics Vidhya. Another free course by Google is Google’s Python Class.\nNext, learn about how to use Regular Expression (also called regex) in Python. It will come in use for data cleaning, especially if you are working with text data. Learn regular expressions through Google class. A very good beginner tutorial for learning regular expression in python on Analytics Vidhya. Cheatsheet for Regex.\nNow comes the fun part of learning the various libraries in Python. Numpy, Pandas, Matplotlib, Seaborn, and Sklearn are the packages heavily used in ML.\n\nNumpy provides a high-performance multidimensional array and basic tools to compute with and manipulate these arrays. Numpy quickstart tutorial is a good place to start. This will form a good foundation for this to come. Practice numpy by solving 100 numpy exercises to solve.\nPandas is used for data manipulation and analysis. The most used package in Python is Pandas. Intro to pandas data structure provides a detailed tutorial on pandas. A short course by Kaggle on pandas.\nMatplotlib is a visualization library in python. In the matplotlib tutorial, you will learn the basics of Python data visualization, the anatomy of a Matplotlib plot, and much more. Official documentation of matplotlib is one of the best ways to learn the library.\nSeaborn is another visualization library built on top of matplotlib. Kaggle short course on data visualization provides a good start point to learn the library."
  },
  {
    "objectID": "posts/ml/machine-learning-expert-path.html#data-explorationcleaningpreparation",
    "href": "posts/ml/machine-learning-expert-path.html#data-explorationcleaningpreparation",
    "title": "Path to become a Machine Learning Expert",
    "section": "3. Data Exploration/Cleaning/Preparation",
    "text": "3. Data Exploration/Cleaning/Preparation\nReal-world data is unstructured, contains missing values, outliers, typos, etc. This step is one of the most important steps for a data analyst to perform because how good the model will perform will depend on the quality of the data.\nLearn different stages of data explorations:\n\nVariable Identification, Univariate and Multivariate analysis\nMissing values treatment\nOutlier treatment\nFeature Engineering\n\nAdditional resources:\n\nYou can also refer to the data exploration guide.\nBook on Python for Data Analysis by Wes McKinney"
  },
  {
    "objectID": "posts/ml/machine-learning-expert-path.html#introduction-to-machine-learning",
    "href": "posts/ml/machine-learning-expert-path.html#introduction-to-machine-learning",
    "title": "Path to become a Machine Learning Expert",
    "section": "4. Introduction to Machine Learning",
    "text": "4. Introduction to Machine Learning\nNow it’s time to enter the belly of the beast. There are various resources to learn ML and I would suggest the following courses:\n\nMachine Learning by Stanford (Coursera) The Machine Learning course by Andrew Ng is one of the best courses out there and covers all the basic algorithms. Also, it introduces all the advanced topics in a very simple manner which is easy to understand. However, this course is taught in Octave rather than the popular languages like R/Python. Also, this course is NOT free but you can apply for financial aid.\nMachine Learning A-Z™: Hands-On Python & R In Data Science (Udemy) Good course for beginners. Explore complex topics such as natural language processing (NLP), reinforcement learning (RL), deep learning (DL) among many others. Tons of practice exercise and quizzes. This course is NOT free but comparatively not expensive.\nMachine Learning (edx) This is an advanced course that has the highest math prerequisite out of any other course in this list. You’ll need a very firm grasp of Linear Algebra, Calculus, Probability, and programming. This course is free of cost but to acquire a certificate payment is required.\nComprehensive learning path for Data Science (Analytics Vidhya) This course covers every topic right from the beginning. Installing Python, data cleaning and preparation, Machine learning concepts, deep learning, and NLP. This course is free and does not come with any certification.\n\nBooks:\n\nThe Hundred Page Machine Learning Book\nThe Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition\n\nList of best books for machine learning.\nAfter learning about the various techniques in ML the next natural thing to do is apply those techniques. What better place than Kaggle. It is one of the most popular websites among data science enthusiasts. Below two problem statement can be a good starting problem statement to begin with.\n\nTitanic: Machine Learning from Disaster\nHouse Prices: Advanced Regression Techniques"
  },
  {
    "objectID": "posts/ml/machine-learning-expert-path.html#deep-learning",
    "href": "posts/ml/machine-learning-expert-path.html#deep-learning",
    "title": "Path to become a Machine Learning Expert",
    "section": "5. Deep Learning",
    "text": "5. Deep Learning\nUsing the idea to mimic a human brain has been around since the 1900s. There were various algorithms and techniques developed for the same but due to the lack of computing power, it was difficult to run those algorithms.\nDue to the improvements in the hardware and the introduction to using GPUs to compute caught the attention of people passionate about working on neural net-based models. Today, state of the art results can be obtained using deep neural networks.\nCourses from deeplearning.ai on Coursera are one of the most popular and fantastic courses on deep learning.\n\nNeural Networks and Deep Learning\nDeep Learning Specialization\n\nBoth the courses are paid but financial aid is available for both of them.\nAdditional Resources:\n\nDeep Learning Summer School, Montreal 2015\nDeep Learning for Perception, Virginia Tech, Electrical, and Computer Engineering\nCS231N 2017\nA blog that explains concepts on Convolutional Neural Nets (CNN)\n(Book) Deep Learning – Methods and Applications\n(Youtube Channel) DeepLearning.TV\nDeep Learning book from MIT\nNeural Networks and Deep Learning online Book\nComprehensive resources on deeplearning.net"
  },
  {
    "objectID": "posts/ml/machine-learning-expert-path.html#natural-language-processing",
    "href": "posts/ml/machine-learning-expert-path.html#natural-language-processing",
    "title": "Path to become a Machine Learning Expert",
    "section": "6. Natural Language Processing",
    "text": "6. Natural Language Processing\nNatural language processing (NLP) is a branch of Artificial Intelligence which aims to bridge the gap between how a computer and human communicate with each other. The two major handles used for communication are speech and written i.e. text. If you are unfamiliar with what NLP is, this blog could help in understanding what NLP is.\nCourses:\n\n(Youtube) Natural Language Processing by University of Michigan\nSpeech and Language Processing\nStanford CS224N: NLP with Deep Learning Winter 2019 – Stanford\nLecture Collection on Natural Language Processing with Deep Learning (Winter 2017) – Stanford\nCS224d: Deep Learning for Natural Language Processing – Stanford\nNatural Language Processing Specialization offered by deeplearning.ai on Coursera (Intermediate level)\nNatural Language Processing offered by National Research University Higher School of Economics on Coursera (Advanced level course)\n\nMachine Learning in itself is a huge domain and the only way to master it is to explore and practice. I cannot stress more on practice because without practice is like trying to play the guitar without any strings.\nPopular blogs to follow:\n\nAnalytics Vidhya\nMachine Learning Mastery\nTowards Data Science\nKDnuggets\n\nAdditional Resources:\n\nA Complete Python Tutorial to Learn Data Science from Scratch\nA Comprehensive Learning Path for Deep Learning in 2019 on Analytics Vidhya\nLearning Path to Master Computer Vision in 2020 on Analytics Vidhya\nA Comprehensive Learning Path to Understand and Master NLP in 2020 on Analytics Vidhya\nA Comprehensive Guide to Understand and Implement Text Classification in Python on Analytics Vidhya\nCollection of datasets for NLP\nA comprehensive Learning path to becoming a data scientist in 2020 free course on Analytics Vidhya\n\nI wish you all the best on your journey to becoming a machine learning expert.\nShare if you like it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html",
    "href": "posts/nlp/text-preprocessing.html",
    "title": "Text Preprocessing",
    "section": "",
    "text": "In any machine learning task, cleaning and pre-processing of the data is a very important step. The better we can represent our data, the better the model training and prediction can be expected.\nSpecially in the domain of Natural Language Processing (NLP) the data is unstructured. It become crucial to clean and properly format it based on the task at hand. There are various pre-processing steps that can be performed but not necessary to perform all. These steps should be applied based on the problem statement.\nExample: Sentiment analysis on twitter data can required to remove hashtags, emoticons, etc. but this may not be the case if we are doing the same analysis on customer feedback data.\nHere we are using the twitter_sample dataset from the nltk library."
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#lower-casing",
    "href": "posts/nlp/text-preprocessing.html#lower-casing",
    "title": "Text Preprocessing",
    "section": "Lower Casing",
    "text": "Lower Casing\nLowercasing is a common text preprocessing technique. It helps to transform all the text in same case.  Examples ‘The’, ‘the’, ‘ThE’ -> ‘the’\nThis is also useful to find all the duplicates since words in different cases are treated as separate words and becomes difficult for us to remove redundant words in all different case combination.\nThis may not be helpful when we do tasks like Part of Speech tagging (where proper casing gives some information about Nouns and so on) and Sentiment Analysis (where upper casing refers to anger and so on)\n\ndf.text = df.text.str.lower()\ndf.head(2)\n\n\n\n\n\n  \n    \n      \n      text\n      label\n    \n  \n  \n    \n      0\n      username changed! :d\n      1\n    \n    \n      1\n      @kimtaaeyeonss unnieeee!!!:)\n      1"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#remove-redundant-features",
    "href": "posts/nlp/text-preprocessing.html#remove-redundant-features",
    "title": "Text Preprocessing",
    "section": "Remove Redundant Features",
    "text": "Remove Redundant Features\n\n\n\n\n\n\nNote\n\n\n\nNote: How you define redundant features varies based on the problem statement.\n\n\n\nURL’s\nURL stands for Uniform Resource Locator. If present in a text, it represents the location of another website.\nIf we are performing any websites backlink analysis, in that case URL’s are useful to keep. Otherwise, they don’t provide any information. So we can remove them from our text.\n\ndf.text = df.text.str.replace(r'https?://\\S+|www\\.\\S+', '', regex=True)\ndf.head()\n\n\n\n\n\n  \n    \n      \n      text\n      label\n    \n  \n  \n    \n      0\n      username changed! :d\n      1\n    \n    \n      1\n      @kimtaaeyeonss unnieeee!!!:)\n      1\n    \n    \n      2\n      @amyewest thanks! i hope you've got a good book to keep you company. :-)\n      1\n    \n    \n      3\n      :) where are you situated? @hijay09\n      1\n    \n    \n      4\n      @egaroo you're welcome, i'm glad you liked it :)\n      1\n    \n  \n\n\n\n\n\n\nE-mail\nE-mail id’s are common in customer feedback data and they do not provide any useful information. So we remove them from the text.\nTwitter data that we are using does not contain any email id’s. Hence, please find the code snipper with an dummy example to remove e-mail id’s.\n\ntext = 'I have being trying to contact xyz via email to xyz@abc.co.in but there is no response.'\nre.sub(r'\\S+@\\S+', '', text)\n\n'I have being trying to contact xyz via email to  but there is no response.'\n\n\n\n\nDate\nDates can be represented in various formats and can be difficult at times to remove them. They are unlikely to contain any useful information for predicting the labels.\nBelow I have used dummy text to showcase the following task.\n\ntext = \"Today is 22/12/2020 and after two days on 24-12-2020 our vacation starts until 25th.09.2021\"\n\n# 1. Remove date formats like: dd/mm/yy(yy), dd-mm-yy(yy), dd(st|nd|rd).mm/yy(yy)\nre.sub(r'\\d{1,2}(st|nd|rd|th)?[-./]\\d{1,2}[-./]\\d{2,4}', '', text)\n\n'Today is  and after two days on  our vacation starts until '\n\n\n\ntext = \"Today is 11th of January, 2021 when I am writing this post. I hope to post this by February 15th or max to max by 20 may 21 or 20th-December-21\"\n\n# 2. Remove date formats like: 20 apr 21, April 15th, 11th of April, 2021\npattern = re.compile(\n    r'(\\d{1,2})?(st|nd|rd|th)?[-./,]?\\s?(of)?\\s?([J|j]an(uary)?|[F|f]eb(ruary)?|[Mm]ar(ch)?|[Aa]pr(il)?|[Mm]ay|[Jj]un(e)?|[Jj]ul(y)?|[Aa]ug(ust)?|[Ss]ep(tember)?|[Oo]ct(ober)?|[Nn]ov(ember)?|[Dd]ec(ember)?)\\s?(\\d{1,2})?(st|nd|rd|th)?\\s?[-./,]?\\s?(\\d{2,4})?')\npattern.sub(r'', text)\n\n'Today is  when I am writing this post. I hope to post this byor max to max by or '\n\n\nThere are various formats in which dates are represented and the above regex can be customized in many ways. Above, “byor” got combined cause we are trying multiple format in single regex pattern. You can customize the above expression accordingly to your need.\n\n\nHTML Tags\nIf we are extracting data from various websites, it is possible that the data also contains HTML tags. These tags does not provide any information and should be removed. These tags can be removed using regex or by using BeautifulSoup library.\n\n# Dummy text\ntext = \"\"\"\n<title>Below is a dummy html code.</title>\n<body>\n    <p>All the html opening and closing brackets should be remove.</p>\n    <a href=\"https://www.abc.com\">Company Site</a>\n</body>\n\"\"\"\n\n\n# Using regex to remove html tags\npattern = re.compile('<.*?>')\npattern.sub('', text)\n\n'\\nBelow is a dummy html code.\\n\\n    All the html opening and closing brackets should be remove.\\n    Company Site\\n\\n'\n\n\n\n# Using Beautiful Soup\ndef remove_html(text):\n    clean_text = BeautifulSoup(text).get_text()\n    return clean_text\n\n\nremove_html(text)\n\n'\\nBelow is a dummy html code.\\n\\nAll the html opening and closing brackets should be remove.\\nCompany Site\\n\\n'\n\n\n\n\nEmojis\nAs more and more people have started using social media emoji’s play a very crucial role. Emoji’s are used to express emotions that are universally understood.\nIn some analysis such as sentiment analysis emoji’s can be useful. We can convert them to words or create some new features based on them. For some analysis we need to remove them. Find the below code snippet used to remove the emoji’s.\n\n\nCode\n# Reference: https://gist.github.com/slowkow/7a7f61f495e3dbb7e3d767f97bd7304b\n\ndef remove_emoji(text):\n    emoji_pattern = re.compile(\"[\"\n                               u\"\\U0001F600-\\U0001F64F\"  # emoticons\n                               u\"\\U0001F300-\\U0001F5FF\"  # symbols & pictographs\n                               u\"\\U0001F680-\\U0001F6FF\"  # transport & map symbols\n                               u\"\\U0001F1E0-\\U0001F1FF\"  # flags (iOS)\n                               u\"\\U00002500-\\U00002BEF\"  # chinese char\n                               u\"\\U00002702-\\U000027B0\"\n                               u\"\\U00002702-\\U000027B0\"\n                               u\"\\U000024C2-\\U0001F251\"\n                               u\"\\U0001f926-\\U0001f937\"\n                               u\"\\U00010000-\\U0010ffff\"\n                               u\"\\u2640-\\u2642\"\n                               u\"\\u2600-\\u2B55\"\n                               u\"\\u200d\"\n                               u\"\\u23cf\"\n                               u\"\\u23e9\"\n                               u\"\\u231a\"\n                               u\"\\ufe0f\"  # dingbats\n                               u\"\\u3030\"\n                               \"]+\", flags=re.UNICODE)\n    return emoji_pattern.sub(r'', text)\n\n\n\ntext = \"game is on 🔥🔥. Hilarious😂\"\nremove_emoji(text)\n\n'game is on . Hilarious'\n\n\n\n# Remove emoji's from text\ndf.text = df.text.apply(lambda x: remove_emoji(x))\n\n\n\nEmoticons\nEmoji’s and Emoticons are different. Yes!! Emoticons are used to express facial expressions using keyboard characters such as letters, numbers, and pucntuation marks. Where emjoi’s are small images.\nThanks to Neel Shah for curating a dictionary of emoticons and their description. We shall use this dictionary and remove the emoticons from our text.\n\n\nCode\nEMOTICONS = {\n    u\":‑\\)\": \"Happy face or smiley\",\n    u\":\\)\": \"Happy face or smiley\",\n    u\":-\\]\": \"Happy face or smiley\",\n    u\":\\]\": \"Happy face or smiley\",\n    u\":-3\": \"Happy face smiley\",\n    u\":3\": \"Happy face smiley\",\n    u\":->\": \"Happy face smiley\",\n    u\":>\": \"Happy face smiley\",\n    u\"8-\\)\": \"Happy face smiley\",\n    u\":o\\)\": \"Happy face smiley\",\n    u\":-\\}\": \"Happy face smiley\",\n    u\":\\}\": \"Happy face smiley\",\n    u\":-\\)\": \"Happy face smiley\",\n    u\":c\\)\": \"Happy face smiley\",\n    u\":\\^\\)\": \"Happy face smiley\",\n    u\"=\\]\": \"Happy face smiley\",\n    u\"=\\)\": \"Happy face smiley\",\n    u\":‑D\": \"Laughing, big grin or laugh with glasses\",\n    u\":D\": \"Laughing, big grin or laugh with glasses\",\n    u\"8‑D\": \"Laughing, big grin or laugh with glasses\",\n    u\"8D\": \"Laughing, big grin or laugh with glasses\",\n    u\"X‑D\": \"Laughing, big grin or laugh with glasses\",\n    u\"XD\": \"Laughing, big grin or laugh with glasses\",\n    u\"=D\": \"Laughing, big grin or laugh with glasses\",\n    u\"=3\": \"Laughing, big grin or laugh with glasses\",\n    u\"B\\^D\": \"Laughing, big grin or laugh with glasses\",\n    u\":-\\)\\)\": \"Very happy\",\n    u\":‑\\(\": \"Frown, sad, andry or pouting\",\n    u\":-\\(\": \"Frown, sad, andry or pouting\",\n    u\":\\(\": \"Frown, sad, andry or pouting\",\n    u\":‑c\": \"Frown, sad, andry or pouting\",\n    u\":c\": \"Frown, sad, andry or pouting\",\n    u\":‑<\": \"Frown, sad, andry or pouting\",\n    u\":<\": \"Frown, sad, andry or pouting\",\n    u\":‑\\[\": \"Frown, sad, andry or pouting\",\n    u\":\\[\": \"Frown, sad, andry or pouting\",\n    u\":-\\|\\|\": \"Frown, sad, andry or pouting\",\n    u\">:\\[\": \"Frown, sad, andry or pouting\",\n    u\":\\{\": \"Frown, sad, andry or pouting\",\n    u\":@\": \"Frown, sad, andry or pouting\",\n    u\">:\\(\": \"Frown, sad, andry or pouting\",\n    u\":'‑\\(\": \"Crying\",\n    u\":'\\(\": \"Crying\",\n    u\":'‑\\)\": \"Tears of happiness\",\n    u\":'\\)\": \"Tears of happiness\",\n    u\"D‑':\": \"Horror\",\n    u\"D:<\": \"Disgust\",\n    u\"D:\": \"Sadness\",\n    u\"D8\": \"Great dismay\",\n    u\"D;\": \"Great dismay\",\n    u\"D=\": \"Great dismay\",\n    u\"DX\": \"Great dismay\",\n    u\":‑O\": \"Surprise\",\n    u\":O\": \"Surprise\",\n    u\":‑o\": \"Surprise\",\n    u\":o\": \"Surprise\",\n    u\":-0\": \"Shock\",\n    u\"8‑0\": \"Yawn\",\n    u\">:O\": \"Yawn\",\n    u\":-\\*\": \"Kiss\",\n    u\":\\*\": \"Kiss\",\n    u\":X\": \"Kiss\",\n    u\";‑\\)\": \"Wink or smirk\",\n    u\";\\)\": \"Wink or smirk\",\n    u\"\\*-\\)\": \"Wink or smirk\",\n    u\"\\*\\)\": \"Wink or smirk\",\n    u\";‑\\]\": \"Wink or smirk\",\n    u\";\\]\": \"Wink or smirk\",\n    u\";\\^\\)\": \"Wink or smirk\",\n    u\":‑,\": \"Wink or smirk\",\n    u\";D\": \"Wink or smirk\",\n    u\":‑P\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\":P\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\"X‑P\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\"XP\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\":‑Þ\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\":Þ\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\":b\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\"d:\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\"=p\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\">:P\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\":‑/\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\":/\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\":-[.]\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\">:[(\\\\\\)]\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\">:/\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\":[(\\\\\\)]\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\"=/\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\"=[(\\\\\\)]\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\":L\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\"=L\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\":S\": \"Skeptical, annoyed, undecided, uneasy or hesitant\",\n    u\":‑\\|\": \"Straight face\",\n    u\":\\|\": \"Straight face\",\n    u\":$\": \"Embarrassed or blushing\",\n    u\":‑x\": \"Sealed lips or wearing braces or tongue-tied\",\n    u\":x\": \"Sealed lips or wearing braces or tongue-tied\",\n    u\":‑#\": \"Sealed lips or wearing braces or tongue-tied\",\n    u\":#\": \"Sealed lips or wearing braces or tongue-tied\",\n    u\":‑&\": \"Sealed lips or wearing braces or tongue-tied\",\n    u\":&\": \"Sealed lips or wearing braces or tongue-tied\",\n    u\"O:‑\\)\": \"Angel, saint or innocent\",\n    u\"O:\\)\": \"Angel, saint or innocent\",\n    u\"0:‑3\": \"Angel, saint or innocent\",\n    u\"0:3\": \"Angel, saint or innocent\",\n    u\"0:‑\\)\": \"Angel, saint or innocent\",\n    u\"0:\\)\": \"Angel, saint or innocent\",\n    u\":‑b\": \"Tongue sticking out, cheeky, playful or blowing a raspberry\",\n    u\"0;\\^\\)\": \"Angel, saint or innocent\",\n    u\">:‑\\)\": \"Evil or devilish\",\n    u\">:\\)\": \"Evil or devilish\",\n    u\"\\}:‑\\)\": \"Evil or devilish\",\n    u\"\\}:\\)\": \"Evil or devilish\",\n    u\"3:‑\\)\": \"Evil or devilish\",\n    u\"3:\\)\": \"Evil or devilish\",\n    u\">;\\)\": \"Evil or devilish\",\n    u\"\\|;‑\\)\": \"Cool\",\n    u\"\\|‑O\": \"Bored\",\n    u\":‑J\": \"Tongue-in-cheek\",\n    u\"#‑\\)\": \"Party all night\",\n    u\"%‑\\)\": \"Drunk or confused\",\n    u\"%\\)\": \"Drunk or confused\",\n    u\":-###..\": \"Being sick\",\n    u\":###..\": \"Being sick\",\n    u\"<:‑\\|\": \"Dump\",\n    u\"\\(>_<\\)\": \"Troubled\",\n    u\"\\(>_<\\)>\": \"Troubled\",\n    u\"\\(';'\\)\": \"Baby\",\n    u\"\\(\\^\\^>``\": \"Nervous or Embarrassed or Troubled or Shy or Sweat drop\",\n    u\"\\(\\^_\\^;\\)\": \"Nervous or Embarrassed or Troubled or Shy or Sweat drop\",\n    u\"\\(-_-;\\)\": \"Nervous or Embarrassed or Troubled or Shy or Sweat drop\",\n    u\"\\(~_~;\\) \\(・\\.・;\\)\": \"Nervous or Embarrassed or Troubled or Shy or Sweat drop\",\n    u\"\\(-_-\\)zzz\": \"Sleeping\",\n    u\"\\(\\^_-\\)\": \"Wink\",\n    u\"\\(\\(\\+_\\+\\)\\)\": \"Confused\",\n    u\"\\(\\+o\\+\\)\": \"Confused\",\n    u\"\\(o\\|o\\)\": \"Ultraman\",\n    u\"\\^_\\^\": \"Joyful\",\n    u\"\\(\\^_\\^\\)/\": \"Joyful\",\n    u\"\\(\\^O\\^\\)／\": \"Joyful\",\n    u\"\\(\\^o\\^\\)／\": \"Joyful\",\n    u\"\\(__\\)\": \"Kowtow as a sign of respect, or dogeza for apology\",\n    u\"_\\(\\._\\.\\)_\": \"Kowtow as a sign of respect, or dogeza for apology\",\n    u\"<\\(_ _\\)>\": \"Kowtow as a sign of respect, or dogeza for apology\",\n    u\"<m\\(__\\)m>\": \"Kowtow as a sign of respect, or dogeza for apology\",\n    u\"m\\(__\\)m\": \"Kowtow as a sign of respect, or dogeza for apology\",\n    u\"m\\(_ _\\)m\": \"Kowtow as a sign of respect, or dogeza for apology\",\n    u\"\\('_'\\)\": \"Sad or Crying\",\n    u\"\\(/_;\\)\": \"Sad or Crying\",\n    u\"\\(T_T\\) \\(;_;\\)\": \"Sad or Crying\",\n    u\"\\(;_;\": \"Sad of Crying\",\n    u\"\\(;_:\\)\": \"Sad or Crying\",\n    u\"\\(;O;\\)\": \"Sad or Crying\",\n    u\"\\(:_;\\)\": \"Sad or Crying\",\n    u\"\\(ToT\\)\": \"Sad or Crying\",\n    u\";_;\": \"Sad or Crying\",\n    u\";-;\": \"Sad or Crying\",\n    u\";n;\": \"Sad or Crying\",\n    u\";;\": \"Sad or Crying\",\n    u\"Q\\.Q\": \"Sad or Crying\",\n    u\"T\\.T\": \"Sad or Crying\",\n    u\"QQ\": \"Sad or Crying\",\n    u\"Q_Q\": \"Sad or Crying\",\n    u\"\\(-\\.-\\)\": \"Shame\",\n    u\"\\(-_-\\)\": \"Shame\",\n    u\"\\(一一\\)\": \"Shame\",\n    u\"\\(；一_一\\)\": \"Shame\",\n    u\"\\(=_=\\)\": \"Tired\",\n    u\"\\(=\\^\\·\\^=\\)\": \"cat\",\n    u\"\\(=\\^\\·\\·\\^=\\)\": \"cat\",\n    u\"=_\\^= \": \"cat\",\n    u\"\\(\\.\\.\\)\": \"Looking down\",\n    u\"\\(\\._\\.\\)\": \"Looking down\",\n    u\"\\^m\\^\": \"Giggling with hand covering mouth\",\n    u\"\\(\\・\\・?\": \"Confusion\",\n    u\"\\(?_?\\)\": \"Confusion\",\n    u\">\\^_\\^<\": \"Normal Laugh\",\n    u\"<\\^!\\^>\": \"Normal Laugh\",\n    u\"\\^/\\^\": \"Normal Laugh\",\n    u\"\\（\\*\\^_\\^\\*）\": \"Normal Laugh\",\n    u\"\\(\\^<\\^\\) \\(\\^\\.\\^\\)\": \"Normal Laugh\",\n    u\"\\(^\\^\\)\": \"Normal Laugh\",\n    u\"\\(\\^\\.\\^\\)\": \"Normal Laugh\",\n    u\"\\(\\^_\\^\\.\\)\": \"Normal Laugh\",\n    u\"\\(\\^_\\^\\)\": \"Normal Laugh\",\n    u\"\\(\\^\\^\\)\": \"Normal Laugh\",\n    u\"\\(\\^J\\^\\)\": \"Normal Laugh\",\n    u\"\\(\\*\\^\\.\\^\\*\\)\": \"Normal Laugh\",\n    u\"\\(\\^—\\^\\）\": \"Normal Laugh\",\n    u\"\\(#\\^\\.\\^#\\)\": \"Normal Laugh\",\n    u\"\\（\\^—\\^\\）\": \"Waving\",\n    u\"\\(;_;\\)/~~~\": \"Waving\",\n    u\"\\(\\^\\.\\^\\)/~~~\": \"Waving\",\n    u\"\\(-_-\\)/~~~ \\($\\·\\·\\)/~~~\": \"Waving\",\n    u\"\\(T_T\\)/~~~\": \"Waving\",\n    u\"\\(ToT\\)/~~~\": \"Waving\",\n    u\"\\(\\*\\^0\\^\\*\\)\": \"Excited\",\n    u\"\\(\\*_\\*\\)\": \"Amazed\",\n    u\"\\(\\*_\\*;\": \"Amazed\",\n    u\"\\(\\+_\\+\\) \\(@_@\\)\": \"Amazed\",\n    u\"\\(\\*\\^\\^\\)v\": \"Laughing,Cheerful\",\n    u\"\\(\\^_\\^\\)v\": \"Laughing,Cheerful\",\n    u\"\\(\\(d[-_-]b\\)\\)\": \"Headphones,Listening to music\",\n    u'\\(-\"-\\)': \"Worried\",\n    u\"\\(ーー;\\)\": \"Worried\",\n    u\"\\(\\^0_0\\^\\)\": \"Eyeglasses\",\n    u\"\\(\\＾ｖ\\＾\\)\": \"Happy\",\n    u\"\\(\\＾ｕ\\＾\\)\": \"Happy\",\n    u\"\\(\\^\\)o\\(\\^\\)\": \"Happy\",\n    u\"\\(\\^O\\^\\)\": \"Happy\",\n    u\"\\(\\^o\\^\\)\": \"Happy\",\n    u\"\\)\\^o\\^\\(\": \"Happy\",\n    u\":O o_O\": \"Surprised\",\n    u\"o_0\": \"Surprised\",\n    u\"o\\.O\": \"Surpised\",\n    u\"\\(o\\.o\\)\": \"Surprised\",\n    u\"oO\": \"Surprised\",\n    u\"\\(\\*￣m￣\\)\": \"Dissatisfied\",\n    u\"\\(‘A`\\)\": \"Snubbed or Deflated\"\n}\n\n\n\ndef remove_emoticons(text):\n    emoticons_pattern = re.compile(\n        u'(' + u'|'.join(emo for emo in EMOTICONS) + u')')\n    return emoticons_pattern.sub(r'', text)\n\n\nremove_emoticons(\"Hello :->\")\n\n'Hello '\n\n\n\n# Remove emoticons from text\ndf.text = df.text.apply(lambda x: remove_emoticons(x))\n\n\n\nHashtags and Mentions\nWe are habituated to use hashtags and mentions in our tweet either to indicate the context or bring attention to an individual. Hashtags can be used to extract features, to see what’s trending and in various other applications.\nSince, we don’t require them we’ll remove them.\n\ndef remove_tags_mentions(text):\n    pattern = re.compile(r'(@\\S+|#\\S+)')\n    return pattern.sub('', text)\n\n\ntext = \"live @flippinginja on #younow - jonah and jareddddd\"\nremove_tags_mentions(text)\n\n'live  on  - jonah and jareddddd'\n\n\n\n# Remove hashtags and mentions\ndf.text = df.text.apply(lambda x: remove_tags_mentions(x))\n\n\n\nPunctuations\nPunctuations are character other than alphaters and digits. These include [!“#$%&'()*+,-./:;<=>?@\\^_`{|}~]\nIt is better remove or convert emoticons before removing the punctuations, since if we do the other we around we might loose the emoticons from the text. Another example, if the text contains $10.50 then we’ll remove the .(dot) and the value will loose it’s meaning.\n\nPUNCTUATIONS = string.punctuation\n\n\ndef remove_punctuation(text):\n    return text.translate(str.maketrans('', '', PUNCTUATIONS))\n\n\ndf.text = df[\"text\"].apply(lambda text: remove_punctuation(text))\n\n\n\n\n\n  \n    \n      \n      text\n      label\n    \n  \n  \n    \n      0\n      username changed d\n      1\n    \n    \n      1\n      unnieeee\n      1\n    \n    \n      2\n      thanks i hope youve got a good book to keep you company\n      1\n    \n    \n      3\n      where are you situated\n      1\n    \n    \n      4\n      youre welcome im glad you liked it\n      1\n    \n  \n\n\n\n\n\n\nStopwords\nStopwords are commonly occuring words in any language. Such as, in english these words are ‘the’, ‘a’, ‘an’, & many more. They are in most cases not useful and should be removed.\nThere are certain tasks in which these words are useful such as Part-of-Speech(POS) tagging, language translation. Stopwords are compiled for many languages, for english language we can use the list from the nltk package.\n\nSTOPWORDS = set(stopwords.words('english'))\n\n\ndef remove_stopwords(text):\n    return ' '.join([word for word in text.split() if word not in STOPWORDS])\n\n\n# Remove stopwords\ndf.text = df.text.apply(lambda text: remove_stopwords(text))\ndf.head()\n\n\n\n\n\n  \n    \n      \n      text\n      label\n    \n  \n  \n    \n      0\n      username changed\n      1\n    \n    \n      1\n      unnieeee\n      1\n    \n    \n      2\n      thanks hope youve got good book keep company\n      1\n    \n    \n      3\n      situated\n      1\n    \n    \n      4\n      youre welcome im glad liked\n      1\n    \n  \n\n\n\n\n\n\nNumbers\nWe may remove numbers if they are not useful in our analysis. But analysis in the financial domain, numbers are very useful.\n\ndf.text = df.text.str.replace(r'\\d+', '', regex=True)\n\n\n\nExtra whitespaces\nAfter usually after preprocessing the text there might be extra whitespaces that might be created after transforming, removing various characters. Also, there is a need to remove all the new line, tab characters as well from our text.\n\ndef remove_whitespaces(text):\n    return \" \".join(text.split())\n\n\ntext = \"  Whitespaces in the beginning are removed  \\t as well \\n  as in between  the text   \"\n\nclean_text = \" \".join(text.split())\nclean_text\n\n'Whitespaces in the beginning are removed as well as in between the text'\n\n\n\ndf.text = df.text.apply(lambda x: remove_whitespaces(x))\n\n\n\nFrequent words\nPreviously we have removed stopwords which are common in any language. If we are working in any domain, we can also remove the common words used in that domain which don’t provide us with much information.\n\ndef freq_words(text):\n    tokens = word_tokenize(text)\n    FrequentWords = []\n\n    for word in tokens:\n        counter[word] += 1\n\n    for (word, word_count) in counter.most_common(10):\n        FrequentWords.append(word)\n    return FrequentWords\n\n\ndef remove_fw(text, FrequentWords):\n    tokens = word_tokenize(text)\n    without_fw = []\n    for word in tokens:\n        if word not in FrequentWords:\n            without_fw.append(word)\n\n    without_fw = ' '.join(without_fw)\n    return without_fw\n\n\ncounter = Counter()\n\n\ntext = \"\"\"\nNatural Language Processing is the technology used to aid computers to understand the human’s natural language. It’s not an easy task teaching machines to understand how we communicate. Leand Romaf, an experienced software engineer who is passionate at teaching people how artificial intelligence systems work, says that “in recent years, there have been significant breakthroughs in empowering computers to understand language just as we do.” This article will give a simple introduction to Natural Language Processing and how it can be achieved. Natural Language Processing, usually shortened as NLP, is a branch of artificial intelligence that deals with the interaction between computers and humans using the natural language. The ultimate objective of NLP is to read, decipher, understand, and make sense of the human languages in a manner that is valuable. Most NLP techniques rely on machine learning to derive meaning from human languages.\n\"\"\"\n\n\nFrequentWords = freq_words(text)\nprint(FrequentWords)\n\n[',', 'to', '.', 'is', 'the', 'understand', 'Natural', 'Language', 'Processing', 'computers']\n\n\n\nfw_result = remove_fw(text, FrequentWords)\nfw_result\n\n'technology used aid human ’ s natural language It ’ s not an easy task teaching machines how we communicate Leand Romaf an experienced software engineer who passionate at teaching people how artificial intelligence systems work says that “ in recent years there have been significant breakthroughs in empowering language just as we do. ” This article will give a simple introduction and how it can be achieved usually shortened as NLP a branch of artificial intelligence that deals with interaction between and humans using natural language The ultimate objective of NLP read decipher and make sense of human languages in a manner that valuable Most NLP techniques rely on machine learning derive meaning from human languages'\n\n\n\n\nRare words\nRare words are similar to frequent words. We can remove them because they are so less that they cannot add any value to the purpose.\n\ndef rare_words(text):\n    # tokenization\n    tokens = word_tokenize(text)\n    for word in tokens:\n        counter[word] = +1\n\n    RareWords = []\n    number_rare_words = 10\n    # take top 10 frequent words\n    frequentWords = counter.most_common()\n    for (word, word_count) in frequentWords[:-number_rare_words:-1]:\n        RareWords.append(word)\n\n    return RareWords\n\n\ndef remove_rw(text, RareWords):\n    tokens = word_tokenize(text)\n    without_rw = []\n    for word in tokens:\n        if word not in RareWords:\n            without_rw.append(word)\n\n    without_rw = ' '.join(without_fw)\n    return without_rw\n\n\ncounter = Counter()\n\n\ntext = \"\"\"\nNatural Language Processing is the technology used to aid computers to understand the human’s natural language. It’s not an easy task teaching machines to understand how we communicate. Leand Romaf, an experienced software engineer who is passionate at teaching people how artificial intelligence systems work, says that “in recent years, there have been significant breakthroughs in empowering computers to understand language just as we do.” This article will give a simple introduction to Natural Language Processing and how it can be achieved. Natural Language Processing, usually shortened as NLP, is a branch of artificial intelligence that deals with the interaction between computers and humans using the natural language. The ultimate objective of NLP is to read, decipher, understand, and make sense of the human languages in a manner that is valuable. Most NLP techniques rely on machine learning to derive meaning from human languages.\n\"\"\"\n\n\nRareWords = rare_words(text)\nRareWords\n\n['from',\n 'meaning',\n 'derive',\n 'learning',\n 'machine',\n 'on',\n 'rely',\n 'techniques',\n 'Most']\n\n\n\nrw_result = remove_fw(text, RareWords)\nrw_result\n\n'Natural Language Processing is the technology used to aid computers to understand the human ’ s natural language . It ’ s not an easy task teaching machines to understand how we communicate . Leand Romaf , an experienced software engineer who is passionate at teaching people how artificial intelligence systems work , says that “ in recent years , there have been significant breakthroughs in empowering computers to understand language just as we do. ” This article will give a simple introduction to Natural Language Processing and how it can be achieved . Natural Language Processing , usually shortened as NLP , is a branch of artificial intelligence that deals with the interaction between computers and humans using the natural language . The ultimate objective of NLP is to read , decipher , understand , and make sense of the human languages in a manner that is valuable . NLP to human languages .'"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#conversion-of-emoji-to-words",
    "href": "posts/nlp/text-preprocessing.html#conversion-of-emoji-to-words",
    "title": "Text Preprocessing",
    "section": "Conversion of Emoji to Words",
    "text": "Conversion of Emoji to Words\nTo remove or not is done based on the purpose of the application. Example if we are building a sentiment analysis system emoji’s can be useful.\n“The movie was 🔥” or “The movie was 💩”\nIf we remove the emoji’s the meaning of the sentence changes completely. In these cases we can convert emoji’s to words.\ndemoji requires an initial data download from the Unicode Consortium’s emoji code repository.\nOn first use of the package, call download_codes(). This will store the Unicode hex-notated symbols at ~/.demoji/codes.json for future use.\nRead more about demoji on pypi.org\n\ndemoji.download_codes()\n\nDownloading emoji data ...\n... OK (Got response in 1.35 seconds)\nWriting emoji data to C:\\Users\\sagar\\.demoji\\codes.json ...\n... OK\n\n\n\ndef emoji_to_words(text):\n    return demoji.replace_with_desc(text, sep=\"__\")\n\n\ntext = \"game is on 🔥 🚣🏼\"\nemoji_to_words(text)\n\n'game is on __fire__ __person rowing boat: medium-light skin tone__'"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#conversion-of-emoticons-to-words",
    "href": "posts/nlp/text-preprocessing.html#conversion-of-emoticons-to-words",
    "title": "Text Preprocessing",
    "section": "Conversion of Emoticons to Words",
    "text": "Conversion of Emoticons to Words\nAs we did for emoji’s, we convert emoticons to words for the same purpose.\n\ndef emoticons_to_words(text):\n    for emot in EMOTICONS:\n        text = re.sub(\n            u'('+emot+')', \"_\".join(EMOTICONS[emot].replace(\",\", \"\").replace(\":\", \"\").split()), text)\n    return text\n\n\ntext = \"Hey there!! :-)\"\nemoticons_to_words(text)\n\n'Hey there!! Happy_face_smiley'"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#converting-numbers-to-words",
    "href": "posts/nlp/text-preprocessing.html#converting-numbers-to-words",
    "title": "Text Preprocessing",
    "section": "Converting Numbers to Words",
    "text": "Converting Numbers to Words\nIf our analysis require us to use information based on the numbers in the text, we can convert them to words.\nRead more about num2words on github\n\ndef nums_to_words(text):\n    new_text = []\n    for word in text.split():\n        if word.isdigit():\n            new_text.append(num2words(word))\n        else:\n            new_text.append(word)\n    return \" \".join(new_text)\n\n\ntext = \"I ran this track 30 times\"\nnums_to_words(text)\n\n'I ran this track thirty times'"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#chat-words-conversion",
    "href": "posts/nlp/text-preprocessing.html#chat-words-conversion",
    "title": "Text Preprocessing",
    "section": "Chat words Conversion",
    "text": "Chat words Conversion\nThe more we use social media, we have become lazy to type the whole phrase or word. Due to which slang words came into existance such as “omg” which represents “Oh my god”. Such slang words don’t provide much information and if we need to use them we have to convert them.\nThank you: GitHub repo for the list of slang words\n\n\nCode\nchat_words = \"\"\"\nAFAIK=As Far As I Know\nAFK=Away From Keyboard\nASAP=As Soon As Possible\nATK=At The Keyboard\nATM=At The Moment\nA3=Anytime, Anywhere, Anyplace\nBAK=Back At Keyboard\nBBL=Be Back Later\nBBS=Be Back Soon\nBFN=Bye For Now\nB4N=Bye For Now\nBRB=Be Right Back\nBRT=Be Right There\nBTW=By The Way\nB4=Before\nB4N=Bye For Now\nCU=See You\nCUL8R=See You Later\nCYA=See You\nFAQ=Frequently Asked Questions\nFC=Fingers Crossed\nFWIW=For What It's Worth\nFYI=For Your Information\nGAL=Get A Life\nGG=Good Game\nGN=Good Night\nGMTA=Great Minds Think Alike\nGR8=Great!\nG9=Genius\nIC=I See\nICQ=I Seek you (also a chat program)\nILU=ILU: I Love You\nIMHO=In My Honest/Humble Opinion\nIMO=In My Opinion\nIOW=In Other Words\nIRL=In Real Life\nKISS=Keep It Simple, Stupid\nLDR=Long Distance Relationship\nLMAO=Laugh My A.. Off\nLOL=Laughing Out Loud\nLTNS=Long Time No See\nL8R=Later\nMTE=My Thoughts Exactly\nM8=Mate\nNRN=No Reply Necessary\nOIC=Oh I See\nPITA=Pain In The A..\nPRT=Party\nPRW=Parents Are Watching\nQPSA?=Que Pasa?\nROFL=Rolling On The Floor Laughing\nROFLOL=Rolling On The Floor Laughing Out Loud\nROTFLMAO=Rolling On The Floor Laughing My A.. Off\nSK8=Skate\nSTATS=Your sex and age\nASL=Age, Sex, Location\nTHX=Thank You\nTTFN=Ta-Ta For Now!\nTTYL=Talk To You Later\nU=You\nU2=You Too\nU4E=Yours For Ever\nWB=Welcome Back\nWTF=What The F...\nWTG=Way To Go!\nWUF=Where Are You From?\nW8=Wait...\n7K=Sick:-D Laugher\nOMG=Oh my god\"\"\"\n\n\n\nchat_words_dict = dict()\nchat_words_set = set()\n\n\ndef cw_conversion(text):\n    new_text = []\n    for word in text.split():\n        if word.upper() in chat_words_set:\n            new_text.append(chat_words_dict[word.upper()])\n        else:\n            new_text.append(word)\n    return \" \".join(new_text)\n\n\nfor line in chat_words.split('\\n'):\n    if line != '':\n        cw, cw_expanded = line.split('=')[0], line.split('=')[1]\n\n        chat_words_set.add(cw)\n        chat_words_dict[cw] = cw_expanded\n\n\ntext = \"omg that's awesome.\"\ncw_conversion(text)\n\n\"Oh my god that's awesome.\""
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#expanding-contractions",
    "href": "posts/nlp/text-preprocessing.html#expanding-contractions",
    "title": "Text Preprocessing",
    "section": "Expanding Contractions",
    "text": "Expanding Contractions\nContractions are words or combinations of words created by dropping a few letters and replacing those letters by an apostrophe.\nExample:\n\ndon’t: do not\nwe’ll: we will\n\nOur nlp model don’t understand these contractions i.e. they don’t understand that “don’t” and “do not” are the same thing. If our problem statement requires them then we can expand them or else leave it as it is.\n\ndef expand_contractions(text):\n    expanded_text = []\n    for line in text:\n        expanded_text.append(contractions.fix(line))\n    return expanded_text\n\n\ntext = [\"I'll be there within 15 minutes.\",\n        \"It's awesome to meet your new friends.\"]\nexpand_contractions(text)\n\n['I will be there within 15 minutes.',\n 'it is awesome to meet your new friends.']"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#stemming",
    "href": "posts/nlp/text-preprocessing.html#stemming",
    "title": "Text Preprocessing",
    "section": "Stemming",
    "text": "Stemming\nIn stemming we reduce the word to it’s base or root form by removing the suffix characters from the word. It is one of the technique to normalize text.\nStemming for root word “like” include:\n\n“likes”\n“liked”\n“likely”\n“liking”\n\nStemmed word doesn’t always match the words in our dictionary such as:\n\nconsole -> consol\ncompany -> compani\nwelcome -> welcom\n\nDue to which stemming is not performed in all nlp tasks.\nThere are various algorithms used for stemming but the most widely used is PorterStemmer. In this post we have used the PorterStemmer as well.\n\nstemmer = PorterStemmer()\n\n\ndef stem_words(text):\n    return ' '.join([stemmer.stem(word) for word in text.split()])\n\n\ndf['text_stemmed'] = df.text.apply(lambda text: stem_words(text))\ndf[['text', 'text_stemmed']].head()\n\n\n\n\n\n  \n    \n      \n      text\n      text_stemmed\n    \n  \n  \n    \n      0\n      username changed\n      usernam chang\n    \n    \n      1\n      unnieeee\n      unnieee\n    \n    \n      2\n      thanks hope youve got good book keep company\n      thank hope youv got good book keep compani\n    \n    \n      3\n      situated\n      situat\n    \n    \n      4\n      youre welcome im glad liked\n      your welcom im glad like\n    \n  \n\n\n\n\nPorterStemmer can be used only for english. If we are working with other than english then we can use SnowballStemmer.\n\nSnowballStemmer.languages\n\n('arabic',\n 'danish',\n 'dutch',\n 'english',\n 'finnish',\n 'french',\n 'german',\n 'hungarian',\n 'italian',\n 'norwegian',\n 'porter',\n 'portuguese',\n 'romanian',\n 'russian',\n 'spanish',\n 'swedish')"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#lemmatization",
    "href": "posts/nlp/text-preprocessing.html#lemmatization",
    "title": "Text Preprocessing",
    "section": "Lemmatization",
    "text": "Lemmatization\nLemmatization tried to perform the similar task as that of stemming i.e. trying to reduce the inflection words to it’s base form. But lemmatization does it by using a different approach.\nLemmatizations takes into consideration of the morphological analysis of the word. It tries to reduce to words to it’s dictionary form which is known as lemma.\n\nlemmatizer = WordNetLemmatizer()\n\n\ndef text_lemmatize(text):\n    return ' '.join([lemmatizer.lemmatize(word) for word in text.split()])\n\n\ndf['text_lemmatized'] = df.text.apply(lambda text: text_lemmatize(text))\ndf[['text', 'text_stemmed', 'text_lemmatized']].head()\n\n\n\n\n\n  \n    \n      \n      text\n      text_stemmed\n      text_lemmatized\n    \n  \n  \n    \n      0\n      username changed\n      usernam chang\n      username changed\n    \n    \n      1\n      unnieeee\n      unnieee\n      unnieeee\n    \n    \n      2\n      thanks hope youve got good book keep company\n      thank hope youv got good book keep compani\n      thanks hope youve got good book keep company\n    \n    \n      3\n      situated\n      situat\n      situated\n    \n    \n      4\n      youre welcome im glad liked\n      your welcom im glad like\n      youre welcome im glad liked\n    \n  \n\n\n\n\nDifference between Stemming and Lemmatization:\n\n\n\n\n\n\n\nStemming\nLemmatization\n\n\n\n\nFast compared to lemmatization\nSlow compared to stemming\n\n\nReduces the word to it’s base form by removing the suffix\nUses lexical knowledge to get the base form of the word\n\n\nDoes not always provide meaning or dictionary form of the original word\nResulting words are always meaningful and dictionary words"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#spelling-correction",
    "href": "posts/nlp/text-preprocessing.html#spelling-correction",
    "title": "Text Preprocessing",
    "section": "Spelling Correction",
    "text": "Spelling Correction\nWe as human always make mistake. Normally incorrect spelling in text are know as typos.\nSince the NLP model doesn’t know the difference between a correct and an incorrect word. For the model “thanks” and “thnks” are two different words. Therefore, spelling correction is an important step to bring the incorrect words in the correct format.\n\nspell = SpellChecker()\n\n\ndef correct_spelling(text):\n    correct_text = []\n    misspelled_words = spell.unknown(text.split())\n    for word in text.split():\n        if word in misspelled_words:\n            correct_text.append(spell.correction(word))\n        else:\n            correct_text.append(word)\n    return \" \".join(correct_text)\n\n\ntext = \"Hi, hwo are you doin? I'm good thnks for asking\"\ncorrect_spelling(text)\n\n\"Hi, how are you doing I'm good thanks for asking\"\n\n\n\ntext = \"hw are you doin? I'm god thnks\"\ncorrect_spelling(text)\n\n\"he are you doing I'm god thanks\""
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#convert-accented-characters-to-ascii-characters",
    "href": "posts/nlp/text-preprocessing.html#convert-accented-characters-to-ascii-characters",
    "title": "Text Preprocessing",
    "section": "Convert accented characters to ASCII characters",
    "text": "Convert accented characters to ASCII characters\nAccent marks (also referred to as diacritics or diacriticals) usually appear above a character when we press the character for a long time. These need to be remove cause the model cannot distinguish between “dèèp” and “deep”. It will consider them as two different words.\n\ndef accented_to_ascii(text):\n    return unidecode.unidecode(text)\n\n\ntext = \"This is an example text with accented characters like dèèp lèarning ánd cömputer vísíön etc.\"\naccented_to_ascii(text)\n\n'This is an example text with accented characters like deep learning and computer vision etc.'"
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#ekphrasis",
    "href": "posts/nlp/text-preprocessing.html#ekphrasis",
    "title": "Text Preprocessing",
    "section": "Ekphrasis",
    "text": "Ekphrasis\nCollection of lightweight text tools, geared towards text from social networks, such as Twitter or Facebook, for tokenization, word normalization, word segmentation (for splitting hashtags) and spell correction, using word statistics from 2 big corpora (english Wikipedia, twitter - 330mil english tweets).\nekphrasis was developed as part of the text processing pipeline for DataStories team’s submission for SemEval-2017 Task 4 (English), Sentiment Analysis in Twitter (source)\n\n# Referred from: https://github.com/cbaziotis/ekphrasis\n\ntext_processor = TextPreProcessor(\n    # terms that will be normalized\n    normalize=['url', 'email', 'percent', 'money', 'phone', 'user',\n               'time', 'url', 'date', 'number'],\n\n    # terms that will be annotated\n    annotate={\"hashtag\", \"allcaps\", \"elongated\", \"repeated\",\n              'emphasis', 'censored'},\n    fix_html=True,  # fix HTML tokens\n\n    # corpus from which the word statistics are going to be used\n    # for word segmentation\n    segmenter=\"twitter\",\n\n    # corpus from which the word statistics are going to be used\n    # for spell correction\n    corrector=\"twitter\",\n\n    unpack_hashtags=True,  # perform word segmentation on hashtags\n    unpack_contractions=True,  # Unpack contractions (can't -> can not)\n    spell_correct_elong=False,  # spell correction for elongated words\n\n    # select a tokenizer. You can use SocialTokenizer, or pass your own\n    # the tokenizer, should take as input a string and return a list of tokens\n    tokenizer=SocialTokenizer(lowercase=True).tokenize,\n\n    # list of dictionaries, for replacing tokens extracted from the text,\n    # with other expressions. You can pass more than one dictionaries.\n    dicts=[emoticons]\n)\n\nReading twitter - 1grams ...\nReading twitter - 2grams ...\nReading twitter - 1grams ...\n\n\n\n# Clean text based on function defined above\ndf['clean_tweets'] = [\n    \" \".join(text_processor.pre_process_doc(tweet)) for tweet in df.text]\n\n\n# Display the clean text\ndf.head()\n\n\n\n\n\n  \n    \n      \n      text\n      label\n      clean_tweets\n    \n  \n  \n    \n      0\n      @ManiMint_ you're welcome :)\n      1\n      <user> you are welcome <happy>\n    \n    \n      1\n      Expired and I used BIS money now I'm broke ):(...\n      0\n      expired and i used <allcaps> bis </allcaps> mo...\n    \n    \n      2\n      Thank you :) https://t.co/DuVcLseonQ\n      1\n      thank you <happy> <url>\n    \n    \n      3\n      @DeMoorSophie Hii, can you follow me, please? ...\n      1\n      <user> hii , can you follow me , please ? i ' ...\n    \n    \n      4\n      @hellasugg @MyNamesChai and sacconejoly's (@Jo...\n      0\n      <user> <user> and sacconejoly ' s ( <user> and..."
  },
  {
    "objectID": "posts/nlp/text-preprocessing.html#conclusion",
    "href": "posts/nlp/text-preprocessing.html#conclusion",
    "title": "Text Preprocessing",
    "section": "Conclusion",
    "text": "Conclusion\nIn this article, most of the text pre-processing techniques are explanied. I’ll update this post as I learn more techniques to pre-process text.\nShare if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/nlp/into-nlp.html",
    "href": "posts/nlp/into-nlp.html",
    "title": "What is Natural Language Processing?",
    "section": "",
    "text": "Natural language processing is a branch of Artificial Intelligence which aims to bridge the gap between how a computer and human communicate with each other. The two major handles used for communication are speech and written i.e. text."
  },
  {
    "objectID": "posts/nlp/into-nlp.html#history-of-natural-language-processing",
    "href": "posts/nlp/into-nlp.html#history-of-natural-language-processing",
    "title": "What is Natural Language Processing?",
    "section": "History of Natural Language Processing",
    "text": "History of Natural Language Processing\nThe dawn of NLP can be dated back to the early 1900s. In 1950, Alan Turing published his famous article “Computing Machinery and Intelligence” which proposed what is now called the Turing test as a criterion of intelligence. It tests the ability of the computer program to impersonate a human in a real-time conversation with a human judge where the judge is unable to distinguish the human from the computer program. In 1954, the Georgetown experiment automatically translated more than sixty Russian words into English.\nIn 1957, Noam Chomsky’s Syntactic Structures a rule-based system of syntactic structures with “universal grammar” was an incredible advancement. Up to the 1980’s most of the NLP systems were based on complex hand-written rules but in the late 1980s by the introduction of machine learning algorithms for language processing revolutionized the field. A steady increase in computational power resulting from Moore’s law and use of statistical models that use probabilistic measures to map the features making up the input data. Watson an artificial intelligence software designed as a question answering system won the Jeopardy contest, defeating the best human players in February 2011.\nDevelopment of famous virtual assistants like Siri in 2011, Amazon Alexa in 2014, and Google Assistant in 2016. The use of deep learning produced better results than the state-of-the-art in many natural language processing tasks, such as machine translation, text classification, and many more. Recent advancements include the use of network architecture of the transformer which is based on the attention mechanism that has produced better results in various NLP tasks.\nWe humans in our daily life overlook the powerful ability of our human brain to read, understand the meaning of a word, it’s context (how does it relate to each other), understand humor, sarcasm, and thousand other things. How do we teach this to a computer?"
  },
  {
    "objectID": "posts/nlp/into-nlp.html#challenges",
    "href": "posts/nlp/into-nlp.html#challenges",
    "title": "What is Natural Language Processing?",
    "section": "Challenges",
    "text": "Challenges\n1. Ambiguity:  In a natural language, words are unique but their meaning may differ based on the context in which it is used. One classical example used is: - The bank is a financial institution where customers can save or borrow money. - Tom was sitting by the banks of the river.\nIn this example, we can see that the word “bank” is used in two different ways. The word is the same but the meaning is different. This is because the context in which the word is used is different.\n2. Co-Referencing: It is a process to find all the phrases in the document that refer to the same entity. Example: Harry kept the paneer on the plate and ate it. Here it refers to the paneer that he ate which was kept on the plate.\n3. Information Extraction: Identifying phrases in a language that refer to specific types of entities and relations in text. Named Entity Recognition (NER) is the task used to identify the names of people, organizations, places, etc, in a text. Example: Tom used to work at FedEx and lives in Mumbai, India. where Person = Tom, organization = FedEx and Place = Mumbai, India\n4. Personality, intention, emotions, and style: Different authors may have different personalities, intentions, emotions, and styles to convey the same idea. Based on these factors the underlying idea can be interpreted in different ways. Use of humor or sarcasm may convey a meaning that is opposite of the literal one."
  },
  {
    "objectID": "posts/nlp/into-nlp.html#applications",
    "href": "posts/nlp/into-nlp.html#applications",
    "title": "What is Natural Language Processing?",
    "section": "Applications",
    "text": "Applications\n1. Machine Translation:  The idea behind machine translation is to develop a system that is capable of translating text from one language to another without any human intervention. Only translating the text from one language to another is not the key. Understanding the meaning behind the text and translating it to some other language is the crux of it. Example: Google Translate\n2. Automatic summarization:  We all love to read storybooks and always a good storybook will have a summary at the end that highlights the important things about the story. Likewise take any piece of text, a story, a news article, etc, and develop a system that can automatically summary the piece of text. Example: Inshorts – an app that summarizes each news article in 60 words.\n3. Sentiment Analysis:  It deals with the study of extracting opinions and sentiment that are not always explicitly expressed. For instance it helps the company to understand the level of consumer satisfaction for its goods and services. Example: “I love the new iPhone and it has a great camera.”.\nAnother branch of sentiment analysis is “Aspect based Sentiment Analysis” where it tries to extract opinions for each aspect from the customer review. Example: “The new iPhone is great it has a great camera but the battery life is not that good.” Here the customer is satisfied with the camera aspect of the iPhone but not the battery life.\n4. Text Classification:  Organizing text documents into predefined categories enables to classify the information or any activity. Examples: Classifying an email as spam or not spam.\n5. Question Answering:  Question answering deals with a system that can answer questions posed by humans in natural language. Sounds simple yet building the knowledge base, understanding the text, and to answer in natural language is altogether a thing in itself.\n6. Chatbots:  Chatbots are a piece of software that can simulate a conversation (or chat) with a user in natural language through websites, apps, messaging applications, etc. Chatbots are a natural evolution of question answering system but are one step further with their ability to understand the text and engage in a conversation.\n7. Speech Recognition:  Using our voice to interact with our phones has become a common phenomenon. For example to ask questions to our voice assistants like Google Assistant/Siri/Cortana, use of voice to type a piece of text. Recognizing speech has replaced the method by which we interact with our devices and made it so convenient.\nRecent advancements in NLP have deepened our knowledge on how to tackle the various challenges in NLP. Also, this new decade will be filled with excitement and breakthroughs that awaits us. Stay tunned to deep dive into the world of NLP.\nShare if you like it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/spark/movielens.html",
    "href": "posts/spark/movielens.html",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "",
    "text": "Recommendation System are build by analyzing the user and product interation data. It can be used to give item suggestion to a user or predict how a user would rate the an item.\nRecommendation System have mainly have three approaches:\nIn this notebook, Alternating Least Squares (ALS) matrix factorization algorithm with the use of Apache Spark APIs to predict the ratings of movies in the MovieLens Dataset.\nALS attempts to estimate the ratings matrix R as the product of two lower-rank matrices, X and Y, i.e. X * Yt = R. Typically these approximations are called ‘factor’ matrices. The general approach is iterative. During each iteration, one of the factor matrices is held constant, while the other is solved for using least squares. The newly-solved factor matrix is then held constant while solving for the other factor matrix (source)."
  },
  {
    "objectID": "posts/spark/movielens.html#data-description",
    "href": "posts/spark/movielens.html#data-description",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "1. Data Description",
    "text": "1. Data Description\nMovieLens 25M movie ratings. Stable benchmark dataset. 25 million ratings and one million tag applications applied to 62,000 movies by 162,000 users.\n\nmovies.csv: Movie information is contained in the file movies.csv. Each line of this file after the header row represents one movie, and has the following format: movieId,title,genres\n\nGenres are a pipe-separated list, and are selected from the following:\n\nAction\nAdventure\nAnimation\nChildren’s\nComedy\nCrime\nDocumentary\nDrama\nFantasy\nFilm-Noir\nHorror\nMusical\nMystery\nRomance\nSci-Fi\nThriller\nWar\nWestern\n(no genres listed)\n\n\nrating.csv: All ratings are contained in the file rating.csv. Each line of this file after the header row represents one rating of one movie by one user, and has the following format: userId,movieId,rating,timestamp\n\nThe lines within this file are ordered first by userId, then, within user, by movieId.\nRatings are made on a 5-star scale, with half-star increments (0.5 stars - 5.0 stars).\nTimestamps represent seconds since midnight Coordinated Universal Time (UTC) of January 1, 1970."
  },
  {
    "objectID": "posts/spark/movielens.html#overview-structure-and-data-content",
    "href": "posts/spark/movielens.html#overview-structure-and-data-content",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "2. Overview Structure and Data Content",
    "text": "2. Overview Structure and Data Content\n\n# Create a spark session\nspark = SparkSession.builder.appName(\n    \"movie-lens-recommendation\").config(\"spark.driver.memory\", \"16g\").getOrCreate()\nspark.sparkContext.setLogLevel(\"ERROR\")\n\nSetting default log level to \"WARN\".\nTo adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).\n\n\n23/01/21 01:45:14 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable\n\n\n\n# Read dataset\n__dirname = '../input/movielens-20m-dataset/'\nmovies = spark.read.csv(__dirname + 'movie.csv', header=True, inferSchema=True)\nratings = spark.read.csv(__dirname + 'rating.csv',\n                         header=True, inferSchema=True)\n\n                                                                                \n\n\n\n# Shape of the datasets\nprint(f'Movies has {movies.count()} rows and {len(movies.columns)} columns')\nprint(f'Ratings has {ratings.count()} rows and {len(ratings.columns)} colunms')\n\nMovies has 27278 rows and 3 columns\n\n\n[Stage 7:=================================================>         (5 + 1) / 6]\n\n\nRatings has 20000263 rows and 4 colunms\n\n\n                                                                                \n\n\n\n# Display top five rows of each dataframe\nmovies.show(n=5, truncate=False)\nratings.show(n=5, truncate=False)\n\n+-------+----------------------------------+-------------------------------------------+\n|movieId|title                             |genres                                     |\n+-------+----------------------------------+-------------------------------------------+\n|1      |Toy Story (1995)                  |Adventure|Animation|Children|Comedy|Fantasy|\n|2      |Jumanji (1995)                    |Adventure|Children|Fantasy                 |\n|3      |Grumpier Old Men (1995)           |Comedy|Romance                             |\n|4      |Waiting to Exhale (1995)          |Comedy|Drama|Romance                       |\n|5      |Father of the Bride Part II (1995)|Comedy                                     |\n+-------+----------------------------------+-------------------------------------------+\nonly showing top 5 rows\n\n+------+-------+------+-------------------+\n|userId|movieId|rating|timestamp          |\n+------+-------+------+-------------------+\n|1     |2      |3.5   |2005-04-02 23:53:47|\n|1     |29     |3.5   |2005-04-02 23:31:16|\n|1     |32     |3.5   |2005-04-02 23:33:39|\n|1     |47     |3.5   |2005-04-02 23:32:07|\n|1     |50     |3.5   |2005-04-02 23:29:40|\n+------+-------+------+-------------------+\nonly showing top 5 rows\n\n\n\n\n2.1. Data Structure and Statistics\nLet’s go over each dataframe and check it’s schema.\nRun the describe() method to see the count, mean, standard deviation, minimum, and maximum values for the data in each column:\n\n# Movies DataFrame\nmovies.printSchema()\nmovies.describe().show()\n\nroot\n |-- movieId: integer (nullable = true)\n |-- title: string (nullable = true)\n |-- genres: string (nullable = true)\n\n\n\n[Stage 14:>                                                         (0 + 1) / 1]\n\n\n+-------+-----------------+--------------------+------------------+\n|summary|          movieId|               title|            genres|\n+-------+-----------------+--------------------+------------------+\n|  count|            27278|               27278|             27278|\n|   mean|59855.48057042305|                null|              null|\n| stddev|44429.31469707313|                null|              null|\n|    min|                1|\"\"Great Performan...|(no genres listed)|\n|    max|           131262|       貞子3D (2012)|           Western|\n+-------+-----------------+--------------------+------------------+\n\n\n\n                                                                                \n\n\n\n# Ratings DataFrame\nratings.printSchema()\nratings.summary().show()\n\nroot\n |-- userId: integer (nullable = true)\n |-- movieId: integer (nullable = true)\n |-- rating: double (nullable = true)\n |-- timestamp: timestamp (nullable = true)\n\n\n\n[Stage 17:================================================>         (5 + 1) / 6]\n\n\n+-------+-----------------+------------------+------------------+\n|summary|           userId|           movieId|            rating|\n+-------+-----------------+------------------+------------------+\n|  count|         20000263|          20000263|          20000263|\n|   mean|69045.87258292554| 9041.567330339605|3.5255285642993797|\n| stddev|40038.62665316267|19789.477445413264| 1.051988919294229|\n|    min|                1|                 1|               0.5|\n|    25%|            34395|               903|               3.0|\n|    50%|            69133|              2167|               3.5|\n|    75%|           103637|              4771|               4.0|\n|    max|           138493|            131262|               5.0|\n+-------+-----------------+------------------+------------------+\n\n\n\n                                                                                \n\n\nNot all of these statistics are actually meaningful! You can use specific methods from the DataFrame API to compute any statistic:\n\nprint(\n    f\"Number of distinct users: {ratings.select('userId').distinct().count()}\")\nprint(\n    f\"Number of distinct movies: {ratings.select('movieId').distinct().count()}\")\n\n                                                                                \n\n\nNumber of distinct users: 138493\n\n\n[Stage 26:================================================>         (5 + 1) / 6]\n\n\nNumber of distinct movies: 26744\n\n\n                                                                                \n\n\nYou can also leverage your SQL knowledge to query the data.\nExample, Find the number of movies with ratings higher than 4 with and without SQL:\n\n# Without SQL\nprint(\n    f\"Number of distinct movies with rating greater than 4: {ratings.filter('rating > 4').select('movieId').distinct().count()}\")\n\n# With SQL\nratings.createOrReplaceTempView('ratings')\nspark.sql('SELECT COUNT(DISTINCT(movieId)) AS movie_count FROM ratings WHERE rating > 4').show()\n\n                                                                                \n\n\nNumber of distinct movies with rating greater than 4: 17218\n\n\n[Stage 44:================================================>         (5 + 1) / 6]\n\n\n+-----------+\n|movie_count|\n+-----------+\n|      17218|\n+-----------+\n\n\n\n                                                                                \n\n\n\n\n2.2. Missing Values\nCheck if any column contains missing values.\n\n# Check for missing values\n# 1. Movies Dataframe\nmovies.select([F.count(F.when(F.col(c).contains('NULL') |\n                              F.col(c).isNull() |\n                              F.isnan(c), c)).alias(c) for c in movies.columns]).show()\n\n# 2. Ratings Dataframe\nratings.select(*[(\n    F.count(\n        F.when(\n            (F.col(c).contains('NULL') | F.col(c).isNull() | F.isnan(c)), c)) if t not in ('timestamp', 'data')\n    else F.count(F.when(F.col(c).contains('NULL') | F.col(c).isNull(), c))).alias(c)\n    for c, t in ratings.dtypes]).show()\n\n+-------+-----+------+\n|movieId|title|genres|\n+-------+-----+------+\n|      0|    0|     0|\n+-------+-----+------+\n\n\n\n[Stage 53:================================================>         (5 + 1) / 6]\n\n\n+------+-------+------+---------+\n|userId|movieId|rating|timestamp|\n+------+-------+------+---------+\n|     0|      0|     0|        0|\n+------+-------+------+---------+\n\n\n\n                                                                                \n\n\n\n\n2.3. Merge DataFrame\nWe’ll merge the movies and ratings dataframe for further analysis and model building process.\n\n# Merge the movies and ratings dataframes\ndf = ratings.join(movies, on=[\"movieId\"], how=\"left\")\n\n\n# Look at df structure\ndf.printSchema()\nprint(f'Merged DataFrame has {df.count()} rows and {len(df.columns)} colunms')\n\nroot\n |-- movieId: integer (nullable = true)\n |-- userId: integer (nullable = true)\n |-- rating: double (nullable = true)\n |-- timestamp: timestamp (nullable = true)\n |-- title: string (nullable = true)\n |-- genres: string (nullable = true)\n\n\n\n[Stage 57:================================================>         (5 + 1) / 6]\n\n\nMerged DataFrame has 20000263 rows and 6 colunms\n\n\n                                                                                \n\n\n\n# Display top five rows of merged dataframe\ndf.show(n=5, truncate=False)\n\n+-------+------+------+-------------------+---------------------------------------------------------------+--------------------------------------+\n|movieId|userId|rating|timestamp          |title                                                          |genres                                |\n+-------+------+------+-------------------+---------------------------------------------------------------+--------------------------------------+\n|2      |1     |3.5   |2005-04-02 23:53:47|Jumanji (1995)                                                 |Adventure|Children|Fantasy            |\n|29     |1     |3.5   |2005-04-02 23:31:16|City of Lost Children, The (Cité des enfants perdus, La) (1995)|Adventure|Drama|Fantasy|Mystery|Sci-Fi|\n|32     |1     |3.5   |2005-04-02 23:33:39|Twelve Monkeys (a.k.a. 12 Monkeys) (1995)                      |Mystery|Sci-Fi|Thriller               |\n|47     |1     |3.5   |2005-04-02 23:32:07|Seven (a.k.a. Se7en) (1995)                                    |Mystery|Thriller                      |\n|50     |1     |3.5   |2005-04-02 23:29:40|Usual Suspects, The (1995)                                     |Crime|Mystery|Thriller                |\n+-------+------+------+-------------------+---------------------------------------------------------------+--------------------------------------+\nonly showing top 5 rows"
  },
  {
    "objectID": "posts/spark/movielens.html#visualizations",
    "href": "posts/spark/movielens.html#visualizations",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "3. Visualizations",
    "text": "3. Visualizations\n\n# Distribution of User Ratings\nrating_count_df = (df.groupBy(['rating']).count()).toPandas()\n\nfig = plt.figure(figsize=(8, 5))\nsns.barplot(x='rating', y='count', data=rating_count_df)\nplt.title(\"Count of each rating\", fontsize=14)\nplt.show()\n\n                                                                                \n\n\n\n\n\n\nrating_values = df.select(['rating']).toPandas()\n\nfig = plt.figure(figsize=(8, 5))\nsns.violinplot(rating_values['rating'])\nplt.title(\"Distribution of rating\", fontsize=14)\nplt.show()\n\n\n\n\nWe find:\n\nMost of the users have rated 4.0 followed by 3.0.\n\n\ngenre_rating = (df\n                .select(\"movieId\", \"userId\", \"genres\", \"rating\")\n                .withColumn(\"genres_array\", F.split(\"genres\", \"\\|\"))\n                .withColumn(\"genre\", F.explode(\"genres_array\"))\n                .groupBy(\"genre\").agg(F.mean(F.col(\"rating\")).alias(\"genre_rating\"),\n                                      F.countDistinct(\"movieId\").alias(\n                                          \"num_movies\"),\n                                      F.countDistinct(\"movieId\", \"userId\").alias(\"num_ratings\"))\n                ).toPandas()\n\n                                                                                \n\n\n\nfig, axes = plt.subplots(nrows=2, ncols=2, figsize=(20, 15))\n\ngenre_rating.plot.barh(\"genre\", \"genre_rating\", ax=axes[0, 0])\naxes[0, 0].set_title(\"Visualizing average rating for each genre\")\n\ngenre_rating.plot.barh(\"genre\", \"num_ratings\", ax=axes[0, 1])\naxes[0, 1].set_title(\"Visualizing number of ratings for each genre\")\n\ngenre_rating.plot.barh(\"genre\", \"num_movies\", ax=axes[1, 0])\naxes[1, 0].set_title(\"Visualizing number of movies in each genre\")\n\nfig.delaxes(axes[1, 1])\nfig.tight_layout()\n\nplt.show()\n\n\n\n\n\n# Analyzing day of the month - Timestamp of rating\nday_month_rating = (df\n                    .withColumnRenamed(\"timestamp\", \"date\")\n                    .withColumn(\"day\", F.dayofmonth(F.col(\"date\")))\n                    .groupBy(\"day\").agg(F.mean(F.col(\"rating\")).alias(\"avg_rating\"),\n                                        F.countDistinct(\"movieId\").alias(\n                                            \"num_movies\"),\n                                        F.countDistinct(\"movieId\", \"userId\").alias(\"num_ratings\"))\n                    ).toPandas()\n\n                                                                                \n\n\n\nfig, axes = plt.subplots(nrows=2, ncols=2, figsize=(20, 12))\n\nday_month_rating.plot.scatter(\"day\", \"avg_rating\", ax=axes[0, 0])\naxes[0, 0].set_title(\"Visualizing average rating rated each day\")\n\nday_month_rating.plot.scatter(\"day\", \"num_ratings\", ax=axes[0, 1])\naxes[0, 1].set_title(\"Visualizing number of ratings rated each day\")\n\nday_month_rating.plot.scatter(\"day\", \"num_movies\", ax=axes[1, 0])\naxes[1, 0].set_title(\"Visualizing number of movies rated each day\")\n\nfig.delaxes(axes[1, 1])\nfig.tight_layout()\n\nplt.show()\n\n\n\n\nWe find:\n\nThere is no clear pattern or relation between the day of the month with other features.\n\n\n# Analyzing day of the week - Timestamp of rating\nday_week_rating = (df\n                   .withColumnRenamed(\"timestamp\", \"date\")\n                   .withColumn(\"day\", F.dayofweek(F.col(\"date\")))\n                   .groupBy(\"day\").agg(F.mean(F.col(\"rating\")).alias(\"avg_rating\"),\n                                       F.countDistinct(\"movieId\").alias(\n                                           \"num_movies\"),\n                                       F.countDistinct(\"movieId\", \"userId\").alias(\"num_ratings\"))\n                   ).toPandas()\n\n                                                                                \n\n\n\nfig, axes = plt.subplots(nrows=2, ncols=2, figsize=(20, 12))\n\naxes[0, 0].scatter(day_week_rating.day.astype(\n    'int64'), day_week_rating.avg_rating)\naxes[0, 0].set_title(\"Visualizing average rating rated each day\")\n\naxes[0, 1].scatter(day_week_rating.day.astype(\n    'int64'), day_week_rating.num_ratings)\naxes[0, 1].set_title(\"Visualizing number of ratings rated each day\")\n\naxes[1, 0].scatter(day_week_rating.day.astype(\n    'int64'), day_week_rating.num_movies)\naxes[1, 0].set_title(\"Visualizing number of movies rated each day\")\n\nfig.delaxes(axes[1, 1])\nfig.tight_layout()\n\nplt.show()\n\n\n\n\n\nrelease_year_rating = (df\n                       .select(\"title\", \"movieId\", \"userId\", \"rating\")\n                       .withColumn(\"releaseyear\", F.substring('title', -5, 4))\n                       .filter(F.col(\"releaseyear\") > 1900)\n                       .groupBy(\"releaseyear\").agg(F.mean(F.col(\"rating\")).alias(\"avg_rating\"),\n                                                   F.countDistinct(\"movieId\").alias(\n                                                       \"num_movies\"),\n                                                   F.countDistinct(\"movieId\", \"userId\").alias(\"num_ratings\"))\n                       ).toPandas()\n\n                                                                                \n\n\n\nfig, axes = plt.subplots(nrows=2, ncols=2, figsize=(20, 12))\n\naxes[0, 0].scatter(release_year_rating.releaseyear.astype(\n    'int64'), release_year_rating.avg_rating)\naxes[0, 0].set_title(\"Visualizing average rating vs Release Year\")\n\naxes[0, 1].scatter(release_year_rating.releaseyear.astype(\n    'int64'), release_year_rating.num_ratings)\naxes[0, 1].set_title(\"Visualizing number of ratings vs Release Year\")\n\naxes[1, 0].scatter(release_year_rating.releaseyear.astype(\n    'int64'), release_year_rating.num_movies)\naxes[1, 0].set_title(\"Visualizing number of movies vs Release Year\")\n\nfig.delaxes(axes[1, 1])\nfig.tight_layout()\n\nplt.show()\n\n\n\n\nWe find:\n\nNumber of movies have increased significantly over the years.\nNumber of rating has a weird uprise and drop."
  },
  {
    "objectID": "posts/spark/movielens.html#data-preparation",
    "href": "posts/spark/movielens.html#data-preparation",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "4. Data Preparation",
    "text": "4. Data Preparation\n\n# Train Test split\n(train, test) = df.select(\n    ['userId', 'movieId', 'rating']).randomSplit([0.8, 0.2])"
  },
  {
    "objectID": "posts/spark/movielens.html#model-building",
    "href": "posts/spark/movielens.html#model-building",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "5. Model Building",
    "text": "5. Model Building\nParameter Description:\n\nrank: rank of the factorization\nmaxIter: max number of iterations (>= 0)\nregParam: regularization parameter (>= 0)\nuserCol: column name for user ids. Ids must be within the integer value range\nitemCol: column name for item ids. Ids must be within the integer value range\nratingCol: column name for ratings\ncoldStartStrategy: strategy for dealing with unknown or new users/items at prediction time. This may be useful in cross-validation or production scenarios, for handling user/item ids the model has not seen in the training data. Supported values: ‘nan’, ‘drop’\n\n\n# Basic Model building\nals = ALS(rank=10, maxIter=4, regParam=0.1, userCol='userId',\n          itemCol='movieId', ratingCol='rating', coldStartStrategy=\"drop\")\n\n# Define evaluator as RMSE\nevaluator = RegressionEvaluator(\n    metricName=\"rmse\", labelCol=\"rating\", predictionCol=\"prediction\")\n\n\n% % time\n# Fit the model\nmodel = als.fit(train)\n\n                                                                                \n\n\nCPU times: user 168 ms, sys: 40.7 ms, total: 209 ms\nWall time: 3min 24s\n\n\n\n# Evaluate the model\npredictions = model.transform(test)\nrmse = evaluator.evaluate(predictions)\n\nprint('The RMSE for our model is: {}'.format(rmse))\n\n[Stage 170:============================>                            (2 + 2) / 4]\n\n\nThe RMSE for our model is: 0.8176288680275328\n\n\n                                                                                \n\n\n\n5.1. Improving the model\nOne way to improve the model is to tune the hyperparameter of the model. CrossValidator is familiar with sklearn’s cross_val_score and ParamGridBuilder is a builder for a param grid used in grid search-based model selection.\nThe cross validation consumes enormouse amout of time and hence, below you can find the skeleton code to perform hyper parameter tuning.\n\n# Define the model parameter grid\nparam_grid = ParamGridBuilder()\\\n    .addGrid(als.rank, [12, 13, 14])\\\n    .addGrid(als.maxIter, [18, 19, 20])\\\n    .addGrid(als.regParam, [0.05, 0.5, 0.1])\\\n    .build()\n\n# Initialize the cross validator\ncrossVal = CrossValidator(\n    estimator=als, estimatorParamMaps=param_grid, evaluator=evaluator, numFolds=10)\n\n# Fit the model and perform cross validation\ncvModel = crossVal.fit(train)\n\n# Evaluate the model\ncvPredictions = cvModel.transform(test)\ncvRmse = evaluator.evaluate(cvPredictions)\n\nprint('The RMSE for our model is: {}'.format(cvRmse))"
  },
  {
    "objectID": "posts/spark/movielens.html#recommend-movies",
    "href": "posts/spark/movielens.html#recommend-movies",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "6. Recommend Movies",
    "text": "6. Recommend Movies\nTo recommend movies for a specific user, below is a function that applies the trained model, ALSModel, on the list of movies that the user hasn’t yet rated\n\ndef recommendMovies(model, user, nRecommendation):\n    # Create a Spark DataFrame with the specified user and all the movies listed in the ratings DataFrame\n    dataSet = ratings.select('movieId').distinct(\n    ).withColumn('userId', F.lit(user))\n\n    # Create a Spark DataFrame with the movies that have already been rated by this user\n    moviesAlreadyRated = ratings.filter(\n        ratings.userId == user).select('movieId', 'userId')\n\n    # Apply the recommender system to the data set without the already rated movies to predict ratings\n    predictions = model.transform(dataSet.subtract(moviesAlreadyRated)).dropna().orderBy(\n        'prediction', ascending=False).limit(nRecommendation).select('movieId', 'prediction')\n\n    # Join with the movies DataFrame to get the movies titles and genres\n    recommendations = predictions.join(movies, predictions.movieId == movies.movieId).select(\n        predictions.movieId, movies.title, movies.genres, predictions.prediction)\n\n    return recommendations\n\nNow run this function to recommend 10 movies for different users:\n\nprint('Recommendations for user 153:')\nrecommendMovies(model, 153, 10).toPandas()\n\nRecommendations for user 153:\n\n\n                                                                                \n\n\n\n\n\n\n  \n    \n      \n      movieId\n      title\n      genres\n      prediction\n    \n  \n  \n    \n      0\n      81117\n      Moth, The (Cma) (1980)\n      Drama\n      6.064673\n    \n    \n      1\n      82328\n      One Fine Spring Day (Bomnaleun ganda) (2001)\n      Drama\n      5.925478\n    \n    \n      2\n      109887\n      Great Passage, The (Fune wo amu) (2013)\n      Drama\n      5.818318\n    \n    \n      3\n      116183\n      It's Love I'm After (1937)\n      Comedy\n      5.911806\n    \n    \n      4\n      117907\n      My Brother Tom (2001)\n      Drama\n      6.311569\n    \n    \n      5\n      120134\n      Doggiewoggiez! Poochiewoochiez! (2012)\n      Comedy\n      6.050812\n    \n    \n      6\n      120821\n      The War at Home (1979)\n      Documentary|War\n      6.015426\n    \n    \n      7\n      121029\n      No Distance Left to Run (2010)\n      Documentary\n      6.553770\n    \n    \n      8\n      129536\n      Code Name Coq Rouge (1989)\n      (no genres listed)\n      6.092913\n    \n    \n      9\n      130347\n      Bill Hicks: Sane Man (1989)\n      Comedy\n      5.887615\n    \n  \n\n\n\n\n[Stage 420:=======================================>                (7 + 3) / 10]\n\n\n\nprint('Recommendations for user 250:')\nrecommendMovies(model, 250, 10).toPandas()\n\nRecommendations for user 250:\n\n\n                                                                                \n\n\n\n\n\n\n  \n    \n      \n      movieId\n      title\n      genres\n      prediction\n    \n  \n  \n    \n      0\n      26793\n      Tito and Me (Tito i ja) (1992)\n      Comedy\n      4.924314\n    \n    \n      1\n      103593\n      Taming the Fire (Ukroshcheniye ognya) (1972)\n      Documentary|Drama|Sci-Fi\n      4.850996\n    \n    \n      2\n      104317\n      Flight of the Conchords: A Texan Odyssey (2006)\n      Comedy\n      4.919813\n    \n    \n      3\n      107434\n      Diplomatic Immunity (2009– )\n      Comedy\n      4.923127\n    \n    \n      4\n      110669\n      Honest Liar, An (2014)\n      Comedy|Documentary\n      4.900411\n    \n    \n      5\n      118338\n      Hard to Be a God (2013)\n      Sci-Fi\n      4.911441\n    \n    \n      6\n      120134\n      Doggiewoggiez! Poochiewoochiez! (2012)\n      Comedy\n      5.056443\n    \n    \n      7\n      121029\n      No Distance Left to Run (2010)\n      Documentary\n      5.534087\n    \n    \n      8\n      128091\n      Craig Ferguson: A Wee Bit o' Revolution (2009)\n      Comedy\n      5.608799\n    \n    \n      9\n      130347\n      Bill Hicks: Sane Man (1989)\n      Comedy\n      5.114568\n    \n  \n\n\n\n\n[Stage 666:>                                                       (0 + 4) / 10]"
  },
  {
    "objectID": "posts/spark/movielens.html#thank-you",
    "href": "posts/spark/movielens.html#thank-you",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "Thank you",
    "text": "Thank you\nShare if you liked it, comment if you loved it. Hope to see you guys in the next one. Peace!"
  },
  {
    "objectID": "posts/spark/movielens.html#resources",
    "href": "posts/spark/movielens.html#resources",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "Resources",
    "text": "Resources\n\nML Tuning: Model Selection and Hyperparameter Tuning Using PySpark\nALS\nPySpark Documentation"
  },
  {
    "objectID": "posts/spark/movielens.html#data-citation",
    "href": "posts/spark/movielens.html#data-citation",
    "title": "Movie Lens - Collaborative Filtering based Recommendation System",
    "section": "Data Citation",
    "text": "Data Citation\nF. Maxwell Harper and Joseph A. Konstan. 2015. The MovieLens Datasets: History and Context. ACM Transactions on Interactive Intelligent Systems (TiiS) 5, 4, Article 19 (December 2015), 19 pages. DOI=http://dx.doi.org/10.1145/2827872"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sagar Thacker",
    "section": "",
    "text": "📮 Blog Series\n\nNatural Language Processing\nKaggle Competitions\n\n\n\n📬 Subscribe\n\n\n“Don’t focus on having a great blog. Focus on producing a blog that’s great for your readers.” - Brian Clark\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nPrefect Cloud Deployment\n\n\n\n\n\n\n\nMLOps\n\n\nPrefect\n\n\nDeployment\n\n\nPrefect-Cloud\n\n\n\n\nA comprehensive guide to deploying Prefect Flows on Prefect Cloud\n\n\n\n\n\n\nJun 16, 2023\n\n\n9 min\n\n\n\n\n\n\n  \n\n\n\n\nPrefect Deployment\n\n\n\n\n\n\n\nMLOps\n\n\nPrefect\n\n\nDeployment\n\n\n\n\nA comprehensive guide to deploying Prefect Flows\n\n\n\n\n\n\nJun 11, 2023\n\n\n18 min\n\n\n\n\n\n\n  \n\n\n\n\nPrefect Blocks\n\n\n\n\n\n\n\nMLOps\n\n\nPrefect\n\n\n\n\nPrefect Blocks are reusable, composable building blocks for orchestrating data workflows.\n\n\n\n\n\n\nJun 7, 2023\n\n\n11 min\n\n\n\n\n\n\n  \n\n\n\n\nPrefect: An Workflow Orchestration Tool\n\n\n\n\n\n\n\nMLOps\n\n\nPrefect\n\n\n\n\nPrefect is an open-source workflow orchestration tool that helps you automate and manage the flow of work across your data stack.\n\n\n\n\n\n\nJun 5, 2023\n\n\n19 min\n\n\n\n\n\n\n  \n\n\n\n\nMLflow on AWS\n\n\n\n\n\n\n\nMLOps\n\n\nMLflow\n\n\nAWS\n\n\n\n\nDiscover the implementation of MLflow on AWS, leveraging EC2 to host MLFlow Server, S3 for artifact storage and RDS-PostgreSQL for backend entity storager.\n\n\n\n\n\n\nMay 30, 2023\n\n\n6 min\n\n\n\n\n\n\n  \n\n\n\n\nIntroduction to MLflow\n\n\n\n\n\n\n\nMLOps\n\n\nMLflow\n\n\n\n\nLearn how MLflow simplifies experiment tracking, model versioning, and deployment for efficient machine learning development.\n\n\n\n\n\n\nMay 28, 2023\n\n\n9 min\n\n\n\n\n\n\n  \n\n\n\n\nAWS Instance Setup\n\n\n\n\n\n\n\nAWS\n\n\n\n\nStep-by-step guide to setup AWS EC2 Instance and setup environment\n\n\n\n\n\n\nMay 19, 2023\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\nIntroduction to MLOps\n\n\n\n\n\n\n\nMLOps\n\n\n\n\nLearn how to combine machine learning with software engineering to develop, deploy & maintain production ML applications.\n\n\n\n\n\n\nMay 18, 2023\n\n\n7 min\n\n\n\n\n\n\n  \n\n\n\n\nEDA - Playground Series Season 3, Episode 4\n\n\n\n\n\n\n\nKaggle\n\n\n\n\nTabular Classification with a Credit Card Fraud Dataset\n\n\n\n\n\n\nJan 30, 2023\n\n\n4 min\n\n\n\n\n\n\n  \n\n\n\n\nModeling - Playground Series Season 3, Episode 4\n\n\n\n\n\n\n\nKaggle\n\n\n\n\nTabular Classification with a Credit Card Fraud Dataset\n\n\n\n\n\n\nJan 30, 2023\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\nMovie Lens - Collaborative Filtering based Recommendation System\n\n\n\n\n\n\n\nPySpark\n\n\n\n\nMovie Recommendation Using PySpark\n\n\n\n\n\n\nJan 20, 2022\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\nSong Popularity EDA\n\n\n\n\n\n\n\nKaggle\n\n\n\n\nSong Popularity Prediction is a competition on Kaggle. This post is all about performing exploratory data analysis following the coding session by Martin Henze.\n\n\n\n\n\n\nMay 31, 2021\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\nText Preprocessing\n\n\n\n\n\n\n\nText Preprocessing\n\n\nNatural Language Processing\n\n\nNLP\n\n\n\n\nVairous preprocessing steps required to clean and prepare your data in NLP\n\n\n\n\n\n\nApr 19, 2021\n\n\n9 min\n\n\n\n\n\n\n  \n\n\n\n\nWhat is Natural Language Processing?\n\n\n\n\n\n\n\nNatural Language Processing\n\n\nNLP\n\n\n\n\nA brief summary of what is natural language processing, it’s challenges and applications.\n\n\n\n\n\n\nApr 12, 2021\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\nPath to become a Machine Learning Expert\n\n\n\n\n\n\n\nMachine Learning\n\n\nLearning Path\n\n\n\n\nComprehensive learning path to become an expert in Machine Learning\n\n\n\n\n\n\nApr 5, 2021\n\n\n7 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Hello,  I’m Sagar Thacker",
    "section": "",
    "text": "I’m a research scientist at University at Buffalo where I focus on identifying white supremacist extremist language in online hate speech. I am fortunate to be advised by Professor Kenneth Joseph.\nMy expertise lies in conducting research and development and creating software solutions using Natural Language Processing (NLP), Applied Machine Learning (ML), and Information Access. I have a strong interest in understanding entire ML lifecycle end-to-end to evaluate the business requirements; run experiments; build data and machine learning (ML) models; evaluate performance and business impact; deploy the models; setup long-term monitoring.\nI recently completed my Master’s degree in Computer Science from the University at Buffalo, The State University of New York in December 2022. During that period, one of my most exciting and rewarding project I worked upon involved various shared tasks from Social Media Mining for Health Applications (SMM4H) 2020 & 2021 to tackle problems in the health care domain. You can read more about this project here, along with my report.\nBefore moving to the USA, I worked remotely as a Data Scientist at FedEx Express. My responsibility included End-to-End Research, Design, Developement, Deployment of NLP, and classical ML classification tasks . I worked on projects such as identifying customer sentiments towards our services, classifying customer tickets to relevant departments for efficient resolution, building Extract-Transform-Load (ETL) pipelines, and developing dashboards to improve communication, productivity, and save time and money.\nIn 2018, I got the opportunity to work as a Assistant System Engineer at Tata Consultancy Services. I worked on developing automated test scripts to simulate testing process in web apps, model customer/software system interaction in ARD for automatic tests scripts generation.\nDuring my undergraduate studies at Ramrao Adik Institute of Technology (RAIT), I majored in Computer Science and actively participated in cultural events and competitions. I also served as the Administrator of Social Wing RAIT, a non-profit organization dedicated to creating a better society. In this role, I managed various events focused on making a positive impact, such as tree planting, teaching at orphanages, donation drives, and clean-up efforts.\nOne of our most successful events was a marathon fundraiser, with all proceeds going towards providing education for underprivileged children in our community for an entire academic year. Thanks to the overwhelming support of our community, we were able to provide education for more than 20 children, making a tangible and meaningful difference in their lives.\nOutside of work, I have a keen interest in learning about our galaxy, black holes, and physics. I also enjoy exploring different cuisines, watching football, and playing Dota 2. Connecting with others is something I truly enjoy, so if you share similar interests or would like to connect, please feel free to reach out. I look forward to hearing from you! 🙌\n\nMy Journey\n\n\n“Stay hungry. Stay foolish.” - Steve Job\n\n\n\n\n\n\n\n2021 - 2023\n\n\n\n\n\nUniversity at Buffalo, The State University of New York\n\n\nMaster of Science, Computer Science\n\n\n\n\n\n\n2014 - 2018\n\n\n\n\n\nUniversity of Mumbai\n\n\nBachelors of Engineering, Computer Engineering\n\n\n\n\n\n\n\n\n\n\n\n2020 - 2021\n\n\n\n\n\nData Scientist\n\n\nFedEx Express\n\n\n\n\n\n\n2018 - 2019\n\n\n\n\n\nAssistant System Engineer\n\n\nTata Consultancy Services\n\n\n\n\n\n\n\n\n\nAchievements\n\n\n\nSecured second place in the H2O World India Hackathon held in April 2023."
  },
  {
    "objectID": "nlp_series.html",
    "href": "nlp_series.html",
    "title": "Natural Language Processing",
    "section": "",
    "text": "What is Natural Language Processing\nText Preprocessing"
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html",
    "href": "posts/mlops/prefect-deployments.html",
    "title": "Prefect Deployment",
    "section": "",
    "text": "In this post, we’ll be looking at how to deploy a Prefect flow locally."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#what-does-deployment-mean",
    "href": "posts/mlops/prefect-deployments.html#what-does-deployment-mean",
    "title": "Prefect Deployment",
    "section": "What does deployment mean?",
    "text": "What does deployment mean?\nSo far, we’ve learned how to create and run a workflow on our local machine. The Prefect API has been helpful in tracking the workflow’s status through the user interface.\nHowever, what if we need to run the workflow on a different machine or schedule it to run automatically? This is where deployment comes into play."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#deployment-in-prefect",
    "href": "posts/mlops/prefect-deployments.html#deployment-in-prefect",
    "title": "Prefect Deployment",
    "section": "Deployment in Prefect",
    "text": "Deployment in Prefect\nTo deploy a Prefect workflow, we need to package the workflow code, settings, and infrastructure configuration. This packaging process enables us to manage the workflow using the Prefect API and execute it remotely on a Prefect agent.\nI understand this might sound technical, so let’s simplify it further.\n\nDeployment can be thought of as shipping a package that includes the workflow code, settings, and infrastructure configuration required by Prefect to run the workflow.\nAll the necessary files are packed into a single box and labeled with a yaml file e.g. deployment.yaml. This file contains information about the workflow, its location, and additional metadata.\nUsing the deployment.yaml file, we can ship the package to the Prefect API, which creates a deployment object and stores it in the Prefect database. The deployment is now ready to be executed.\nHowever, simply deploying the workflow doesn’t start its execution.\nIn Prefect, we have the concept of work-pools and agents/workers. When a deployed workflow runs, it creates a flow run which is similar to what we did previously when running a Prefect flow.\nHowever, during deployment, the flow run is submitted to a specific work-pool for scheduling. Think of the work-pool as a staging area where the flow run waits to be picked up by an agent/worker. (Imagine package lying in the warehouse waiting for the courier to be picked).\nAn agent or worker (courier), operating within the execution environment, polls the work-pool for new runs to execute.\nOnce an agent/worker picks up a flow run, it proceeds to execute it and reports the status back to the Prefect API.\n\nIt might seem like a lot of steps, but it’s quite simple once you get the hang of it. We’ll be going through each step in detail in the next section."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#deployment-in-action",
    "href": "posts/mlops/prefect-deployments.html#deployment-in-action",
    "title": "Prefect Deployment",
    "section": "Deployment in Action",
    "text": "Deployment in Action\nTo demonstrate deployment, we’ll be using a simple prefect flow that has a flow with one task. The task simply prints a message to the console. You can find the code for the flow below.\n\n\n\"prefect_demo.py\n\nfrom prefect import flow, task\n\n@task(name=\"say_hello\", log_prints=True)\ndef say_hello():\n    print(\"Hello, I'm a Task!\")\n\n@flow(name=\"hello-flow\", log_prints=True)\ndef flow_hello():\n    print(\"Hello, I'm a Flow!\")\n    print(\"I'm about to call a Task...\")\n    say_hello()\n\nif __name__ == \"__main__\":\n    flow_hello()\n\nThe flow is simple and will help us focus more on the deployment process rather than understanding what the flow does. Let’s get started.\n\nStep 1: Start a Prefect server\nBefore we can deploy our flow, we need to start a Prefect server. We’ll be using the Prefect CLI command to start the server. Run the following command in your terminal.\nprefect server start\n\n\nStep 2: Create a yaml file for the deployment\nWe’ll use the prefect deployment build command to create a deployment definition yaml file. Run the Prefect CLI command from the folder containing your flow script and any dependencies of the script.\nprefect deployment build [OPTIONS] PATH\nPath to the flow is specified in the format path-to-script:flow-function-name — The path and filename of the flow script file, a colon, then the name of the entrypoint flow function.\nFor our example, the command will be:\nprefect deployment build -n flow_test -p default-agent-pool -q test prefect_demo.py:flow_hello\nLet’s break down the command:\n\n-n specifies the name of the deployment. We’ve named our deployment flow_test.\n-p specifies the name of the work-pool. Prefect provides a default work-pool named default-agent-pool.\n-q specifies the name of the work queue. We’ve named our queue test.\nprefect_demo.py:flow_hello specifies the path to the flow script, a colon, then the name of the flow function.\n\nWhen you run this command, Prefect:\n\nCreates a flow_hello-deployment.yaml file for your deployment based on your flow code and options. Usually the format is <flow_name>-deployment.yaml. You can specify a different name using the --output option.\nUploads your flow files to the configured storage location (local by default). (We’ll cover storage in a later post).\nSubmit your deployment to the work queue test. The work queue test will be created if it doesn’t exist.\n\nYou can find the yaml file in the same folder as your flow script.\n\n\nWork Queues\n\nImagine work-pool has a big highway and work-queues are lanes on the highway. Each work-queue is a separate lane on the highway. When a flow run is submitted to a work-pool, it is placed in a work-queue.\nAs different lanes in a highway have different priorities, and purpose so do work-queues. For example, you might have a work-queue for high priority flows and another for low priority flows. You can seperate your test and production flows by using different work-queues.\nBelow you’ll find a brief overview of work-queues and I highly recommend you read the official documentation\n\nWork pools have a default queue where all work is sent by default, but additional queues can be added for finer control over work delivery.\nWork queues have priorities indicated by unique positive integers, with lower numbers having higher priority. New queues can be added without affecting the priority of existing queues.\nWork queues can also have their own concurrency limits, allowing for precise control over the execution of work. However, all queues are subject to the global work pool concurrency limit.\n\n\n\nStep 3: Create a deployment on Prefect API\nNow that we have the deployment.yaml file, we can create a deployment on the Prefect API. To do this, we’ll use the prefect deployment apply Prefect CLI command.\nprefect deployment apply PATH_TO_YAML_FILE\nFor our example, the command will be:\nprefect deployment apply flow_hello-deployment.yaml\nOnce the deployment is created, you’ll see it in the CLI and the Prefect UI. Run the prefect deployment ls command to see a list of all deployments.\nprefect deployment ls\n\n\nTo view the work-pool and work-queue in the Prefect UI, navigate to the Work Pools section and click on the default-agent-pool work-pool. Click on the Work Queues tab to view the test work-queue. You’ll also notice a default work queue. This is the default work queue that Prefect creates when you create any work-pool.\n\n\n\nStep 4: Start an agent\nAgent processes are lightweight polling services that regularly check a work-pool for scheduled work and execute the corresponding flow runs.\nBy default, agents poll for work every 15 seconds. You can adjust this interval by configuring the PREFECT_AGENT_QUERY_INTERVAL setting in the profile settings.\nYou can have multiple agent processes running for a single work pool. Each agent process sends a unique ID to the server, which helps distinguish them from one another and informs users about the number of active agents.\nWe’ll use the prefect agent start command to start an agent.\nprefect agent start -p [WORK_POOL_NAME]\nFor our example, the command will be:\nprefect agent start -p default-agent-pool\n\n\nStep 5: Execute the deployment\nNow that we have an agent running, we can execute the deployment. To do this, we’ll use the prefect deployment run command.\nprefect deployment run [OPTIONS] DEPLOYMENT_NAME\nIf you don’t know the name of the deployment, you can use the prefect deployment ls command to get a list of all deployments.\nFor our example, the command will be:\nprefect deployment run hello-flow/flow_test\nAfter running the command, you’ll see the flow run in the Prefect UI. Navigate to the Flow Runs section to view the flow run. Click on the flow run to view the logs.\n\nYou can also run the flow from the Prefect UI from the Flow section.\n\nCongratulations! You’ve successfully deployed and executed your first Prefect flow. Yet there’s so much more to cover like schedules, storage, agents, workers, and more.\nCongratulations! 🎉 You’ve successfully deployed and executed your first Prefect flow. Yet there’s so much more to cover like 📅 schedules, 📦 storage, 💪 agents, workers, and more."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#deployment.yaml-file",
    "href": "posts/mlops/prefect-deployments.html#deployment.yaml-file",
    "title": "Prefect Deployment",
    "section": "deployment.yaml file",
    "text": "deployment.yaml file\nThe YAML file for a deployment contains extra settings required to create the deployment on the server.\nA single flow can have multiple deployments created for it, each with different schedules, tags, and other configurations.\nTo achieve this, you can have multiple deployment YAML files referencing the same flow definition, each specifying distinct settings. The only rule is that each deployment must have a unique name.\n\nEach deployment is linked to a specific flow, but a flow can be referenced by multiple deployments.\nDeployments are uniquely identified based on the combination of the flow name and deployment name.\nThis allows you to execute a single flow with various parameters, on multiple schedules, and in different environments. It also enables you to run different versions of the same flow for testing or production purposes."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#schedules",
    "href": "posts/mlops/prefect-deployments.html#schedules",
    "title": "Prefect Deployment",
    "section": "Schedules",
    "text": "Schedules\nSchedules allow you to instruct the Prefect API to automatically generate new flow runs for you at regular intervals.\nYou can attach a schedule to any flow deployment. The Prefect Scheduler service regularly checks each deployment and generates new flow runs based on the schedule defined for that deployment.\nThere are four recommended ways to create a schedule for a deployment:\n\nUse the Prefect UI\nUse the cron, interval, or rrule flags with the CLI deployment build command\nUse the schedule parameter with a Python deployment file\nManually edit the deployment YAML file’s schedule section\n\nPrefect offers different types of schedules that cater to various needs and provide a high level of customization:\n\nCron: This type is well-suited for users who have prior experience with cron and want to leverage its functionality.\nInterval: Ideal for deployments that require a consistent cadence of execution, irrespective of specific timestamps.\nRRule: Designed for deployments that rely on calendar-based logic, allowing for simple recurring schedules, irregular intervals, exclusions, or adjustments based on specific days of the month.\n\nThese schedule types offer flexibility and can accommodate a wide range of scheduling requirements.\nWe’ll go through an example of scheduling a flow run in the section below."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#agents-and-workers",
    "href": "posts/mlops/prefect-deployments.html#agents-and-workers",
    "title": "Prefect Deployment",
    "section": "Agents and Workers",
    "text": "Agents and Workers\nWork-pools serve as a way to organize work that agents or workers pick up for execution. The coordination between deployments and agents happens through a shared work-pool name.\nIn case you want to create a new work pool, you would have to choose the type of the work pool. Type defines the type of infrastructure that can execute runs from this work pool.\nThat’s where which polling service (Agent / Worker) is decided. View the table below to understand the difference between the two.\n\n\n\n\n\n\n\n\nWork-Pool Type\nAgent/Worker\nDescription\n\n\n\n\nAmazon Elastic Container Service\nWorker\nExecutes flow runs as ECS tasks\n\n\nAzure Container Service\nWorker\nExecutes flow runs in ACI containers\n\n\nGoogle Cloud Run\nWorker\nExecutes flow runs as Google Cloud Run jobs\n\n\nDocker\nWorker\nExecutes flow runs within Docker containers\n\n\nKubernetes\nWorker\nExecutes flow runs as Kubernetes jobs\n\n\nProcess\nWorker\nExecutes flow runs in subprocesses\n\n\nPrefect Agent\nAgent\nExecutes flow runs in subprocesses\n\n\n\nWe have seen an example of an agent in the previous section. Let’s look at an example of a worker."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#scheduled-flow-run-example-with-worker",
    "href": "posts/mlops/prefect-deployments.html#scheduled-flow-run-example-with-worker",
    "title": "Prefect Deployment",
    "section": "Scheduled Flow Run Example with Worker",
    "text": "Scheduled Flow Run Example with Worker\n\nStep 1: Create a new work-pool.\nprefect work-pool create [OPTIONS] NAME\nFor our example, the command will be:\nprefect work-pool create test-pool -t process\n\n-t or --type flag is used to specify the type of work-pool. In our case, we are using the process type.\n\nOn CLI you can use the command prefect work-pool ls to list all the work-pools.\n\n\n\n\nStep 2: Create a new yaml file.\nprefect deployment build -n demo_schedule -p test-pool -q demo --cron \"0 0 * * *\" --output demo_schedule.yaml prefect_demo.py:flow_hello\n\n--cron flag is used to specify the cron schedule.\n\nThis create flow runs for this deployment every day at midnight.\n\n\nStep 3: Apply the deployment.\nprefect deployment apply demo_schedule.yaml\n\n\n\n\nStep 4: Start the worker.\nprefect worker start -p test-pool\n\n\nStep 5: Execute the deployment.\nEither run the deployment from the Prefect UI or use the CLI command.\n\n\n\n\n\n\nNote\n\n\n\nOne observation you might have made is that we are using the same flow for both the deployments but with different deployments. This is because we want to run the first flow manually through CLI or UI and second on a schedule.\n\n\nFirst can be used to test the flow and second can be used to run the flow on a schedule. It completely depends on your use case.\nI hope this provides a comprehensive overview of Prefect deployment and steps to deploy a flow. Hush… there’s an abundance yet to explore."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#storage",
    "href": "posts/mlops/prefect-deployments.html#storage",
    "title": "Prefect Deployment",
    "section": "Storage",
    "text": "Storage\nPrefect follows a hybrid model where your flow code stays within your storage and execution infrastructure and never lives on the Prefect server or database. What does that mean?\nIt means that there’s always a boundary between your code, your private infrastructure, and the Prefect backend. You can use your existing storage infrastructure to store your flow code. Prefect supports a wide range of storage options like GitHub, local storage, Bitbucket, Amazon S3, Google Cloud Storage, Azure Storage, and more.\nTill now we have been using local storage to store our flow code and run the Prefect Server. However, you might choose to store the flow code in a GitHub repository and run the Prefect Server on your local machine. Prefect supports this as well.\n\nWhile creating a deployment, you can specify the storage location of your flow code. This let’s Prefect Agent/Worker know where to look for the flow code.\nOne cool thing about it is if you make changes to your flow code, you don’t have to create a new deployment. Prefect Agent/Worker will automatically pick up the changes and execute the flow with the new code.\n\n\n\n\n\n\nWarning\n\n\n\nHowever, changes to the infrastructure code will require a new deployment. Such as entrypoint. This part of changing the infrastructure code is experimental for me, I have to try it out more to better understand it.\n\n\nThis post has been a long one. Hence, I have not covered storage in detail. You can refer to the official Prefect documentation on this topic for more details. Hopefully, in the next post I will cover the remaining topics.\nWait, there is ONE more thing!"
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#prefect-projects",
    "href": "posts/mlops/prefect-deployments.html#prefect-projects",
    "title": "Prefect Deployment",
    "section": "Prefect Projects",
    "text": "Prefect Projects\n\n\n\n\n\n\nWarning\n\n\n\nProjects are a beta feature and are subject to change in future releases.\n\n\nPrefect Projects is a new feature that describe how to prepare one or more flow deployments. You can create a project using the Prefect CLI command prefect project init.\nI would encourage you to follow along in a new directory so as to seperate what we did so far from the project.\n# Create a new directory\nmkdir project\n\n# Change directory\ncd project\n\n# Create a new Prefect project\nprefect project init\nOnce you run the command, three files and a directory will be created - deployment.yaml, prefect.yaml, .prefectignore, and .prefect/ directory.\n\ndeployment.yaml: a YAML file describing base settings for deployments produced from this project\nprefect.yaml: a YAML file describing procedural steps for preparing a deployment from this project, as well as instructions for preparing the execution environment for a deployment run\n.prefect/: a hidden directory where Prefect will store workflow metadata\n.prefectignore: a file that specifies files and directories to ignore when preparing a deployment\n\nBelow we’ll go through an example of how to use Prefect Projects to create a deployment.\n\n\nStep 1: Create a new project.\nprefect project init\n\n\nStep 2: Create a flow.\nWe’ll be utilizing the same flow we created earlier but with some changes. The flow will take a name as an argument, which are called parameters to a flow in Prefect.\n\n\nprefect_demo.py\n\nimport argparse\nfrom prefect import flow, task\n\n@task(name=\"say_hello\", log_prints=True)\ndef say_hello():\n    print(\"Hello, I'm a Task!\")\n\n@flow(name=\"hello-flow\", log_prints=True)\ndef flow_hello(name: str):\n    print(f\"Hello {name}, I'm a Flow!\")\n    print(\"I'm about to call a Task...\")\n    say_hello()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--name\", help=\"Your name\", default=\"World\")\n    args = parser.parse_args()    \n    \n    flow_hello(args.name)\n\n\n\nStep 3: Start the Prefect Server.\nprefect server start\n\n\nStep 4: Start the Prefect Worker.\nprefect worker start -p test-pool\n\n\nStep 5: Configure the deployment.yaml file.\nPreviously, we created seperated files for creating a deployment and executing it.\nHowever, with Prefect Projects, we can do both in a single file. The deployment.yaml file is used to configure the deployment. Let’s look at the contents of the file.\n\n\ndeployment.yaml\n\ndeployments:\n- # base metadata\n  name: manual-deployment\n  tags: [\"test\"]\n  description: \"Trigger deployment using `run` CLI command or Prefect UI\"\n  \n  # flow-specific fields\n  entrypoint: prefect_demo.py:flow_hello\n  parameters:\n    name: \"Sagar\"\n  \n  # infra-specific fields\n  work_pool:\n    name: test-pool\n    work_queue_name: demo\n\n- # base metadata\n  name: scheduled-deployment\n  tags: [\"dev\"]\n  description: \"Trigger deployment using a Schedule\"\n  schedule:\n    cron: 0 0 * * *\n    timezone: America/Chicago\n  \n  # flow-specific fields\n  entrypoint: prefect_demo.py:flow_hello\n  parameters:\n    name: \"World\"\n  \n  # infra-specific fields\n  work_pool:\n    name: test-pool\n    work_queue_name: demo\n\n\n\nStep 6: Deploy your flow.\nThis file has two deployment declarations, each referencing a same flow in the project but with different parameters and schedule. Each deployment declaration has a unique name field and can be deployed individually by using the --name flag when deploying.\n\n\n\n\n\n\nTip\n\n\n\nYou also have the freedom to deploy different flows in the same yaml file. Example, we already have one flow file called prefect_demo.py. We can create another flow file called prefect_demo_2.py and reference it in the deployment.yaml file. Give the appropriate entrypoint and parameters and you are good to go.\n\n\nThis method of declaring multiple deployments allows the configuration for all deployments within a project to be version controlled and deployed with a single command.\nYou can deploy a single deployment by using the --name flag.\nprefect deploy --name manual-deployment\nYou can also deploy multiple deployments by providing multiple --name flags.\nprefect deploy --name manual-deployment --name scheduled-deployment\nOr, you can deploy all the deployments by using the --all flag.\nprefect deploy --all\nFor our example, we’ll deploy both the deployments.\nprefect deploy --all\nYou might have noticed that we are using the prefect deploy command instead of prefect deployment command. This is because while using Prefect Projects, prefect deploy command under the hood performs multiple steps like build, push, pull, and applies the deployment. You can read more about it here.\n\n\n\n\nStep 7: Execute the deployments.\nYou can execute a deployment either through the Prefect UI or using the CLI command.\n# Using the default parameters\nprefect deployment run hello-flow/manual-deployment\n\n# Using the custom parameters\nprefect deployment run hello-flow/manual-deployment --param name=\"Prefect\"\nOutput of the CLI command with default parameters.\n\nOutput of the CLI command with custom parameters.\n\nCongratulations! 🎉 You have successfully created your first Prefect Project.\nPrefect Project have a lot more to offer.\nI encourage you to read about Templating Options for deployment.yaml file that lets you refer dynamic value to the file. Also, read more about prefect.yaml file here."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#conclusion",
    "href": "posts/mlops/prefect-deployments.html#conclusion",
    "title": "Prefect Deployment",
    "section": "Conclusion",
    "text": "Conclusion\nIn this post, we covered the basics of Prefect deployment and how to deploy a flow. We also covered Prefect Projects and how to use it to create a deployment. In the next post, we’ll cover storgae and deployment on Prefect Cloud.\nThank you for reading and I hope you found this notebook helpful. 👏 Upvote if you liked it, 💬 comment if you loved it. Hope to see you guys in the next one. ✌️ Peace!"
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#worker",
    "href": "posts/mlops/prefect-deployments.html#worker",
    "title": "Prefect Deployment",
    "section": "Worker",
    "text": "Worker\n\n\n\n\n\n\nWarning\n\n\n\nWorkers are a beta feature and are subject to change in future releases.\n\n\nWorkers are similar to Agents in that they are long-running processes that poll for work i.e., fetch scheduled runs from a work pool and carry out their execution.\nHowever, workers provide the advantage of more control over infrastructure configuration and the capability to route work to specific types of execution environments.\nEach worker is assigned a type that corresponds to the specific execution environment where it will submit flow runs. Workers can only join work pools that match their designated type. Consequently, when deployments are associated with a work pool, you can determine the execution environment in which scheduled flow runs for that deployment will be executed.\nAbove table shows the different types of workers available. Prefect also provides a way to create your own worker type."
  },
  {
    "objectID": "posts/mlops/prefect-deployments.html#references",
    "href": "posts/mlops/prefect-deployments.html#references",
    "title": "Prefect Deployment",
    "section": "References",
    "text": "References\n\nDeployments\nWork Pools, Workers & Agents\nStorage\nSchedules\nProjects\nDeployment Tutorial\nEnd-to-End Example Image"
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html",
    "href": "posts/mlops/prefect-deployment.html",
    "title": "Prefect Deployment",
    "section": "",
    "text": "In this post, we’ll be looking at how to deploy a Prefect flow locally."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#what-does-deployment-mean",
    "href": "posts/mlops/prefect-deployment.html#what-does-deployment-mean",
    "title": "Prefect Deployment",
    "section": "What does deployment mean?",
    "text": "What does deployment mean?\nSo far, we’ve learned how to create and run a workflow on our local machine. The Prefect API has been helpful in tracking the workflow’s status through the user interface.\nHowever, what if we need to run the workflow on a different machine or schedule it to run automatically? This is where deployment comes into play."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#deployment-in-prefect",
    "href": "posts/mlops/prefect-deployment.html#deployment-in-prefect",
    "title": "Prefect Deployment",
    "section": "Deployment in Prefect",
    "text": "Deployment in Prefect\nTo deploy a Prefect workflow, we need to package the workflow code, settings, and infrastructure configuration. This packaging process enables us to manage the workflow using the Prefect API and execute it remotely on a Prefect agent.\nI understand this might sound technical, so let’s simplify it further.\n\nDeployment can be thought of as shipping a package that includes the workflow code, settings, and infrastructure configuration required by Prefect to run the workflow.\nAll the necessary files are packed into a single box and labeled with a yaml file e.g. deployment.yaml. This file contains information about the workflow, its location, and additional metadata.\nUsing the deployment.yaml file, we can ship the package to the Prefect API, which creates a deployment object and stores it in the Prefect database. The deployment is now ready to be executed.\nHowever, simply deploying the workflow doesn’t start its execution.\nIn Prefect, we have the concept of work-pools and agents/workers. When a deployed workflow runs, it creates a flow run which is similar to what we did previously when running a Prefect flow.\nHowever, during deployment, the flow run is submitted to a specific work-pool for scheduling. Think of the work-pool as a staging area where the flow run waits to be picked up by an agent/worker. (Imagine package lying in the warehouse waiting for the courier to be picked).\nAn agent or worker (courier), operating within the execution environment, polls the work-pool for new runs to execute.\nOnce an agent/worker picks up a flow run, it proceeds to execute it and reports the status back to the Prefect API.\n\nIt might seem like a lot of steps, but it’s quite simple once you get the hang of it. We’ll be going through each step in detail in the next section."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#deployment-in-action",
    "href": "posts/mlops/prefect-deployment.html#deployment-in-action",
    "title": "Prefect Deployment",
    "section": "Deployment in Action",
    "text": "Deployment in Action\nTo demonstrate deployment, we’ll be using a simple prefect flow that has a flow with one task. The task simply prints a message to the console. You can find the code for the flow below.\n\n\n\"prefect_demo.py\n\nfrom prefect import flow, task\n\n@task(name=\"say_hello\", log_prints=True)\ndef say_hello():\n    print(\"Hello, I'm a Task!\")\n\n@flow(name=\"hello-flow\", log_prints=True)\ndef flow_hello():\n    print(\"Hello, I'm a Flow!\")\n    print(\"I'm about to call a Task...\")\n    say_hello()\n\nif __name__ == \"__main__\":\n    flow_hello()\n\nThe flow is simple and will help us focus more on the deployment process rather than understanding what the flow does. Let’s get started.\n\nStep 1: Start a Prefect server\nBefore we can deploy our flow, we need to start a Prefect server. We’ll be using the Prefect CLI command to start the server. Run the following command in your terminal.\nprefect server start\n\n\nStep 2: Create a yaml file for the deployment\nWe’ll use the prefect deployment build command to create a deployment definition yaml file. Run the Prefect CLI command from the folder containing your flow script and any dependencies of the script.\nprefect deployment build [OPTIONS] PATH\nPath to the flow is specified in the format path-to-script:flow-function-name — The path and filename of the flow script file, a colon, then the name of the entrypoint flow function.\nFor our example, the command will be:\nprefect deployment build -n flow_test -p default-agent-pool -q test prefect_demo.py:flow_hello\nLet’s break down the command:\n\n-n specifies the name of the deployment. We’ve named our deployment flow_test.\n-p specifies the name of the work-pool. Prefect provides a default work-pool named default-agent-pool.\n-q specifies the name of the work queue. We’ve named our queue test.\nprefect_demo.py:flow_hello specifies the path to the flow script, a colon, then the name of the flow function.\n\nWhen you run this command, Prefect:\n\nCreates a flow_hello-deployment.yaml file for your deployment based on your flow code and options. Usually the format is <flow_name>-deployment.yaml. You can specify a different name using the --output option.\nUploads your flow files to the configured storage location (local by default). (We’ll cover storage in a later post).\nSubmit your deployment to the work queue test. The work queue test will be created if it doesn’t exist.\n\nYou can find the yaml file in the same folder as your flow script.\n\n\nWork Queues\n\nImagine work-pool has a big highway and work-queues are lanes on the highway. Each work-queue is a separate lane on the highway. When a flow run is submitted to a work-pool, it is placed in a work-queue.\nAs different lanes in a highway have different priorities, and purpose so do work-queues. For example, you might have a work-queue for high priority flows and another for low priority flows. You can seperate your test and production flows by using different work-queues.\nBelow you’ll find a brief overview of work-queues and I highly recommend you read the official documentation\n\nWork pools have a default queue where all work is sent by default, but additional queues can be added for finer control over work delivery.\nWork queues have priorities indicated by unique positive integers, with lower numbers having higher priority. New queues can be added without affecting the priority of existing queues.\nWork queues can also have their own concurrency limits, allowing for precise control over the execution of work. However, all queues are subject to the global work pool concurrency limit.\n\n\n\nStep 3: Create a deployment on Prefect API\nNow that we have the deployment.yaml file, we can create a deployment on the Prefect API. To do this, we’ll use the prefect deployment apply Prefect CLI command.\nprefect deployment apply PATH_TO_YAML_FILE\nFor our example, the command will be:\nprefect deployment apply flow_hello-deployment.yaml\nOnce the deployment is created, you’ll see it in the CLI and the Prefect UI. Run the prefect deployment ls command to see a list of all deployments.\nprefect deployment ls\n\n\nTo view the work-pool and work-queue in the Prefect UI, navigate to the Work Pools section and click on the default-agent-pool work-pool. Click on the Work Queues tab to view the test work-queue. You’ll also notice a default work queue. This is the default work queue that Prefect creates when you create any work-pool.\n\n\n\nStep 4: Start an agent\nAgent processes are lightweight polling services that regularly check a work-pool for scheduled work and execute the corresponding flow runs.\nBy default, agents poll for work every 15 seconds. You can adjust this interval by configuring the PREFECT_AGENT_QUERY_INTERVAL setting in the profile settings.\nYou can have multiple agent processes running for a single work pool. Each agent process sends a unique ID to the server, which helps distinguish them from one another and informs users about the number of active agents.\nWe’ll use the prefect agent start command to start an agent.\nprefect agent start -p [WORK_POOL_NAME]\nFor our example, the command will be:\nprefect agent start -p default-agent-pool\n\n\nStep 5: Execute the deployment\nNow that we have an agent running, we can execute the deployment. To do this, we’ll use the prefect deployment run command.\nprefect deployment run [OPTIONS] DEPLOYMENT_NAME\nIf you don’t know the name of the deployment, you can use the prefect deployment ls command to get a list of all deployments.\nFor our example, the command will be:\nprefect deployment run hello-flow/flow_test\nAfter running the command, you’ll see the flow run in the Prefect UI. Navigate to the Flow Runs section to view the flow run. Click on the flow run to view the logs.\n\nYou can also run the flow from the Prefect UI from the Flow section.\n\nCongratulations! You’ve successfully deployed and executed your first Prefect flow. Yet there’s so much more to cover like schedules, storage, agents, workers, and more.\nCongratulations! 🎉 You’ve successfully deployed and executed your first Prefect flow. Yet there’s so much more to cover like 📅 schedules, 📦 storage, 💪 agents, workers, and more."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#deployment.yaml-file",
    "href": "posts/mlops/prefect-deployment.html#deployment.yaml-file",
    "title": "Prefect Deployment",
    "section": "deployment.yaml file",
    "text": "deployment.yaml file\nThe YAML file for a deployment contains extra settings required to create the deployment on the server.\nA single flow can have multiple deployments created for it, each with different schedules, tags, and other configurations.\nTo achieve this, you can have multiple deployment YAML files referencing the same flow definition, each specifying distinct settings. The only rule is that each deployment must have a unique name.\n\nEach deployment is linked to a specific flow, but a flow can be referenced by multiple deployments.\nDeployments are uniquely identified based on the combination of the flow name and deployment name.\nThis allows you to execute a single flow with various parameters, on multiple schedules, and in different environments. It also enables you to run different versions of the same flow for testing or production purposes."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#schedules",
    "href": "posts/mlops/prefect-deployment.html#schedules",
    "title": "Prefect Deployment",
    "section": "Schedules",
    "text": "Schedules\nSchedules allow you to instruct the Prefect API to automatically generate new flow runs for you at regular intervals.\nYou can attach a schedule to any flow deployment. The Prefect Scheduler service regularly checks each deployment and generates new flow runs based on the schedule defined for that deployment.\nThere are four recommended ways to create a schedule for a deployment:\n\nUse the Prefect UI\nUse the cron, interval, or rrule flags with the CLI deployment build command\nUse the schedule parameter with a Python deployment file\nManually edit the deployment YAML file’s schedule section\n\nPrefect offers different types of schedules that cater to various needs and provide a high level of customization:\n\nCron: This type is well-suited for users who have prior experience with cron and want to leverage its functionality.\nInterval: Ideal for deployments that require a consistent cadence of execution, irrespective of specific timestamps.\nRRule: Designed for deployments that rely on calendar-based logic, allowing for simple recurring schedules, irregular intervals, exclusions, or adjustments based on specific days of the month.\n\nThese schedule types offer flexibility and can accommodate a wide range of scheduling requirements.\nWe’ll go through an example of scheduling a flow run in the section below."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#agents-and-workers",
    "href": "posts/mlops/prefect-deployment.html#agents-and-workers",
    "title": "Prefect Deployment",
    "section": "Agents and Workers",
    "text": "Agents and Workers\nWork-pools serve as a way to organize work that agents or workers pick up for execution. The coordination between deployments and agents happens through a shared work-pool name.\nIn case you want to create a new work pool, you would have to choose the type of the work pool. Type defines the type of infrastructure that can execute runs from this work pool.\nThat’s where which polling service (Agent / Worker) is decided. View the table below to understand the difference between the two.\n\n\n\n\n\n\n\n\nWork-Pool Type\nAgent/Worker\nDescription\n\n\n\n\nAmazon Elastic Container Service\nWorker\nExecutes flow runs as ECS tasks\n\n\nAzure Container Service\nWorker\nExecutes flow runs in ACI containers\n\n\nGoogle Cloud Run\nWorker\nExecutes flow runs as Google Cloud Run jobs\n\n\nDocker\nWorker\nExecutes flow runs within Docker containers\n\n\nKubernetes\nWorker\nExecutes flow runs as Kubernetes jobs\n\n\nProcess\nWorker\nExecutes flow runs in subprocesses\n\n\nPrefect Agent\nAgent\nExecutes flow runs in subprocesses\n\n\n\nWe have seen an example of an agent in the previous section. Let’s look at an example of a worker."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#worker",
    "href": "posts/mlops/prefect-deployment.html#worker",
    "title": "Prefect Deployment",
    "section": "Worker",
    "text": "Worker\n\n\n\n\n\n\nWarning\n\n\n\nWorkers are a beta feature and are subject to change in future releases.\n\n\nWorkers are similar to Agents in that they are long-running processes that poll for work i.e., fetch scheduled runs from a work pool and carry out their execution.\nHowever, workers provide the advantage of more control over infrastructure configuration and the capability to route work to specific types of execution environments.\nEach worker is assigned a type that corresponds to the specific execution environment where it will submit flow runs. Workers can only join work pools that match their designated type. Consequently, when deployments are associated with a work pool, you can determine the execution environment in which scheduled flow runs for that deployment will be executed.\nAbove table shows the different types of workers available. Prefect also provides a way to create your own worker type."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#scheduled-flow-run-example-with-worker",
    "href": "posts/mlops/prefect-deployment.html#scheduled-flow-run-example-with-worker",
    "title": "Prefect Deployment",
    "section": "Scheduled Flow Run Example with Worker",
    "text": "Scheduled Flow Run Example with Worker\n\nStep 1: Create a new work-pool.\nprefect work-pool create [OPTIONS] NAME\nFor our example, the command will be:\nprefect work-pool create test-pool -t process\n\n-t or --type flag is used to specify the type of work-pool. In our case, we are using the process type.\n\nOn CLI you can use the command prefect work-pool ls to list all the work-pools.\n\n\n\n\nStep 2: Create a new yaml file.\nprefect deployment build -n demo_schedule -p test-pool -q demo --cron \"0 0 * * *\" --output demo_schedule.yaml prefect_demo.py:flow_hello\n\n--cron flag is used to specify the cron schedule.\n\nThis create flow runs for this deployment every day at midnight.\n\n\nStep 3: Apply the deployment.\nprefect deployment apply demo_schedule.yaml\n\n\n\n\nStep 4: Start the worker.\nprefect worker start -p test-pool\n\n\nStep 5: Execute the deployment.\nEither run the deployment from the Prefect UI or use the CLI command.\n\n\n\n\n\n\nNote\n\n\n\nOne observation you might have made is that we are using the same flow for both the deployments but with different deployments. This is because we want to run the first flow manually through CLI or UI and second on a schedule.\n\n\nFirst can be used to test the flow and second can be used to run the flow on a schedule. It completely depends on your use case.\nI hope this provides a comprehensive overview of Prefect deployment and steps to deploy a flow. Hush… there’s an abundance yet to explore."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#storage",
    "href": "posts/mlops/prefect-deployment.html#storage",
    "title": "Prefect Deployment",
    "section": "Storage",
    "text": "Storage\nPrefect follows a hybrid model where your flow code stays within your storage and execution infrastructure and never lives on the Prefect server or database. What does that mean?\nIt means that there’s always a boundary between your code, your private infrastructure, and the Prefect backend. You can use your existing storage infrastructure to store your flow code. Prefect supports a wide range of storage options like GitHub, local storage, Bitbucket, Amazon S3, Google Cloud Storage, Azure Storage, and more.\nTill now we have been using local storage to store our flow code and run the Prefect Server. However, you might choose to store the flow code in a GitHub repository and run the Prefect Server on your local machine. Prefect supports this as well.\n\nWhile creating a deployment, you can specify the storage location of your flow code. This let’s Prefect Agent/Worker know where to look for the flow code.\nOne cool thing about it is if you make changes to your flow code, you don’t have to create a new deployment. Prefect Agent/Worker will automatically pick up the changes and execute the flow with the new code.\n\n\n\n\n\n\nWarning\n\n\n\nHowever, changes to the infrastructure code will require a new deployment. Such as entrypoint. This part of changing the infrastructure code is experimental for me, I have to try it out more to better understand it.\n\n\nThis post has been a long one. Hence, I have not covered storage in detail. You can refer to the official Prefect documentation on this topic for more details. Hopefully, in the next post I will cover the remaining topics.\nWait, there is ONE more thing!"
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#prefect-projects",
    "href": "posts/mlops/prefect-deployment.html#prefect-projects",
    "title": "Prefect Deployment",
    "section": "Prefect Projects",
    "text": "Prefect Projects\n\n\n\n\n\n\nWarning\n\n\n\nProjects are a beta feature and are subject to change in future releases.\n\n\nPrefect Projects is a new feature that describe how to prepare one or more flow deployments. You can create a project using the Prefect CLI command prefect project init.\nI would encourage you to follow along in a new directory so as to seperate what we did so far from the project.\n# Create a new directory\nmkdir project\n\n# Change directory\ncd project\n\n# Create a new Prefect project\nprefect project init\nOnce you run the command, three files and a directory will be created - deployment.yaml, prefect.yaml, .prefectignore, and .prefect/ directory.\n\ndeployment.yaml: a YAML file describing base settings for deployments produced from this project\nprefect.yaml: a YAML file describing procedural steps for preparing a deployment from this project, as well as instructions for preparing the execution environment for a deployment run\n.prefect/: a hidden directory where Prefect will store workflow metadata\n.prefectignore: a file that specifies files and directories to ignore when preparing a deployment\n\nBelow we’ll go through an example of how to use Prefect Projects to create a deployment.\n\n\nStep 1: Create a new project.\nprefect project init\n\n\nStep 2: Create a flow.\nWe’ll be utilizing the same flow we created earlier but with some changes. The flow will take a name as an argument, which are called parameters to a flow in Prefect.\n\n\nprefect_demo.py\n\nimport argparse\nfrom prefect import flow, task\n\n@task(name=\"say_hello\", log_prints=True)\ndef say_hello():\n    print(\"Hello, I'm a Task!\")\n\n@flow(name=\"hello-flow\", log_prints=True)\ndef flow_hello(name: str):\n    print(f\"Hello {name}, I'm a Flow!\")\n    print(\"I'm about to call a Task...\")\n    say_hello()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--name\", help=\"Your name\", default=\"World\")\n    args = parser.parse_args()    \n    \n    flow_hello(args.name)\n\n\n\nStep 3: Start the Prefect Server.\nprefect server start\n\n\nStep 4: Start the Prefect Worker.\nprefect worker start -p test-pool\n\n\nStep 5: Configure the deployment.yaml file.\nPreviously, we created seperated files for creating a deployment and executing it.\nHowever, with Prefect Projects, we can do both in a single file. The deployment.yaml file is used to configure the deployment. Let’s look at the contents of the file.\n\n\ndeployment.yaml\n\ndeployments:\n- # base metadata\n  name: manual-deployment\n  tags: [\"test\"]\n  description: \"Trigger deployment using `run` CLI command or Prefect UI\"\n  \n  # flow-specific fields\n  entrypoint: prefect_demo.py:flow_hello\n  parameters:\n    name: \"Sagar\"\n  \n  # infra-specific fields\n  work_pool:\n    name: test-pool\n    work_queue_name: demo\n\n- # base metadata\n  name: scheduled-deployment\n  tags: [\"dev\"]\n  description: \"Trigger deployment using a Schedule\"\n  schedule:\n    cron: 0 0 * * *\n    timezone: America/Chicago\n  \n  # flow-specific fields\n  entrypoint: prefect_demo.py:flow_hello\n  parameters:\n    name: \"World\"\n  \n  # infra-specific fields\n  work_pool:\n    name: test-pool\n    work_queue_name: demo\n\n\n\nStep 6: Deploy your flow.\nThis file has two deployment declarations, each referencing a same flow in the project but with different parameters and schedule. Each deployment declaration has a unique name field and can be deployed individually by using the --name flag when deploying.\n\n\n\n\n\n\nTip\n\n\n\nYou also have the freedom to deploy different flows in the same yaml file. Example, we already have one flow file called prefect_demo.py. We can create another flow file called prefect_demo_2.py and reference it in the deployment.yaml file. Give the appropriate entrypoint and parameters and you are good to go.\n\n\nThis method of declaring multiple deployments allows the configuration for all deployments within a project to be version controlled and deployed with a single command.\nYou can deploy a single deployment by using the --name flag.\nprefect deploy --name manual-deployment\nYou can also deploy multiple deployments by providing multiple --name flags.\nprefect deploy --name manual-deployment --name scheduled-deployment\nOr, you can deploy all the deployments by using the --all flag.\nprefect deploy --all\nFor our example, we’ll deploy both the deployments.\nprefect deploy --all\nYou might have noticed that we are using the prefect deploy command instead of prefect deployment command. This is because while using Prefect Projects, prefect deploy command under the hood performs multiple steps like build, push, pull, and applies the deployment. You can read more about it here.\n\n\n\n\nStep 7: Execute the deployments.\nYou can execute a deployment either through the Prefect UI or using the CLI command.\n# Using the default parameters\nprefect deployment run hello-flow/manual-deployment\n\n# Using the custom parameters\nprefect deployment run hello-flow/manual-deployment --param name=\"Prefect\"\nOutput of the CLI command with default parameters.\n\nOutput of the CLI command with custom parameters.\n\nCongratulations! 🎉 You have successfully created your first Prefect Project.\nPrefect Project have a lot more to offer.\nI encourage you to read about Templating Options for deployment.yaml file that lets you refer dynamic value to the file. Also, read more about prefect.yaml file here."
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#references",
    "href": "posts/mlops/prefect-deployment.html#references",
    "title": "Prefect Deployment",
    "section": "References",
    "text": "References\n\nDeployments\nWork Pools, Workers & Agents\nStorage\nSchedules\nProjects\nDeployment Tutorial\nEnd-to-End Example Image"
  },
  {
    "objectID": "posts/mlops/prefect-deployment.html#conclusion",
    "href": "posts/mlops/prefect-deployment.html#conclusion",
    "title": "Prefect Deployment",
    "section": "Conclusion",
    "text": "Conclusion\nIn this post, we covered the basics of Prefect deployment and how to deploy a flow. We also covered Prefect Projects and how to use it to create a deployment. In the next post, we’ll cover storgae and deployment on Prefect Cloud.\nThank you for reading and I hope you found this notebook helpful. 👏 Upvote if you liked it, 💬 comment if you loved it. Hope to see you guys in the next one. ✌️ Peace!"
  },
  {
    "objectID": "posts/mlops/prefect-cloud.html",
    "href": "posts/mlops/prefect-cloud.html",
    "title": "Prefect Cloud Deployment",
    "section": "",
    "text": "Prefect Cloud is a hosted platform for managing your data workflows. That means you don’t have to own your own servers. We know Prefect follows a hybrid approach, which means the storage of your flow and the execution environment (prefect server) are seperate from each other.\nWhy should this matter to you? Simply, it means you can run your code on your own infrastructure keeping the code and data on your own servers. Only the metadata about the run is sent to Prefect Cloud. This is a great way to keep your data secure.\nTo understand this better, let’s look at it with an example. We’ll follow through the following steps:\nIn our example, we’ll store our code on GitHub and use the Prefect Cloud to record your runs. We’ll start the prefect worker locally and run the flow locally.\nEverytime you run the deployed flow, the worker will clone the github repo and use the code to run the flow. All the metadata about the run will be sent to Prefect Cloud.\nLet’s get started!"
  },
  {
    "objectID": "posts/mlops/prefect-cloud.html#deployment-on-prefect-cloud",
    "href": "posts/mlops/prefect-cloud.html#deployment-on-prefect-cloud",
    "title": "Prefect Cloud Deployment",
    "section": "Deployment on Prefect Cloud",
    "text": "Deployment on Prefect Cloud\n\nStep 1: Create a GitHub repo\nLogin to your GitHub account and create a new repository. Name it prefect-cloud-demo for instance.\nLocally, initialize a git repo and add the remote origin to your local repo.\n# Initialize a git repo\ngit init\n# Add the remote origin to your local repo\ngit remote add origin [your-github-repo-url]\n\n\nStep 2: Setup\nIt is a good practice to create a virtual environment for each project. This helps us keep our dependencies separate and avoid any version conflicts.\n\n\nrequirements.txt\n\nfastparquet==2023.4.0\nmlflow==2.3.1\npandas==2.0.1\nprefect==2.10.8\nscikit_learn==1.2.2\nxgboost==1.7.5\npsycopg2-binary==2.9.5\n\nLet’s create a virtual environment named venv and install all the dependencies.\n# Create a virtual environment\nconda create -p venv python=3.10 -y\n\n# Activate the virtual environment\nconda activate venv/\n\n# Install all the dependencies\npip install -r requirements.txt --no-cache-dir\n\n\nStep 3: Create a prefect project\nCreate a prefect project using the CLI.\nprefect project init\nThe folder structure of your project should look like this:\n.\n├── deployment.yaml\n├── prefect.yaml\n├── requirements.txt\n└── venv\n└── ./prefect (hidden)\n└── .prefectignore (hidden)\n\n\n\n\n\n\nNote\n\n\n\nOne thing to note here is that in the prefect.yaml file you’ll see key named pull with a value for git_clone_project. It will contain the url of your GitHub repo. It automatically gets added when you run the prefect project init command in a git repo.\nEverytime you run a deployment flow it will pull the code from the repo to run it.\n\n\n\n\nStep 3: Write a prefect flow, configure the yaml file, and push it to GitHub\nWe’ll use the same flow we created in the previous section to keep things simple.\n\n\n\"prefect_demo.py\n\nfrom prefect import flow, task\n\n@task(name=\"say_hello\", log_prints=True)\ndef say_hello():\n    print(\"Hello, I'm a Task!\")\n\n@flow(name=\"mlflow-flow\", log_prints=True)\ndef flow_hello():\n    print(\"Hello, I'm a Flow!\")\n    print(\"I'm about to call a Task...\")\n    say_hello()\n\nif __name__ == \"__main__\":\n    flow_hello()\n\nLet’s now configure the deployment.yaml file. This file tells Prefect Cloud how to deploy your flow.\n\n\ndeployment.yaml\n\ndeployments:\n- # base metadata\n  name: manual-deployment\n  tags: [\"test\"]\n  description: \"Trigger deployment using `run` CLI command or Prefect UI\"\n  \n  # flow-specific fields\n  entrypoint: prefect_demo.py:flow_hello\n  parameters:\n    name: \"Sagar\"\n  \n  # infra-specific fields\n  work_pool:\n    name: test-pool\n    work_queue_name: demo\n\nLet’s now push the code to GitHub.\n# Add all the files to git\ngit add .\n\n# Add .gitignore\ntouch .gitignore\n# Add the following to .gitignore file from https://github.com/github/gitignore/blob/main/Python.gitignore\n\n# Commit the changes\ngit commit -m \"Initial commit\"\n\n# Push the code to GitHub\ngit push -u origin main\n\n\nStep 4: Log into Prefect Cloud through CLI\nIf you haven’t already created an account on Prefect Cloud, you can do so here. Enter your email and you’ll receive a link to login to Prefect Cloud.\nNow, we’ll create a workspace in Prefect Cloud. Workspaces are only available on prefect cloud. Workspaces offer the flexibility to organize and compartmentalize your workflows according to your preferences.\nFor instance, you can leverage separate workspaces to isolate development, staging, and production environments. They also provide a means to create clear boundaries between different teams, ensuring better organization and collaboration.\nCreate a workspace named demo.\nLet’s go ahead and login to Prefect Cloud through CLI. Run the following command to see that which server you’re connected to by default.\nprefect version\nUnder the Server section, you’ll notice Database as sqlite and SQLite version mentioned. This means when you run the flow, it will create a sqlite database on your local machine and store the metadata there.\nVersion:             2.10.8\nAPI version:         0.8.4\nPython version:      3.10.11\nGit commit:          79093235\nBuilt:               Mon, May 8, 2023 12:23 PM\nOS/Arch:             darwin/x86_64\nProfile:             default\nServer type:         ephemeral\nServer:\n  Database:          sqlite\n  SQLite version:    3.41.2\nLet’s now login to Prefect Cloud through CLI. Run the following command\nprefect cloud login\nand you’ll be presented with two options:\n\nLog in with a web browser.\nPaste an API key.\n\nLet’s go ahead and login with a web browser. By default, option 1 will be highlighted and you can press enter to continue. This will open a browser window and you’ll be asked to authorize.\nOnce you’ve authorized, you’ll see a message like Authenticated with Prefect Cloud! Using workspace '[email]/demo'.\nNow if you run prefect version, you’ll see that the server has changed to cloud. This means that when you run the flow, it will upload the metadata to Prefect Cloud.\nVersion:             2.10.8\nAPI version:         0.8.4\nPython version:      3.10.11\nGit commit:          79093235\nBuilt:               Mon, May 8, 2023 12:23 PM\nOS/Arch:             darwin/x86_64\nProfile:             default\nServer type:         cloud\n\n\nStep 5: Deploy the flow to Prefect Cloud\nBefore we deploy the flow, let’s create a work pool. Follow the steps below:\n\nGo to the Work Pools tab on the left side of the screen.\nClick on the+ icon on the top middle of the screen.\nEnter the name of the work pool as test-pool.\nSelect the Local Subprocess as the Infrastructure Type.\nClick on the Create button.\n\nNow, let’s deploy the flow to Prefect Cloud. Run the following command:\nprefect deploy --name manual-deployment\n\n\nStep 6: Run the deployed flow\nTo run the deployed flow, we need a worker that will run the flow. Run the following command to start a worker:\nprefect worker start -p test-pool\nOpen a new terminal to run the flow. Now we have two options to run the deployed flow:\n\nThrough CLI\nThrough Prefect UI\n\nPreviously I have mostly used the Prefect UI to run the flow. But in this case, we’ll use the CLI to run the flow. Run the following command to run the flow:\n# Command to run the flow\nprefect deployment run [DEPLOYMENT-NAME]\n\n# In our case, the command will be\nprefect deployment run  hello-flow/manual-deployment\nIf you don’t know the name of the deployment, you can run the following command to see all the deployments:\nprefect deployment ls\nCongratulations 🎉🎉🎉! You’ve successfully deployed and run your first flow on Prefect Cloud.\nPrefect gives you the flexibility to store your code anywhere and run it anywhere. You can start the worker on local, EC2, or any other machine and run the flow.\nNow, let’s see how to run the deployment with mlflow to record the metrics."
  },
  {
    "objectID": "posts/mlops/prefect-cloud.html#run-the-deployment-with-mlflow-optional",
    "href": "posts/mlops/prefect-cloud.html#run-the-deployment-with-mlflow-optional",
    "title": "Prefect Cloud Deployment",
    "section": "Run the deployment with mlflow [Optional]",
    "text": "Run the deployment with mlflow [Optional]\nWe’ll tweak the flow a little bit to record the metrics with mlflow. The code is super super simple, however, the main take away is how to set the tracking uri and start the mlflow server to track the metrics.\n\n\nmlflow_demo.py\n\nimport mlflow\nfrom prefect import flow, task\n\n@task(name=\"mlflow-run\", log_prints=True)\ndef mlflow_run():\n  with mlflow.start_run():\n    mlflow.log_metric(\"metric\", 1.0)\n\n@flow(name=\"mlflow-flow\", log_prints=True)\ndef flow_hello():\n    mlflow.set_tracking_uri(\"http://127.0.0.1:5000\")\n    mlflow.set_experiment(\"demo\")\n    \n    print(\"Hello, I'm a Flow!\")\n    print(\"I'm about to call a Task...\")\n    mlflow_run()\n\nif __name__ == \"__main__\":\n    flow_hello()\n\nLet’s now configure the deployment.yaml file. Add the following lines to the deployment.yaml file.\n\n\ndeployment.yaml\n\n- # base metadata\n  name: mlflow-deployment\n  description: \"Trigger deployment using `run` CLI command or Prefect UI\"\n  \n  # flow-specific fields\n  entrypoint: mlflow_demo.py:flow_hello\n  \n  # infra-specific fields\n  work_pool:\n    name: test-pool\n    work_queue_name: mlflow-demo\n\nLet’s now push the code to GitHub.\n# Add all the files to git\ngit add .\n\n# Commit the changes\ngit commit -m \"Add mlflow demo\"\n\n# Push the code to GitHub\ngit push -u origin main\nNow, we’ll deploy the new flow to Prefect Cloud. Run the following command:\n# Deploy the flow\nprefect deploy --name mlflow-deployment\n\n# Checkout the deployment name\nprefect deployment ls\nWe already have a worker running. However, if you don’t have a worker running, you can start a worker by running the following command:\nprefect worker start -p test-pool\nLet’s start the mlflow server. Run the following command:\nmlflow server --backend-store-uri sqlite:///mlflow.db --default-artifact-root ./artifacts --host 127.0.0.1 --port 5000\nNow, let’s run the flow. Run the following command:\nprefect deployment run mlflow-flow/mlflow-deployment\nSome pointer to note:\n\nWe set the tracking uri and experiment name in the function where the flow begins.\n\nThis is important because if you set the tracking uri and experiment name in the __main__ function, it will not work.\nWhen you run the flow, it runs the function where the flow begins.\nIn our case, it’s the flow_hello function.\n\nWe set the tracking uri to http://127.0.0.1:5000 because we ran the server locally, however if you run the server on EC2 or any other machine, you need to set the tracking uri accordingly.\nTo start the mlflow server we used the backend store as sqlite db and artifacts directory to store the artifacts.\nWe also specified the host and post so as to map the mlflow server to the same port where we set the tracking uri.\n\nLastly, if you want to logout from the Prefect Cloud, run the following command:\nprefect cloud logout"
  },
  {
    "objectID": "posts/mlops/prefect-cloud.html#conclusion",
    "href": "posts/mlops/prefect-cloud.html#conclusion",
    "title": "Prefect Cloud Deployment",
    "section": "Conclusion",
    "text": "Conclusion\nIn this article, we learned how to deploy a flow to Prefect Cloud and run it. We also learned how to run the flow with mlflow to record the metrics.\nI hope you enjoyed this article. If you have any questions, feel free to reach out to me on Twitter or Email.\n👏 Upvote if you liked it, 💬 comment if you loved it. Hope to see you guys in the next one. ✌️ Peace!"
  },
  {
    "objectID": "posts/mlops/prefect-cloud.html#references",
    "href": "posts/mlops/prefect-cloud.html#references",
    "title": "Prefect Cloud Deployment",
    "section": "References",
    "text": "References\n\nPrefect Cloud Docs\nImage Source"
  },
  {
    "objectID": "index.html#subscribe",
    "href": "index.html#subscribe",
    "title": "Sagar Thacker",
    "section": "Subscribe",
    "text": "Subscribe\n\n\n“Don’t focus on having a great blog. Focus on producing a blog that’s great for your readers.” - Brian Clark\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nPrefect Cloud Deployment\n\n\n\n\n\n\n\nMLOps\n\n\nPrefect\n\n\nDeployment\n\n\nPrefect-Cloud\n\n\n\n\nA comprehensive guide to deploying Prefect Flows on Prefect Cloud\n\n\n\n\n\n\nJun 16, 2023\n\n\n9 min\n\n\n\n\n\n\n  \n\n\n\n\nPrefect Deployment\n\n\n\n\n\n\n\nMLOps\n\n\nPrefect\n\n\nDeployment\n\n\n\n\nA comprehensive guide to deploying Prefect Flows\n\n\n\n\n\n\nJun 11, 2023\n\n\n18 min\n\n\n\n\n\n\n  \n\n\n\n\nPrefect Blocks\n\n\n\n\n\n\n\nMLOps\n\n\nPrefect\n\n\n\n\nPrefect Blocks are reusable, composable building blocks for orchestrating data workflows.\n\n\n\n\n\n\nJun 7, 2023\n\n\n11 min\n\n\n\n\n\n\n  \n\n\n\n\nPrefect: An Workflow Orchestration Tool\n\n\n\n\n\n\n\nMLOps\n\n\nPrefect\n\n\n\n\nPrefect is an open-source workflow orchestration tool that helps you automate and manage the flow of work across your data stack.\n\n\n\n\n\n\nJun 5, 2023\n\n\n19 min\n\n\n\n\n\n\n  \n\n\n\n\nMLflow on AWS\n\n\n\n\n\n\n\nMLOps\n\n\nMLflow\n\n\nAWS\n\n\n\n\nDiscover the implementation of MLflow on AWS, leveraging EC2 to host MLFlow Server, S3 for artifact storage and RDS-PostgreSQL for backend entity storager.\n\n\n\n\n\n\nMay 30, 2023\n\n\n6 min\n\n\n\n\n\n\n  \n\n\n\n\nIntroduction to MLflow\n\n\n\n\n\n\n\nMLOps\n\n\nMLflow\n\n\n\n\nLearn how MLflow simplifies experiment tracking, model versioning, and deployment for efficient machine learning development.\n\n\n\n\n\n\nMay 28, 2023\n\n\n9 min\n\n\n\n\n\n\n  \n\n\n\n\nAWS Instance Setup\n\n\n\n\n\n\n\nAWS\n\n\n\n\nStep-by-step guide to setup AWS EC2 Instance and setup environment\n\n\n\n\n\n\nMay 19, 2023\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\nIntroduction to MLOps\n\n\n\n\n\n\n\nMLOps\n\n\n\n\nLearn how to combine machine learning with software engineering to develop, deploy & maintain production ML applications.\n\n\n\n\n\n\nMay 18, 2023\n\n\n7 min\n\n\n\n\n\n\n  \n\n\n\n\nEDA - Playground Series Season 3, Episode 4\n\n\n\n\n\n\n\nKaggle\n\n\n\n\nTabular Classification with a Credit Card Fraud Dataset\n\n\n\n\n\n\nJan 30, 2023\n\n\n4 min\n\n\n\n\n\n\n  \n\n\n\n\nModeling - Playground Series Season 3, Episode 4\n\n\n\n\n\n\n\nKaggle\n\n\n\n\nTabular Classification with a Credit Card Fraud Dataset\n\n\n\n\n\n\nJan 30, 2023\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\nMovie Lens - Collaborative Filtering based Recommendation System\n\n\n\n\n\n\n\nPySpark\n\n\n\n\nMovie Recommendation Using PySpark\n\n\n\n\n\n\nJan 20, 2022\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\nSong Popularity EDA\n\n\n\n\n\n\n\nKaggle\n\n\n\n\nSong Popularity Prediction is a competition on Kaggle. This post is all about performing exploratory data analysis following the coding session by Martin Henze.\n\n\n\n\n\n\nMay 31, 2021\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\nText Preprocessing\n\n\n\n\n\n\n\nText Preprocessing\n\n\nNatural Language Processing\n\n\nNLP\n\n\n\n\nVairous preprocessing steps required to clean and prepare your data in NLP\n\n\n\n\n\n\nApr 19, 2021\n\n\n9 min\n\n\n\n\n\n\n  \n\n\n\n\nWhat is Natural Language Processing?\n\n\n\n\n\n\n\nNatural Language Processing\n\n\nNLP\n\n\n\n\nA brief summary of what is natural language processing, it’s challenges and applications.\n\n\n\n\n\n\nApr 12, 2021\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\nPath to become a Machine Learning Expert\n\n\n\n\n\n\n\nMachine Learning\n\n\nLearning Path\n\n\n\n\nComprehensive learning path to become an expert in Machine Learning\n\n\n\n\n\n\nApr 5, 2021\n\n\n7 min\n\n\n\n\n\n\nNo matching items"
  }
]